"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jimp";
exports.ids = ["vendor-chunks/@jimp"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@jimp/bmp/es/index.js":
/*!********************************************!*\
  !*** ./node_modules/@jimp/bmp/es/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var bmp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bmp-js */ \"(action-browser)/./node_modules/bmp-js/index.js\");\n/* harmony import */ var bmp_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bmp_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\nconst MIME_TYPE = \"image/bmp\";\nconst MIME_TYPE_SECOND = \"image/x-ms-bmp\";\nfunction toAGBR(image) {\n  return (0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.scan)(image, 0, 0, image.bitmap.width, image.bitmap.height, function (x, y, index) {\n    const red = this.bitmap.data[index + 0];\n    const green = this.bitmap.data[index + 1];\n    const blue = this.bitmap.data[index + 2];\n    const alpha = this.bitmap.data[index + 3];\n    this.bitmap.data[index + 0] = alpha;\n    this.bitmap.data[index + 1] = blue;\n    this.bitmap.data[index + 2] = green;\n    this.bitmap.data[index + 3] = red;\n  }).bitmap;\n}\nfunction fromAGBR(bitmap) {\n  return (0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.scan)({\n    bitmap\n  }, 0, 0, bitmap.width, bitmap.height, function (x, y, index) {\n    const alpha = this.bitmap.data[index + 0];\n    const blue = this.bitmap.data[index + 1];\n    const green = this.bitmap.data[index + 2];\n    const red = this.bitmap.data[index + 3];\n    this.bitmap.data[index + 0] = red;\n    this.bitmap.data[index + 1] = green;\n    this.bitmap.data[index + 2] = blue;\n    this.bitmap.data[index + 3] = bitmap.is_with_alpha ? alpha : 0xff;\n  }).bitmap;\n}\nconst decode = data => fromAGBR(bmp_js__WEBPACK_IMPORTED_MODULE_0___default().decode(data));\nconst encode = image => bmp_js__WEBPACK_IMPORTED_MODULE_0___default().encode(toAGBR(image)).data;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  mime: {\n    [MIME_TYPE]: [\"bmp\"]\n  },\n  constants: {\n    MIME_BMP: MIME_TYPE,\n    MIME_X_MS_BMP: MIME_TYPE_SECOND\n  },\n  decoders: {\n    [MIME_TYPE]: decode,\n    [MIME_TYPE_SECOND]: decode\n  },\n  encoders: {\n    [MIME_TYPE]: encode,\n    [MIME_TYPE_SECOND]: encode\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9ibXAvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QjtBQUNVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaURBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLGlEQUFJO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxvREFBVTtBQUMxQyx3QkFBd0Isb0RBQVU7QUFDbEMsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9ibXAvZXMvaW5kZXguanM/N2Q1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQk1QIGZyb20gXCJibXAtanNcIjtcbmltcG9ydCB7IHNjYW4gfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbmNvbnN0IE1JTUVfVFlQRSA9IFwiaW1hZ2UvYm1wXCI7XG5jb25zdCBNSU1FX1RZUEVfU0VDT05EID0gXCJpbWFnZS94LW1zLWJtcFwiO1xuZnVuY3Rpb24gdG9BR0JSKGltYWdlKSB7XG4gIHJldHVybiBzY2FuKGltYWdlLCAwLCAwLCBpbWFnZS5iaXRtYXAud2lkdGgsIGltYWdlLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpbmRleCkge1xuICAgIGNvbnN0IHJlZCA9IHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAwXTtcbiAgICBjb25zdCBncmVlbiA9IHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAxXTtcbiAgICBjb25zdCBibHVlID0gdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDJdO1xuICAgIGNvbnN0IGFscGhhID0gdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDNdO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAwXSA9IGFscGhhO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAxXSA9IGJsdWU7XG4gICAgdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDJdID0gZ3JlZW47XG4gICAgdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDNdID0gcmVkO1xuICB9KS5iaXRtYXA7XG59XG5mdW5jdGlvbiBmcm9tQUdCUihiaXRtYXApIHtcbiAgcmV0dXJuIHNjYW4oe1xuICAgIGJpdG1hcFxuICB9LCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpbmRleCkge1xuICAgIGNvbnN0IGFscGhhID0gdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDBdO1xuICAgIGNvbnN0IGJsdWUgPSB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMV07XG4gICAgY29uc3QgZ3JlZW4gPSB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMl07XG4gICAgY29uc3QgcmVkID0gdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDNdO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAwXSA9IHJlZDtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMV0gPSBncmVlbjtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMl0gPSBibHVlO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAzXSA9IGJpdG1hcC5pc193aXRoX2FscGhhID8gYWxwaGEgOiAweGZmO1xuICB9KS5iaXRtYXA7XG59XG5jb25zdCBkZWNvZGUgPSBkYXRhID0+IGZyb21BR0JSKEJNUC5kZWNvZGUoZGF0YSkpO1xuY29uc3QgZW5jb2RlID0gaW1hZ2UgPT4gQk1QLmVuY29kZSh0b0FHQlIoaW1hZ2UpKS5kYXRhO1xuZXhwb3J0IGRlZmF1bHQgKCgpID0+ICh7XG4gIG1pbWU6IHtcbiAgICBbTUlNRV9UWVBFXTogW1wiYm1wXCJdXG4gIH0sXG4gIGNvbnN0YW50czoge1xuICAgIE1JTUVfQk1QOiBNSU1FX1RZUEUsXG4gICAgTUlNRV9YX01TX0JNUDogTUlNRV9UWVBFX1NFQ09ORFxuICB9LFxuICBkZWNvZGVyczoge1xuICAgIFtNSU1FX1RZUEVdOiBkZWNvZGUsXG4gICAgW01JTUVfVFlQRV9TRUNPTkRdOiBkZWNvZGVcbiAgfSxcbiAgZW5jb2RlcnM6IHtcbiAgICBbTUlNRV9UWVBFXTogZW5jb2RlLFxuICAgIFtNSU1FX1RZUEVfU0VDT05EXTogZW5jb2RlXG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/bmp/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/composite/composite-modes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@jimp/core/es/composite/composite-modes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   darken: () => (/* binding */ darken),\n/* harmony export */   difference: () => (/* binding */ difference),\n/* harmony export */   dstOver: () => (/* binding */ dstOver),\n/* harmony export */   exclusion: () => (/* binding */ exclusion),\n/* harmony export */   hardLight: () => (/* binding */ hardLight),\n/* harmony export */   lighten: () => (/* binding */ lighten),\n/* harmony export */   multiply: () => (/* binding */ multiply),\n/* harmony export */   overlay: () => (/* binding */ overlay),\n/* harmony export */   screen: () => (/* binding */ screen),\n/* harmony export */   srcOver: () => (/* binding */ srcOver)\n/* harmony export */ });\nfunction srcOver(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;\n  const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;\n  const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction dstOver(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;\n  const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;\n  const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction multiply(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;\n  const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;\n  const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction add(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (sra + dra) / a;\n  const g = (sga + dga) / a;\n  const b = (sba + dba) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction screen(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;\n  const g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;\n  const b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction overlay(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;\n  const g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;\n  const b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction darken(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;\n  const g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;\n  const b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction lighten(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;\n  const g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;\n  const b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction hardLight(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;\n  const g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;\n  const b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction difference(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;\n  const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;\n  const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction exclusion(src, dst) {\n  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  src.a *= ops;\n  const a = dst.a + src.a - dst.a * src.a;\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n  const r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;\n  const g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;\n  const b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\n//# sourceMappingURL=composite-modes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL2NvbXBvc2l0ZS9jb21wb3NpdGUtbW9kZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvY29yZS9lcy9jb21wb3NpdGUvY29tcG9zaXRlLW1vZGVzLmpzPzc4ODIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHNyY092ZXIoc3JjLCBkc3QpIHtcbiAgbGV0IG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgc3JjLmEgKj0gb3BzO1xuICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gIGNvbnN0IHIgPSAoc3JjLnIgKiBzcmMuYSArIGRzdC5yICogZHN0LmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICBjb25zdCBnID0gKHNyYy5nICogc3JjLmEgKyBkc3QuZyAqIGRzdC5hICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgY29uc3QgYiA9IChzcmMuYiAqIHNyYy5hICsgZHN0LmIgKiBkc3QuYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIHJldHVybiB7XG4gICAgcixcbiAgICBnLFxuICAgIGIsXG4gICAgYVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRzdE92ZXIoc3JjLCBkc3QpIHtcbiAgbGV0IG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgc3JjLmEgKj0gb3BzO1xuICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gIGNvbnN0IHIgPSAoZHN0LnIgKiBkc3QuYSArIHNyYy5yICogc3JjLmEgKiAoMSAtIGRzdC5hKSkgLyBhO1xuICBjb25zdCBnID0gKGRzdC5nICogZHN0LmEgKyBzcmMuZyAqIHNyYy5hICogKDEgLSBkc3QuYSkpIC8gYTtcbiAgY29uc3QgYiA9IChkc3QuYiAqIGRzdC5hICsgc3JjLmIgKiBzcmMuYSAqICgxIC0gZHN0LmEpKSAvIGE7XG4gIHJldHVybiB7XG4gICAgcixcbiAgICBnLFxuICAgIGIsXG4gICAgYVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KHNyYywgZHN0KSB7XG4gIGxldCBvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHNyYy5hICo9IG9wcztcbiAgY29uc3QgYSA9IGRzdC5hICsgc3JjLmEgLSBkc3QuYSAqIHNyYy5hO1xuICBjb25zdCBzcmEgPSBzcmMuciAqIHNyYy5hO1xuICBjb25zdCBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICBjb25zdCBzYmEgPSBzcmMuYiAqIHNyYy5hO1xuICBjb25zdCBkcmEgPSBkc3QuciAqIGRzdC5hO1xuICBjb25zdCBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICBjb25zdCBkYmEgPSBkc3QuYiAqIGRzdC5hO1xuICBjb25zdCByID0gKHNyYSAqIGRyYSArIHNyYSAqICgxIC0gZHN0LmEpICsgZHJhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgY29uc3QgZyA9IChzZ2EgKiBkZ2EgKyBzZ2EgKiAoMSAtIGRzdC5hKSArIGRnYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIGNvbnN0IGIgPSAoc2JhICogZGJhICsgc2JhICogKDEgLSBkc3QuYSkgKyBkYmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICByZXR1cm4ge1xuICAgIHIsXG4gICAgZyxcbiAgICBiLFxuICAgIGFcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGQoc3JjLCBkc3QpIHtcbiAgbGV0IG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgc3JjLmEgKj0gb3BzO1xuICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gIGNvbnN0IHNyYSA9IHNyYy5yICogc3JjLmE7XG4gIGNvbnN0IHNnYSA9IHNyYy5nICogc3JjLmE7XG4gIGNvbnN0IHNiYSA9IHNyYy5iICogc3JjLmE7XG4gIGNvbnN0IGRyYSA9IGRzdC5yICogZHN0LmE7XG4gIGNvbnN0IGRnYSA9IGRzdC5nICogZHN0LmE7XG4gIGNvbnN0IGRiYSA9IGRzdC5iICogZHN0LmE7XG4gIGNvbnN0IHIgPSAoc3JhICsgZHJhKSAvIGE7XG4gIGNvbnN0IGcgPSAoc2dhICsgZGdhKSAvIGE7XG4gIGNvbnN0IGIgPSAoc2JhICsgZGJhKSAvIGE7XG4gIHJldHVybiB7XG4gICAgcixcbiAgICBnLFxuICAgIGIsXG4gICAgYVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNjcmVlbihzcmMsIGRzdCkge1xuICBsZXQgb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICBzcmMuYSAqPSBvcHM7XG4gIGNvbnN0IGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgY29uc3Qgc3JhID0gc3JjLnIgKiBzcmMuYTtcbiAgY29uc3Qgc2dhID0gc3JjLmcgKiBzcmMuYTtcbiAgY29uc3Qgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgY29uc3QgZHJhID0gZHN0LnIgKiBkc3QuYTtcbiAgY29uc3QgZGdhID0gZHN0LmcgKiBkc3QuYTtcbiAgY29uc3QgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgY29uc3QgciA9IChzcmEgKiBkc3QuYSArIGRyYSAqIHNyYy5hIC0gc3JhICogZHJhICsgc3JhICogKDEgLSBkc3QuYSkgKyBkcmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICBjb25zdCBnID0gKHNnYSAqIGRzdC5hICsgZGdhICogc3JjLmEgLSBzZ2EgKiBkZ2EgKyBzZ2EgKiAoMSAtIGRzdC5hKSArIGRnYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIGNvbnN0IGIgPSAoc2JhICogZHN0LmEgKyBkYmEgKiBzcmMuYSAtIHNiYSAqIGRiYSArIHNiYSAqICgxIC0gZHN0LmEpICsgZGJhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgcmV0dXJuIHtcbiAgICByLFxuICAgIGcsXG4gICAgYixcbiAgICBhXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gb3ZlcmxheShzcmMsIGRzdCkge1xuICBsZXQgb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICBzcmMuYSAqPSBvcHM7XG4gIGNvbnN0IGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgY29uc3Qgc3JhID0gc3JjLnIgKiBzcmMuYTtcbiAgY29uc3Qgc2dhID0gc3JjLmcgKiBzcmMuYTtcbiAgY29uc3Qgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgY29uc3QgZHJhID0gZHN0LnIgKiBkc3QuYTtcbiAgY29uc3QgZGdhID0gZHN0LmcgKiBkc3QuYTtcbiAgY29uc3QgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgY29uc3QgciA9ICgyICogZHJhIDw9IGRzdC5hID8gMiAqIHNyYSAqIGRyYSArIHNyYSAqICgxIC0gZHN0LmEpICsgZHJhICogKDEgLSBzcmMuYSkgOiBzcmEgKiAoMSArIGRzdC5hKSArIGRyYSAqICgxICsgc3JjLmEpIC0gMiAqIGRyYSAqIHNyYSAtIGRzdC5hICogc3JjLmEpIC8gYTtcbiAgY29uc3QgZyA9ICgyICogZGdhIDw9IGRzdC5hID8gMiAqIHNnYSAqIGRnYSArIHNnYSAqICgxIC0gZHN0LmEpICsgZGdhICogKDEgLSBzcmMuYSkgOiBzZ2EgKiAoMSArIGRzdC5hKSArIGRnYSAqICgxICsgc3JjLmEpIC0gMiAqIGRnYSAqIHNnYSAtIGRzdC5hICogc3JjLmEpIC8gYTtcbiAgY29uc3QgYiA9ICgyICogZGJhIDw9IGRzdC5hID8gMiAqIHNiYSAqIGRiYSArIHNiYSAqICgxIC0gZHN0LmEpICsgZGJhICogKDEgLSBzcmMuYSkgOiBzYmEgKiAoMSArIGRzdC5hKSArIGRiYSAqICgxICsgc3JjLmEpIC0gMiAqIGRiYSAqIHNiYSAtIGRzdC5hICogc3JjLmEpIC8gYTtcbiAgcmV0dXJuIHtcbiAgICByLFxuICAgIGcsXG4gICAgYixcbiAgICBhXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGFya2VuKHNyYywgZHN0KSB7XG4gIGxldCBvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHNyYy5hICo9IG9wcztcbiAgY29uc3QgYSA9IGRzdC5hICsgc3JjLmEgLSBkc3QuYSAqIHNyYy5hO1xuICBjb25zdCBzcmEgPSBzcmMuciAqIHNyYy5hO1xuICBjb25zdCBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICBjb25zdCBzYmEgPSBzcmMuYiAqIHNyYy5hO1xuICBjb25zdCBkcmEgPSBkc3QuciAqIGRzdC5hO1xuICBjb25zdCBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICBjb25zdCBkYmEgPSBkc3QuYiAqIGRzdC5hO1xuICBjb25zdCByID0gKE1hdGgubWluKHNyYSAqIGRzdC5hLCBkcmEgKiBzcmMuYSkgKyBzcmEgKiAoMSAtIGRzdC5hKSArIGRyYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIGNvbnN0IGcgPSAoTWF0aC5taW4oc2dhICogZHN0LmEsIGRnYSAqIHNyYy5hKSArIHNnYSAqICgxIC0gZHN0LmEpICsgZGdhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgY29uc3QgYiA9IChNYXRoLm1pbihzYmEgKiBkc3QuYSwgZGJhICogc3JjLmEpICsgc2JhICogKDEgLSBkc3QuYSkgKyBkYmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICByZXR1cm4ge1xuICAgIHIsXG4gICAgZyxcbiAgICBiLFxuICAgIGFcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsaWdodGVuKHNyYywgZHN0KSB7XG4gIGxldCBvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHNyYy5hICo9IG9wcztcbiAgY29uc3QgYSA9IGRzdC5hICsgc3JjLmEgLSBkc3QuYSAqIHNyYy5hO1xuICBjb25zdCBzcmEgPSBzcmMuciAqIHNyYy5hO1xuICBjb25zdCBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICBjb25zdCBzYmEgPSBzcmMuYiAqIHNyYy5hO1xuICBjb25zdCBkcmEgPSBkc3QuciAqIGRzdC5hO1xuICBjb25zdCBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICBjb25zdCBkYmEgPSBkc3QuYiAqIGRzdC5hO1xuICBjb25zdCByID0gKE1hdGgubWF4KHNyYSAqIGRzdC5hLCBkcmEgKiBzcmMuYSkgKyBzcmEgKiAoMSAtIGRzdC5hKSArIGRyYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gIGNvbnN0IGcgPSAoTWF0aC5tYXgoc2dhICogZHN0LmEsIGRnYSAqIHNyYy5hKSArIHNnYSAqICgxIC0gZHN0LmEpICsgZGdhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgY29uc3QgYiA9IChNYXRoLm1heChzYmEgKiBkc3QuYSwgZGJhICogc3JjLmEpICsgc2JhICogKDEgLSBkc3QuYSkgKyBkYmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICByZXR1cm4ge1xuICAgIHIsXG4gICAgZyxcbiAgICBiLFxuICAgIGFcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXJkTGlnaHQoc3JjLCBkc3QpIHtcbiAgbGV0IG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgc3JjLmEgKj0gb3BzO1xuICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gIGNvbnN0IHNyYSA9IHNyYy5yICogc3JjLmE7XG4gIGNvbnN0IHNnYSA9IHNyYy5nICogc3JjLmE7XG4gIGNvbnN0IHNiYSA9IHNyYy5iICogc3JjLmE7XG4gIGNvbnN0IGRyYSA9IGRzdC5yICogZHN0LmE7XG4gIGNvbnN0IGRnYSA9IGRzdC5nICogZHN0LmE7XG4gIGNvbnN0IGRiYSA9IGRzdC5iICogZHN0LmE7XG4gIGNvbnN0IHIgPSAoMiAqIHNyYSA8PSBzcmMuYSA/IDIgKiBzcmEgKiBkcmEgKyBzcmEgKiAoMSAtIGRzdC5hKSArIGRyYSAqICgxIC0gc3JjLmEpIDogc3JhICogKDEgKyBkc3QuYSkgKyBkcmEgKiAoMSArIHNyYy5hKSAtIDIgKiBkcmEgKiBzcmEgLSBkc3QuYSAqIHNyYy5hKSAvIGE7XG4gIGNvbnN0IGcgPSAoMiAqIHNnYSA8PSBzcmMuYSA/IDIgKiBzZ2EgKiBkZ2EgKyBzZ2EgKiAoMSAtIGRzdC5hKSArIGRnYSAqICgxIC0gc3JjLmEpIDogc2dhICogKDEgKyBkc3QuYSkgKyBkZ2EgKiAoMSArIHNyYy5hKSAtIDIgKiBkZ2EgKiBzZ2EgLSBkc3QuYSAqIHNyYy5hKSAvIGE7XG4gIGNvbnN0IGIgPSAoMiAqIHNiYSA8PSBzcmMuYSA/IDIgKiBzYmEgKiBkYmEgKyBzYmEgKiAoMSAtIGRzdC5hKSArIGRiYSAqICgxIC0gc3JjLmEpIDogc2JhICogKDEgKyBkc3QuYSkgKyBkYmEgKiAoMSArIHNyYy5hKSAtIDIgKiBkYmEgKiBzYmEgLSBkc3QuYSAqIHNyYy5hKSAvIGE7XG4gIHJldHVybiB7XG4gICAgcixcbiAgICBnLFxuICAgIGIsXG4gICAgYVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZlcmVuY2Uoc3JjLCBkc3QpIHtcbiAgbGV0IG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgc3JjLmEgKj0gb3BzO1xuICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gIGNvbnN0IHNyYSA9IHNyYy5yICogc3JjLmE7XG4gIGNvbnN0IHNnYSA9IHNyYy5nICogc3JjLmE7XG4gIGNvbnN0IHNiYSA9IHNyYy5iICogc3JjLmE7XG4gIGNvbnN0IGRyYSA9IGRzdC5yICogZHN0LmE7XG4gIGNvbnN0IGRnYSA9IGRzdC5nICogZHN0LmE7XG4gIGNvbnN0IGRiYSA9IGRzdC5iICogZHN0LmE7XG4gIGNvbnN0IHIgPSAoc3JhICsgZHJhIC0gMiAqIE1hdGgubWluKHNyYSAqIGRzdC5hLCBkcmEgKiBzcmMuYSkpIC8gYTtcbiAgY29uc3QgZyA9IChzZ2EgKyBkZ2EgLSAyICogTWF0aC5taW4oc2dhICogZHN0LmEsIGRnYSAqIHNyYy5hKSkgLyBhO1xuICBjb25zdCBiID0gKHNiYSArIGRiYSAtIDIgKiBNYXRoLm1pbihzYmEgKiBkc3QuYSwgZGJhICogc3JjLmEpKSAvIGE7XG4gIHJldHVybiB7XG4gICAgcixcbiAgICBnLFxuICAgIGIsXG4gICAgYVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1c2lvbihzcmMsIGRzdCkge1xuICBsZXQgb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICBzcmMuYSAqPSBvcHM7XG4gIGNvbnN0IGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgY29uc3Qgc3JhID0gc3JjLnIgKiBzcmMuYTtcbiAgY29uc3Qgc2dhID0gc3JjLmcgKiBzcmMuYTtcbiAgY29uc3Qgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgY29uc3QgZHJhID0gZHN0LnIgKiBkc3QuYTtcbiAgY29uc3QgZGdhID0gZHN0LmcgKiBkc3QuYTtcbiAgY29uc3QgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgY29uc3QgciA9IChzcmEgKiBkc3QuYSArIGRyYSAqIHNyYy5hIC0gMiAqIHNyYSAqIGRyYSArIHNyYSAqICgxIC0gZHN0LmEpICsgZHJhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgY29uc3QgZyA9IChzZ2EgKiBkc3QuYSArIGRnYSAqIHNyYy5hIC0gMiAqIHNnYSAqIGRnYSArIHNnYSAqICgxIC0gZHN0LmEpICsgZGdhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgY29uc3QgYiA9IChzYmEgKiBkc3QuYSArIGRiYSAqIHNyYy5hIC0gMiAqIHNiYSAqIGRiYSArIHNiYSAqICgxIC0gZHN0LmEpICsgZGJhICogKDEgLSBzcmMuYSkpIC8gYTtcbiAgcmV0dXJuIHtcbiAgICByLFxuICAgIGcsXG4gICAgYixcbiAgICBhXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb3NpdGUtbW9kZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/composite/composite-modes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/composite/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jimp/core/es/composite/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ composite)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"(action-browser)/./node_modules/@jimp/core/es/constants.js\");\n/* harmony import */ var _composite_modes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./composite-modes */ \"(action-browser)/./node_modules/@jimp/core/es/composite/composite-modes.js\");\n\n\n\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nfunction composite(src, x, y) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let cb = arguments.length > 4 ? arguments[4] : undefined;\n  if (typeof options === \"function\") {\n    cb = options;\n    options = {};\n  }\n  if (!(src instanceof this.constructor)) {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"The source must be a Jimp image\", cb);\n  }\n  if (typeof x !== \"number\" || typeof y !== \"number\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"x and y must be numbers\", cb);\n  }\n  let {\n    mode,\n    opacitySource,\n    opacityDest\n  } = options;\n  if (!mode) {\n    mode = _constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_SOURCE_OVER;\n  }\n  if (typeof opacitySource !== \"number\" || opacitySource < 0 || opacitySource > 1) {\n    opacitySource = 1.0;\n  }\n  if (typeof opacityDest !== \"number\" || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n\n  // eslint-disable-next-line import/namespace\n  const blendmode = _composite_modes__WEBPACK_IMPORTED_MODULE_2__[mode];\n\n  // round input\n  x = Math.round(x);\n  y = Math.round(y);\n  const baseImage = this;\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {\n    const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, _constants__WEBPACK_IMPORTED_MODULE_1__.EDGE_CROP);\n    if (dstIdx === -1) {\n      // Skip target pixels outside of dst\n      return;\n    }\n    const blended = blendmode({\n      r: this.bitmap.data[idx + 0] / 255,\n      g: this.bitmap.data[idx + 1] / 255,\n      b: this.bitmap.data[idx + 2] / 255,\n      a: this.bitmap.data[idx + 3] / 255\n    }, {\n      r: baseImage.bitmap.data[dstIdx + 0] / 255,\n      g: baseImage.bitmap.data[dstIdx + 1] / 255,\n      b: baseImage.bitmap.data[dstIdx + 2] / 255,\n      a: baseImage.bitmap.data[dstIdx + 3] / 255\n    }, opacitySource);\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);\n  });\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL2NvbXBvc2l0ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdEO0FBQ2Q7QUFDVTs7QUFFcEQ7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLE1BQU07QUFDbkI7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0EsV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsV0FBVyx5REFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsNkNBQWM7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaURBQW1CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxNQUFNLDBEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL2NvbXBvc2l0ZS9pbmRleC5qcz9lZWU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTm9kZVBhdHRlcm4sIHRocm93RXJyb3IgfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgKiBhcyBjb21wb3NpdGVNb2RlcyBmcm9tIFwiLi9jb21wb3NpdGUtbW9kZXNcIjtcblxuLyoqXG4gKiBDb21wb3NpdGVzIGEgc291cmNlIGltYWdlIG92ZXIgdG8gdGhpcyBpbWFnZSByZXNwZWN0aW5nIGFscGhhIGNoYW5uZWxzXG4gKiBAcGFyYW0ge0ppbXB9IHNyYyB0aGUgc291cmNlIEppbXAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSB4IHBvc2l0aW9uIHRvIGJsaXQgdGhlIGltYWdlXG4gKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBwb3NpdGlvbiB0byBibGl0IHRoZSBpbWFnZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgZGV0ZXJtaW5lIHdoYXQgbW9kZSB0byB1c2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2l0ZShzcmMsIHgsIHkpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBsZXQgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmICghKHNyYyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIlRoZSBzb3VyY2UgbXVzdCBiZSBhIEppbXAgaW1hZ2VcIiwgY2IpO1xuICB9XG4gIGlmICh0eXBlb2YgeCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSAhPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ4IGFuZCB5IG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gIH1cbiAgbGV0IHtcbiAgICBtb2RlLFxuICAgIG9wYWNpdHlTb3VyY2UsXG4gICAgb3BhY2l0eURlc3RcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghbW9kZSkge1xuICAgIG1vZGUgPSBjb25zdGFudHMuQkxFTkRfU09VUkNFX09WRVI7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcGFjaXR5U291cmNlICE9PSBcIm51bWJlclwiIHx8IG9wYWNpdHlTb3VyY2UgPCAwIHx8IG9wYWNpdHlTb3VyY2UgPiAxKSB7XG4gICAgb3BhY2l0eVNvdXJjZSA9IDEuMDtcbiAgfVxuICBpZiAodHlwZW9mIG9wYWNpdHlEZXN0ICE9PSBcIm51bWJlclwiIHx8IG9wYWNpdHlEZXN0IDwgMCB8fCBvcGFjaXR5RGVzdCA+IDEpIHtcbiAgICBvcGFjaXR5RGVzdCA9IDEuMDtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbmFtZXNwYWNlXG4gIGNvbnN0IGJsZW5kbW9kZSA9IGNvbXBvc2l0ZU1vZGVzW21vZGVdO1xuXG4gIC8vIHJvdW5kIGlucHV0XG4gIHggPSBNYXRoLnJvdW5kKHgpO1xuICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgY29uc3QgYmFzZUltYWdlID0gdGhpcztcbiAgaWYgKG9wYWNpdHlEZXN0ICE9PSAxLjApIHtcbiAgICBiYXNlSW1hZ2Uub3BhY2l0eShvcGFjaXR5RGVzdCk7XG4gIH1cbiAgc3JjLnNjYW5RdWlldCgwLCAwLCBzcmMuYml0bWFwLndpZHRoLCBzcmMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHN4LCBzeSwgaWR4KSB7XG4gICAgY29uc3QgZHN0SWR4ID0gYmFzZUltYWdlLmdldFBpeGVsSW5kZXgoeCArIHN4LCB5ICsgc3ksIGNvbnN0YW50cy5FREdFX0NST1ApO1xuICAgIGlmIChkc3RJZHggPT09IC0xKSB7XG4gICAgICAvLyBTa2lwIHRhcmdldCBwaXhlbHMgb3V0c2lkZSBvZiBkc3RcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmxlbmRlZCA9IGJsZW5kbW9kZSh7XG4gICAgICByOiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDBdIC8gMjU1LFxuICAgICAgZzogdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSAvIDI1NSxcbiAgICAgIGI6IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gLyAyNTUsXG4gICAgICBhOiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdIC8gMjU1XG4gICAgfSwge1xuICAgICAgcjogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDBdIC8gMjU1LFxuICAgICAgZzogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDFdIC8gMjU1LFxuICAgICAgYjogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDJdIC8gMjU1LFxuICAgICAgYTogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDNdIC8gMjU1XG4gICAgfSwgb3BhY2l0eVNvdXJjZSk7XG4gICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDBdID0gdGhpcy5jb25zdHJ1Y3Rvci5saW1pdDI1NShibGVuZGVkLnIgKiAyNTUpO1xuICAgIGJhc2VJbWFnZS5iaXRtYXAuZGF0YVtkc3RJZHggKyAxXSA9IHRoaXMuY29uc3RydWN0b3IubGltaXQyNTUoYmxlbmRlZC5nICogMjU1KTtcbiAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgMl0gPSB0aGlzLmNvbnN0cnVjdG9yLmxpbWl0MjU1KGJsZW5kZWQuYiAqIDI1NSk7XG4gICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDNdID0gdGhpcy5jb25zdHJ1Y3Rvci5saW1pdDI1NShibGVuZGVkLmEgKiAyNTUpO1xuICB9KTtcbiAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/composite/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/@jimp/core/es/constants.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTO: () => (/* binding */ AUTO),\n/* harmony export */   BLEND_ADD: () => (/* binding */ BLEND_ADD),\n/* harmony export */   BLEND_DARKEN: () => (/* binding */ BLEND_DARKEN),\n/* harmony export */   BLEND_DESTINATION_OVER: () => (/* binding */ BLEND_DESTINATION_OVER),\n/* harmony export */   BLEND_DIFFERENCE: () => (/* binding */ BLEND_DIFFERENCE),\n/* harmony export */   BLEND_EXCLUSION: () => (/* binding */ BLEND_EXCLUSION),\n/* harmony export */   BLEND_HARDLIGHT: () => (/* binding */ BLEND_HARDLIGHT),\n/* harmony export */   BLEND_LIGHTEN: () => (/* binding */ BLEND_LIGHTEN),\n/* harmony export */   BLEND_MULTIPLY: () => (/* binding */ BLEND_MULTIPLY),\n/* harmony export */   BLEND_OVERLAY: () => (/* binding */ BLEND_OVERLAY),\n/* harmony export */   BLEND_SCREEN: () => (/* binding */ BLEND_SCREEN),\n/* harmony export */   BLEND_SOURCE_OVER: () => (/* binding */ BLEND_SOURCE_OVER),\n/* harmony export */   EDGE_CROP: () => (/* binding */ EDGE_CROP),\n/* harmony export */   EDGE_EXTEND: () => (/* binding */ EDGE_EXTEND),\n/* harmony export */   EDGE_WRAP: () => (/* binding */ EDGE_WRAP),\n/* harmony export */   HORIZONTAL_ALIGN_CENTER: () => (/* binding */ HORIZONTAL_ALIGN_CENTER),\n/* harmony export */   HORIZONTAL_ALIGN_LEFT: () => (/* binding */ HORIZONTAL_ALIGN_LEFT),\n/* harmony export */   HORIZONTAL_ALIGN_RIGHT: () => (/* binding */ HORIZONTAL_ALIGN_RIGHT),\n/* harmony export */   VERTICAL_ALIGN_BOTTOM: () => (/* binding */ VERTICAL_ALIGN_BOTTOM),\n/* harmony export */   VERTICAL_ALIGN_MIDDLE: () => (/* binding */ VERTICAL_ALIGN_MIDDLE),\n/* harmony export */   VERTICAL_ALIGN_TOP: () => (/* binding */ VERTICAL_ALIGN_TOP)\n/* harmony export */ });\n// used to auto resizing etc.\nconst AUTO = -1;\n\n// Align modes for cover, contain, bit masks\nconst HORIZONTAL_ALIGN_LEFT = 1;\nconst HORIZONTAL_ALIGN_CENTER = 2;\nconst HORIZONTAL_ALIGN_RIGHT = 4;\nconst VERTICAL_ALIGN_TOP = 8;\nconst VERTICAL_ALIGN_MIDDLE = 16;\nconst VERTICAL_ALIGN_BOTTOM = 32;\n\n// blend modes\nconst BLEND_SOURCE_OVER = \"srcOver\";\nconst BLEND_DESTINATION_OVER = \"dstOver\";\nconst BLEND_MULTIPLY = \"multiply\";\nconst BLEND_ADD = \"add\";\nconst BLEND_SCREEN = \"screen\";\nconst BLEND_OVERLAY = \"overlay\";\nconst BLEND_DARKEN = \"darken\";\nconst BLEND_LIGHTEN = \"lighten\";\nconst BLEND_HARDLIGHT = \"hardLight\";\nconst BLEND_DIFFERENCE = \"difference\";\nconst BLEND_EXCLUSION = \"exclusion\";\n\n// Edge Handling\nconst EDGE_EXTEND = 1;\nconst EDGE_WRAP = 2;\nconst EDGE_CROP = 3;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPOztBQUVQO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUDtBQUNPO0FBQ0E7QUFDQTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvY29yZS9lcy9jb25zdGFudHMuanM/YTMxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1c2VkIHRvIGF1dG8gcmVzaXppbmcgZXRjLlxuZXhwb3J0IGNvbnN0IEFVVE8gPSAtMTtcblxuLy8gQWxpZ24gbW9kZXMgZm9yIGNvdmVyLCBjb250YWluLCBiaXQgbWFza3NcbmV4cG9ydCBjb25zdCBIT1JJWk9OVEFMX0FMSUdOX0xFRlQgPSAxO1xuZXhwb3J0IGNvbnN0IEhPUklaT05UQUxfQUxJR05fQ0VOVEVSID0gMjtcbmV4cG9ydCBjb25zdCBIT1JJWk9OVEFMX0FMSUdOX1JJR0hUID0gNDtcbmV4cG9ydCBjb25zdCBWRVJUSUNBTF9BTElHTl9UT1AgPSA4O1xuZXhwb3J0IGNvbnN0IFZFUlRJQ0FMX0FMSUdOX01JRERMRSA9IDE2O1xuZXhwb3J0IGNvbnN0IFZFUlRJQ0FMX0FMSUdOX0JPVFRPTSA9IDMyO1xuXG4vLyBibGVuZCBtb2Rlc1xuZXhwb3J0IGNvbnN0IEJMRU5EX1NPVVJDRV9PVkVSID0gXCJzcmNPdmVyXCI7XG5leHBvcnQgY29uc3QgQkxFTkRfREVTVElOQVRJT05fT1ZFUiA9IFwiZHN0T3ZlclwiO1xuZXhwb3J0IGNvbnN0IEJMRU5EX01VTFRJUExZID0gXCJtdWx0aXBseVwiO1xuZXhwb3J0IGNvbnN0IEJMRU5EX0FERCA9IFwiYWRkXCI7XG5leHBvcnQgY29uc3QgQkxFTkRfU0NSRUVOID0gXCJzY3JlZW5cIjtcbmV4cG9ydCBjb25zdCBCTEVORF9PVkVSTEFZID0gXCJvdmVybGF5XCI7XG5leHBvcnQgY29uc3QgQkxFTkRfREFSS0VOID0gXCJkYXJrZW5cIjtcbmV4cG9ydCBjb25zdCBCTEVORF9MSUdIVEVOID0gXCJsaWdodGVuXCI7XG5leHBvcnQgY29uc3QgQkxFTkRfSEFSRExJR0hUID0gXCJoYXJkTGlnaHRcIjtcbmV4cG9ydCBjb25zdCBCTEVORF9ESUZGRVJFTkNFID0gXCJkaWZmZXJlbmNlXCI7XG5leHBvcnQgY29uc3QgQkxFTkRfRVhDTFVTSU9OID0gXCJleGNsdXNpb25cIjtcblxuLy8gRWRnZSBIYW5kbGluZ1xuZXhwb3J0IGNvbnN0IEVER0VfRVhURU5EID0gMTtcbmV4cG9ydCBjb25zdCBFREdFX1dSQVAgPSAyO1xuZXhwb3J0IGNvbnN0IEVER0VfQ1JPUCA9IDM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/constants.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@jimp/core/es/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addConstants: () => (/* binding */ addConstants),\n/* harmony export */   addJimpMethods: () => (/* binding */ addJimpMethods),\n/* harmony export */   addType: () => (/* reexport safe */ _utils_mime__WEBPACK_IMPORTED_MODULE_10__.addType),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   jimpEvChange: () => (/* binding */ jimpEvChange),\n/* harmony export */   jimpEvMethod: () => (/* binding */ jimpEvMethod)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n/* harmony import */ var any_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! any-base */ \"(action-browser)/./node_modules/any-base/index.js\");\n/* harmony import */ var any_base__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(any_base__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var pixelmatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pixelmatch */ \"(action-browser)/./node_modules/pixelmatch/index.js\");\n/* harmony import */ var pixelmatch__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(pixelmatch__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tinycolor2 */ \"(action-browser)/./node_modules/tinycolor2/esm/tinycolor.js\");\n/* harmony import */ var _modules_phash__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/phash */ \"(action-browser)/./node_modules/@jimp/core/es/modules/phash.js\");\n/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./request */ \"(action-browser)/./node_modules/@jimp/core/es/request.js\");\n/* harmony import */ var _composite__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./composite */ \"(action-browser)/./node_modules/@jimp/core/es/composite/index.js\");\n/* harmony import */ var _utils_promisify__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/promisify */ \"(action-browser)/./node_modules/@jimp/core/es/utils/promisify.js\");\n/* harmony import */ var _utils_mime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/mime */ \"(action-browser)/./node_modules/@jimp/core/es/utils/mime.js\");\n/* harmony import */ var _utils_image_bitmap__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/image-bitmap */ \"(action-browser)/./node_modules/@jimp/core/es/utils/image-bitmap.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@jimp/core/es/constants.js\");\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\";\n\n// an array storing the maximum string length of hashes at various bases\n// 0 and 1 do not exist as possible hash lengths\nconst maxHashLength = [NaN, NaN];\nfor (let i = 2; i < 65; i++) {\n  const maxHash = any_base__WEBPACK_IMPORTED_MODULE_4___default()((any_base__WEBPACK_IMPORTED_MODULE_4___default().BIN), alphabet.slice(0, i))(new Array(64 + 1).join(\"1\"));\n  maxHashLength.push(maxHash.length);\n}\n\n// no operation\nfunction noop() {}\n\n// error checking methods\n\nfunction isArrayBuffer(test) {\n  return Object.prototype.toString.call(test).toLowerCase().indexOf(\"arraybuffer\") > -1;\n}\n\n// Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,\n// But this function is not useful when running in node directly\nfunction bufferFromArrayBuffer(arrayBuffer) {\n  const buffer = Buffer.alloc(arrayBuffer.byteLength);\n  const view = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < buffer.length; ++i) {\n    buffer[i] = view[i];\n  }\n  return buffer;\n}\nfunction loadFromURL(options, cb) {\n  (0,_request__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(options, (err, data) => {\n    if (err) {\n      return cb(err);\n    }\n    if (typeof data === \"object\" && Buffer.isBuffer(data)) {\n      return cb(null, data);\n    }\n    if (typeof data === \"object\" && isArrayBuffer(data)) {\n      return cb(null, bufferFromArrayBuffer(data));\n    }\n    return new Error(`Could not load Buffer from <${options.url}>`);\n  });\n}\nfunction loadBufferFromPath(src, cb) {\n  if ((fs__WEBPACK_IMPORTED_MODULE_0___default()) && typeof (fs__WEBPACK_IMPORTED_MODULE_0___default().readFile) === \"function\" && !src.match(/^(http|ftp)s?:\\/\\/./)) {\n    fs__WEBPACK_IMPORTED_MODULE_0___default().readFile(src, cb);\n  } else {\n    loadFromURL({\n      url: src\n    }, cb);\n  }\n}\nfunction isRawRGBAData(obj) {\n  return obj && typeof obj === \"object\" && typeof obj.width === \"number\" && typeof obj.height === \"number\" && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === \"function\" && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);\n}\nfunction makeRGBABufferFromRGB(buffer) {\n  if (buffer.length % 3 !== 0) {\n    throw new Error(\"Buffer length is incorrect\");\n  }\n  const rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);\n  let j = 0;\n  for (let i = 0; i < buffer.length; i++) {\n    rgbaBuffer[j] = buffer[i];\n    if ((i + 1) % 3 === 0) {\n      rgbaBuffer[++j] = 255;\n    }\n    j++;\n  }\n  return rgbaBuffer;\n}\nconst emptyBitmap = {\n  data: null,\n  width: null,\n  height: null\n};\n\n/**\n * Jimp constructor (from a file)\n * @param path a path to the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a url with options)\n * @param options { url, otherOptions}\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from another Jimp image or raw image data)\n * @param image a Jimp image to clone\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a Buffer)\n * @param data a Buffer containing the image data\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param background color to fill the image with\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\nclass Jimp extends (events__WEBPACK_IMPORTED_MODULE_2___default()) {\n  // An object representing a bitmap in memory, comprising:\n  //  - data: a buffer of the bitmap data\n  //  - width: the width of the image in pixels\n  //  - height: the height of the image in pixels\n\n  // Default colour to use for new pixels\n\n  // Default MIME is PNG\n\n  // Exif data for the image\n\n  // Whether Transparency supporting formats will be exported as RGB or RGBA\n\n  constructor() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    super();\n    _defineProperty(this, \"bitmap\", emptyBitmap);\n    _defineProperty(this, \"_background\", 0x00000000);\n    _defineProperty(this, \"_originalMime\", Jimp.MIME_PNG);\n    _defineProperty(this, \"_exif\", null);\n    _defineProperty(this, \"_rgba\", true);\n    _defineProperty(this, \"writeAsync\", path => (0,_utils_promisify__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this.write, this, path));\n    _defineProperty(this, \"getBase64Async\", mime => (0,_utils_promisify__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this.getBase64, this, mime));\n    _defineProperty(this, \"getBuffer\", _utils_image_bitmap__WEBPACK_IMPORTED_MODULE_9__.getBuffer);\n    _defineProperty(this, \"getBufferAsync\", _utils_image_bitmap__WEBPACK_IMPORTED_MODULE_9__.getBufferAsync);\n    _defineProperty(this, \"getPixelColour\", this.getPixelColor);\n    _defineProperty(this, \"setPixelColour\", this.setPixelColor);\n    const jimpInstance = this;\n    let cb = noop;\n    if (isArrayBuffer(args[0])) {\n      args[0] = bufferFromArrayBuffer(args[0]);\n    }\n    function finish() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      const [err] = args;\n      const evData = err || {};\n      evData.methodName = \"constructor\";\n      setTimeout(() => {\n        // run on next tick.\n        if (err && cb === noop) {\n          jimpInstance.emitError(\"constructor\", err);\n        } else if (!err) {\n          jimpInstance.emitMulti(\"constructor\", \"initialized\");\n        }\n        cb.call(jimpInstance, ...args);\n      }, 1);\n    }\n    if (typeof args[0] === \"number\" && typeof args[1] === \"number\" || parseInt(args[0], 10) && parseInt(args[1], 10)) {\n      // create a new image\n      const w = parseInt(args[0], 10);\n      const h = parseInt(args[1], 10);\n      cb = args[2];\n\n      // with a hex color\n      if (typeof args[2] === \"number\") {\n        this._background = args[2];\n        cb = args[3];\n      }\n\n      // with a css color\n      if (typeof args[2] === \"string\") {\n        this._background = Jimp.cssColorToHex(args[2]);\n        cb = args[3];\n      }\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n      if (typeof cb !== \"function\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"cb must be a function\", finish);\n      }\n      this.bitmap = {\n        data: Buffer.alloc(w * h * 4),\n        width: w,\n        height: h\n      };\n      for (let i = 0; i < this.bitmap.data.length; i += 4) {\n        this.bitmap.data.writeUInt32BE(this._background, i);\n      }\n      finish(null, this);\n    } else if (typeof args[0] === \"object\" && args[0].url) {\n      cb = args[1] || noop;\n      if (typeof cb !== \"function\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"cb must be a function\", finish);\n      }\n      loadFromURL(args[0], (err, data) => {\n        if (err) {\n          return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, err, finish);\n        }\n        this.parseBitmap(data, args[0].url, finish);\n      });\n    } else if (args[0] instanceof Jimp) {\n      // clone an existing Jimp\n      const [original] = args;\n      cb = args[1];\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n      if (typeof cb !== \"function\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"cb must be a function\", finish);\n      }\n      this.bitmap = {\n        data: Buffer.from(original.bitmap.data),\n        width: original.bitmap.width,\n        height: original.bitmap.height\n      };\n      this._quality = original._quality;\n      this._deflateLevel = original._deflateLevel;\n      this._deflateStrategy = original._deflateStrategy;\n      this._filterType = original._filterType;\n      this._rgba = original._rgba;\n      this._background = original._background;\n      this._originalMime = original._originalMime;\n      finish(null, this);\n    } else if (isRawRGBAData(args[0])) {\n      const [imageData] = args;\n      cb = args[1] || noop;\n      const isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;\n      const buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);\n      this.bitmap = {\n        data: buffer,\n        width: imageData.width,\n        height: imageData.height\n      };\n      finish(null, this);\n    } else if (typeof args[0] === \"string\") {\n      // read from a path\n      const path = args[0];\n      cb = args[1];\n      if (typeof cb === \"undefined\") {\n        cb = noop;\n      }\n      if (typeof cb !== \"function\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"cb must be a function\", finish);\n      }\n      loadBufferFromPath(path, (err, data) => {\n        if (err) {\n          return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, err, finish);\n        }\n        this.parseBitmap(data, path, finish);\n      });\n    } else if (typeof args[0] === \"object\" && Buffer.isBuffer(args[0])) {\n      // read from a buffer\n      const data = args[0];\n      cb = args[1];\n      if (typeof cb !== \"function\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"cb must be a function\", finish);\n      }\n      this.parseBitmap(data, null, finish);\n    } else {\n      // Allow client libs to add new ways to build a Jimp object.\n      // Extra constructors must be added by `Jimp.appendConstructorOption()`\n      cb = args[args.length - 1];\n      if (typeof cb !== \"function\") {\n        // TODO: try to solve the args after cb problem.\n        cb = args[args.length - 2];\n        if (typeof cb !== \"function\") {\n          cb = noop;\n        }\n      }\n      const extraConstructor = Jimp.__extraConstructors.find(c => c.test(...args));\n      if (extraConstructor) {\n        new Promise((resolve, reject) => {\n          extraConstructor.run.call(this, resolve, reject, ...args);\n        }).then(() => finish(null, this)).catch(finish);\n      } else {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"No matching constructor overloading was found. \" + \"Please see the docs for how to call the Jimp constructor.\", finish);\n      }\n    }\n  }\n\n  /**\n   * Parse a bitmap with the loaded image types.\n   *\n   * @param {Buffer} data raw image data\n   * @param {string} path optional path to file\n   * @param {function(Error, Jimp)} finish (optional) a callback for when complete\n   * @memberof Jimp\n   */\n  parseBitmap(data, path, finish) {\n    _utils_image_bitmap__WEBPACK_IMPORTED_MODULE_9__.parseBitmap.call(this, data, null, finish);\n  }\n\n  /**\n   * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)\n   * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rgba(bool, cb) {\n    if (typeof bool !== \"boolean\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"bool must be a boolean, true for RGBA or false for RGB\", cb);\n    }\n    this._rgba = bool;\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n\n  /**\n   * Emit for multiple listeners\n   * @param {string} methodName name of the method to emit an error for\n   * @param {string} eventName name of the eventName to emit an error for\n   * @param {object} data to emit\n   */\n  emitMulti(methodName, eventName) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    data = Object.assign(data, {\n      methodName,\n      eventName\n    });\n    this.emit(\"any\", data);\n    if (methodName) {\n      this.emit(methodName, data);\n    }\n    this.emit(eventName, data);\n  }\n  emitError(methodName, err) {\n    this.emitMulti(methodName, \"error\", err);\n  }\n\n  /**\n   * Get the current height of the image\n   * @return {number} height of the image\n   */\n  getHeight() {\n    return this.bitmap.height;\n  }\n\n  /**\n   * Get the current width of the image\n   * @return {number} width of the image\n   */\n  getWidth() {\n    return this.bitmap.width;\n  }\n\n  /**\n   * Nicely format Jimp object when sent to the console e.g. console.log(image)\n   * @returns {string} pretty printed\n   */\n  inspect() {\n    return \"<Jimp \" + (this.bitmap === emptyBitmap ? \"pending...\" : this.bitmap.width + \"x\" + this.bitmap.height) + \">\";\n  }\n\n  /**\n   * Nicely format Jimp object when converted to a string\n   * @returns {string} pretty printed\n   */\n  toString() {\n    return \"[object Jimp]\";\n  }\n\n  /**\n   * Returns the original MIME of the image (default: \"image/png\")\n   * @returns {string} the MIME\n   */\n  getMIME() {\n    const mime = this._originalMime || Jimp.MIME_PNG;\n    return mime;\n  }\n\n  /**\n   * Returns the appropriate file extension for the original MIME of the image (default: \"png\")\n   * @returns {string} the file extension\n   */\n  getExtension() {\n    const mime = this.getMIME();\n    return _utils_mime__WEBPACK_IMPORTED_MODULE_10__.getExtension(mime);\n  }\n\n  /**\n   * Writes the image to a file\n   * @param {string} path a path to the destination file\n   * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk\n   * @returns {Jimp} this for chaining of methods\n   */\n  write(path, cb) {\n    if (!(fs__WEBPACK_IMPORTED_MODULE_0___default()) || !(fs__WEBPACK_IMPORTED_MODULE_0___default().createWriteStream)) {\n      throw new Error(\"Cant access the filesystem. You can use the getBase64 method.\");\n    }\n    if (typeof path !== \"string\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"path must be a string\", cb);\n    }\n    if (typeof cb === \"undefined\") {\n      cb = noop;\n    }\n    if (typeof cb !== \"function\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"cb must be a function\", cb);\n    }\n    const mime = _utils_mime__WEBPACK_IMPORTED_MODULE_10__.getType(path) || this.getMIME();\n    const pathObj = path__WEBPACK_IMPORTED_MODULE_1___default().parse(path);\n    if (pathObj.dir) {\n      fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(pathObj.dir, {\n        recursive: true\n      });\n    }\n    this.getBuffer(mime, (err, buffer) => {\n      if (err) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, err, cb);\n      }\n      const stream = fs__WEBPACK_IMPORTED_MODULE_0___default().createWriteStream(path);\n      stream.on(\"open\", () => {\n        stream.write(buffer);\n        stream.end();\n      }).on(\"error\", err => {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, err, cb);\n      });\n      stream.on(\"finish\", () => {\n        cb.call(this, null, this);\n      });\n    });\n    return this;\n  }\n  /**\n   * Converts the image to a base 64 string\n   * @param {string} mime the mime type of the image data to be created\n   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {Jimp} this for chaining of methods\n   */\n  getBase64(mime, cb) {\n    if (mime === Jimp.AUTO) {\n      // allow auto MIME detection\n      mime = this.getMIME();\n    }\n    if (typeof mime !== \"string\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"mime must be a string\", cb);\n    }\n    if (typeof cb !== \"function\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"cb must be a function\", cb);\n    }\n    this.getBuffer(mime, function (err, data) {\n      if (err) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, err, cb);\n      }\n      const src = \"data:\" + mime + \";base64,\" + data.toString(\"base64\");\n      cb.call(this, null, src);\n    });\n    return this;\n  }\n  /**\n   * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.\n   * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {string} a string representing the hash\n   */\n  hash(base, cb) {\n    base = base || 64;\n    if (typeof base === \"function\") {\n      cb = base;\n      base = 64;\n    }\n    if (typeof base !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"base must be a number\", cb);\n    }\n    if (base < 2 || base > 64) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"base must be a number between 2 and 64\", cb);\n    }\n    let hash = this.pHash();\n    hash = any_base__WEBPACK_IMPORTED_MODULE_4___default()((any_base__WEBPACK_IMPORTED_MODULE_4___default().BIN), alphabet.slice(0, base))(hash);\n    while (hash.length < maxHashLength[base]) {\n      hash = \"0\" + hash; // pad out with leading zeros\n    }\n\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n      cb.call(this, null, hash);\n    }\n    return hash;\n  }\n\n  /**\n   * Calculates the perceptual hash\n   * @returns {number} the perceptual hash\n   */\n  pHash() {\n    const pHash = new _modules_phash__WEBPACK_IMPORTED_MODULE_11__[\"default\"]();\n    return pHash.getHash(this);\n  }\n\n  /**\n   * Calculates the hamming distance of the current image and a hash based on their perceptual hash\n   * @param {hash} compareHash hash to compare to\n   * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n   */\n  distanceFromHash(compareHash) {\n    const pHash = new _modules_phash__WEBPACK_IMPORTED_MODULE_11__[\"default\"]();\n    const currentHash = pHash.getHash(this);\n    return pHash.distance(currentHash, compareHash);\n  }\n\n  /**\n   * Converts the image to a buffer\n   * @param {string} mime the mime type of the image buffer to be created\n   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {Jimp} this for chaining of methods\n   */\n\n  /**\n   * Returns the offset of a pixel in the bitmap buffer\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {number} edgeHandling (optional) define how to sum pixels from outside the border\n   * @param {number} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  getPixelIndex(x, y, edgeHandling, cb) {\n    let xi;\n    let yi;\n    if (typeof edgeHandling === \"function\" && typeof cb === \"undefined\") {\n      cb = edgeHandling;\n      edgeHandling = null;\n    }\n    if (!edgeHandling) {\n      edgeHandling = Jimp.EDGE_EXTEND;\n    }\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"x and y must be numbers\", cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    xi = x;\n    yi = y;\n    if (edgeHandling === Jimp.EDGE_EXTEND) {\n      if (x < 0) xi = 0;\n      if (x >= this.bitmap.width) xi = this.bitmap.width - 1;\n      if (y < 0) yi = 0;\n      if (y >= this.bitmap.height) yi = this.bitmap.height - 1;\n    }\n    if (edgeHandling === Jimp.EDGE_WRAP) {\n      if (x < 0) {\n        xi = this.bitmap.width + x;\n      }\n      if (x >= this.bitmap.width) {\n        xi = x % this.bitmap.width;\n      }\n      if (y < 0) {\n        yi = this.bitmap.height + y;\n      }\n      if (y >= this.bitmap.height) {\n        yi = y % this.bitmap.height;\n      }\n    }\n    let i = this.bitmap.width * yi + xi << 2;\n\n    // if out of bounds index is -1\n    if (xi < 0 || xi >= this.bitmap.width) {\n      i = -1;\n    }\n    if (yi < 0 || yi >= this.bitmap.height) {\n      i = -1;\n    }\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n      cb.call(this, null, i);\n    }\n    return i;\n  }\n\n  /**\n   * Returns the hex colour value of a pixel\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {number} the color of the pixel\n   */\n  getPixelColor(x, y, cb) {\n    if (typeof x !== \"number\" || typeof y !== \"number\") return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"x and y must be numbers\", cb);\n    const idx = this.getPixelIndex(x, y);\n    const hex = this.bitmap.data.readUInt32BE(idx);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n      cb.call(this, null, hex);\n    }\n    return hex;\n  }\n  /**\n   * Returns the hex colour value of a pixel\n   * @param {number} hex color to set\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  setPixelColor(hex, x, y, cb) {\n    if (typeof hex !== \"number\" || typeof x !== \"number\" || typeof y !== \"number\") return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"hex, x and y must be numbers\", cb);\n    const idx = this.getPixelIndex(x, y);\n    this.bitmap.data.writeUInt32BE(hex, idx);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n  /**\n   * Determine if the image contains opaque pixels.\n   * @return {boolean} hasAlpha whether the image contains opaque pixels\n   */\n  hasAlpha() {\n    const {\n      width,\n      height,\n      data\n    } = this.bitmap;\n    const byteLen = width * height << 2;\n    for (let idx = 3; idx < byteLen; idx += 4) {\n      if (data[idx] !== 0xff) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate scan through a region of the bitmap\n   * @param {number} x the x coordinate to begin the scan at\n   * @param {number} y the y coordinate to begin the scan at\n   * @param w the width of the scan region\n   * @param h the height of the scan region\n   * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}\n   */\n  scanIterator(x, y, w, h) {\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"x and y must be numbers\");\n    }\n    if (typeof w !== \"number\" || typeof h !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"w and h must be numbers\");\n    }\n    return (0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.scanIterator)(this, x, y, w, h);\n  }\n}\nfunction addConstants(constants) {\n  let jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;\n  Object.entries(constants).forEach(_ref => {\n    let [name, value] = _ref;\n    jimpInstance[name] = value;\n  });\n}\nfunction addJimpMethods(methods) {\n  let jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;\n  Object.entries(methods).forEach(_ref2 => {\n    let [name, value] = _ref2;\n    jimpInstance.prototype[name] = value;\n  });\n}\naddConstants(_constants__WEBPACK_IMPORTED_MODULE_12__);\naddJimpMethods({\n  composite: _composite__WEBPACK_IMPORTED_MODULE_13__[\"default\"]\n});\nJimp.__extraConstructors = [];\n\n/**\n * Allow client libs to add new ways to build a Jimp object.\n * @param {string} name identify the extra constructor.\n * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.\n * @param {function} run where the magic happens.\n */\nJimp.appendConstructorOption = function (name, test, run) {\n  Jimp.__extraConstructors.push({\n    name,\n    test,\n    run\n  });\n};\n\n/**\n * Read an image from a file or a Buffer. Takes the same args as the constructor\n * @returns {Promise} a promise\n */\nJimp.read = function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n  return new Promise((resolve, reject) => {\n    // eslint-disable-next-line no-new\n    new Jimp(...args, (err, image) => {\n      if (err) reject(err);else resolve(image);\n    });\n  });\n};\nJimp.create = Jimp.read;\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} r the red value (0-255)\n * @param {number} g the green value (0-255)\n * @param {number} b the blue value (0-255)\n * @param {number} a the alpha value (0-255)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {number} an single integer colour value\n */\nJimp.rgbaToInt = function (r, g, b, a, cb) {\n  if (typeof r !== \"number\" || typeof g !== \"number\" || typeof b !== \"number\" || typeof a !== \"number\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"r, g, b and a must be numbers\", cb);\n  }\n  if (r < 0 || r > 255) {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"r must be between 0 and 255\", cb);\n  }\n  if (g < 0 || g > 255) {\n    _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"g must be between 0 and 255\", cb);\n  }\n  if (b < 0 || b > 255) {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"b must be between 0 and 255\", cb);\n  }\n  if (a < 0 || a > 255) {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"a must be between 0 and 255\", cb);\n  }\n  let i = r & 0xff;\n  i <<= 8;\n  i |= g & 0xff;\n  i <<= 8;\n  i |= b & 0xff;\n  i <<= 8;\n  i |= a & 0xff;\n\n  // Ensure sign is correct\n  i >>>= 0;\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n    cb.call(this, null, i);\n  }\n  return i;\n};\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {object} an object with the properties r, g, b and a representing RGBA values\n */\nJimp.intToRGBA = function (i, cb) {\n  if (typeof i !== \"number\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"i must be a number\", cb);\n  }\n  const rgba = {};\n  rgba.r = Math.floor(i / Math.pow(256, 3));\n  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n  rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));\n  rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n    cb.call(this, null, rgba);\n  }\n  return rgba;\n};\n\n/**\n * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number\n * @param {string} cssColor a number\n * @returns {number} a hex number representing a color\n */\nJimp.cssColorToHex = function (cssColor) {\n  cssColor = cssColor || 0; // 0, null, undefined, NaN\n\n  if (typeof cssColor === \"number\") return Number(cssColor);\n  return parseInt((0,tinycolor2__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(cssColor).toHex8(), 16);\n};\n\n/**\n * Limits a number to between 0 or 255\n * @param {number} n a number\n * @returns {number} the number limited to between 0 or 255\n */\nJimp.limit255 = function (n) {\n  n = Math.max(n, 0);\n  n = Math.min(n, 255);\n  return n;\n};\n\n/**\n * Diffs two images and returns\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)\n * @returns {object} an object { percent: percent similar, diff: a Jimp image highlighting differences }\n */\nJimp.diff = function (img1, img2) {\n  let threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp)) return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"img1 and img2 must be an Jimp images\");\n  const bmp1 = img1.bitmap;\n  const bmp2 = img2.bitmap;\n  if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {\n    if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {\n      // img1 is bigger\n      img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);\n    } else {\n      // img2 is bigger (or they are the same in area)\n      img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);\n    }\n  }\n  if (typeof threshold !== \"number\" || threshold < 0 || threshold > 1) {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"threshold must be a number between 0 and 1\");\n  }\n  const diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);\n  const numDiffPixels = pixelmatch__WEBPACK_IMPORTED_MODULE_5___default()(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {\n    threshold\n  });\n  return {\n    percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),\n    image: diff\n  };\n};\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.distance = function (img1, img2) {\n  const phash = new _modules_phash__WEBPACK_IMPORTED_MODULE_11__[\"default\"]();\n  const hash1 = phash.getHash(img1);\n  const hash2 = phash.getHash(img2);\n  return phash.distance(hash1, hash2);\n};\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {hash} hash1 a pHash\n * @param {hash} hash2 a pHash\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.compareHashes = function (hash1, hash2) {\n  const phash = new _modules_phash__WEBPACK_IMPORTED_MODULE_11__[\"default\"]();\n  return phash.distance(hash1, hash2);\n};\n\n/**\n * Compute color difference\n * 0 means no difference, 1 means maximum difference.\n * @param {number} rgba1:    first color to compare.\n * @param {number} rgba2:    second color to compare.\n * Both parameters must be an color object {r:val, g:val, b:val, a:val}\n * Where `a` is optional and `val` is an integer between 0 and 255.\n * @returns {number} float between 0 and 1.\n */\nJimp.colorDiff = function (rgba1, rgba2) {\n  const pow = n => Math.pow(n, 2);\n  const {\n    max\n  } = Math;\n  const maxVal = 255 * 255 * 3;\n  if (rgba1.a !== 0 && !rgba1.a) {\n    rgba1.a = 255;\n  }\n  if (rgba2.a !== 0 && !rgba2.a) {\n    rgba2.a = 255;\n  }\n  return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;\n};\n\n/**\n * Helper to create Jimp methods that emit events before and after its execution.\n * @param {string} methodName   The name to be appended to Jimp prototype.\n * @param {string} evName       The event name to be called.\n *                     It will be prefixed by `before-` and emitted when on method call.\n *                     It will be appended by `ed` and emitted after the method run.\n * @param {function} method       A function implementing the method itself.\n * It will also create a quiet version that will not emit events, to not\n * mess the user code with many `changed` event calls. You can call with\n * `methodName + \"Quiet\"`.\n *\n * The emitted event comes with a object parameter to the listener with the\n * `methodName` as one attribute.\n */\nfunction jimpEvMethod(methodName, evName, method) {\n  const evNameBefore = \"before-\" + evName;\n  const evNameAfter = evName.replace(/e$/, \"\") + \"ed\";\n  Jimp.prototype[methodName] = function () {\n    let wrappedCb;\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    const cb = args[method.length - 1];\n    const jimpInstance = this;\n    if (typeof cb === \"function\") {\n      wrappedCb = function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        const [err, data] = args;\n        if (err) {\n          jimpInstance.emitError(methodName, err);\n        } else {\n          jimpInstance.emitMulti(methodName, evNameAfter, {\n            [methodName]: data\n          });\n        }\n        cb.apply(this, args);\n      };\n      args[args.length - 1] = wrappedCb;\n    } else {\n      wrappedCb = false;\n    }\n    this.emitMulti(methodName, evNameBefore);\n    let result;\n    try {\n      result = method.apply(this, args);\n      if (!wrappedCb) {\n        this.emitMulti(methodName, evNameAfter, {\n          [methodName]: result\n        });\n      }\n    } catch (error) {\n      error.methodName = methodName;\n      this.emitError(methodName, error);\n    }\n    return result;\n  };\n  Jimp.prototype[methodName + \"Quiet\"] = method;\n}\n\n/**\n * Creates a new image that is a clone of this one.\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns the new image\n */\njimpEvMethod(\"clone\", \"clone\", function (cb) {\n  const clone = new Jimp(this);\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n    cb.call(clone, null, clone);\n  }\n  return clone;\n});\n\n/**\n * Simplify jimpEvMethod call for the common `change` evName.\n * @param {string} methodName name of the method\n * @param {function} method to watch changes for\n */\nfunction jimpEvChange(methodName, method) {\n  jimpEvMethod(methodName, \"change\", method);\n}\n\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param b A Boolean, true to use RGBA or false to use RGB\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\njimpEvChange(\"background\", function (hex, cb) {\n  if (typeof hex !== \"number\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"hex must be a hexadecimal rgba value\", cb);\n  }\n  this._background = hex;\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n});\n\n/**\n * Scans through a region of the bitmap, calling a function for each pixel.\n * @param {number} x the x coordinate to begin the scan at\n * @param {number} y the y coordinate to begin the scan at\n * @param w the width of the scan region\n * @param h the height of the scan region\n * @param f a function to call on even pixel; the (x, y) position of the pixel\n * and the index of the pixel in the bitmap buffer are passed to the function\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\njimpEvChange(\"scan\", function (x, y, w, h, f, cb) {\n  if (typeof x !== \"number\" || typeof y !== \"number\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"x and y must be numbers\", cb);\n  }\n  if (typeof w !== \"number\" || typeof h !== \"number\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"w and h must be numbers\", cb);\n  }\n  if (typeof f !== \"function\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_3__.throwError.call(this, \"f must be a function\", cb);\n  }\n  const result = (0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.scan)(this, x, y, w, h, f);\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_3__.isNodePattern)(cb)) {\n    cb.call(this, null, result);\n  }\n  return result;\n});\nif (process.env.ENVIRONMENT === \"BROWSER\") {\n  // For use in a web browser or web worker\n  /* global self */\n  let gl;\n  if (typeof window !== \"undefined\" && typeof window === \"object\") {\n    gl = window;\n  }\n  if (typeof self !== \"undefined\" && typeof self === \"object\") {\n    gl = self;\n  }\n  gl.Jimp = Jimp;\n  gl.Buffer = Buffer;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Jimp);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sK0JBQStCLHVDQUF1QztBQUN0RSxxQ0FBcUMsK0RBQStELHNDQUFzQywwQkFBMEIsK0NBQStDLHlDQUF5Qyx1RUFBdUU7QUFDL1M7QUFDSTtBQUNVO0FBQzBDO0FBQzdDO0FBQ0s7QUFDRDtBQUNNO0FBQ1Q7QUFDSTtBQUNNO0FBQ0w7QUFDeUM7QUFDckM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsa0JBQWtCLCtDQUFPLENBQUMscURBQVc7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvREFBTztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwyQ0FBRSxXQUFXLG9EQUFXO0FBQzlCLElBQUksa0RBQVc7QUFDZixJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFdBQVcsdUJBQXVCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDOztBQUVBLG1CQUFtQiwrQ0FBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNERBQVM7QUFDekQsb0RBQW9ELDREQUFTO0FBQzdELHVDQUF1QywwREFBUztBQUNoRCw0Q0FBNEMsK0RBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQVU7QUFDM0I7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBVTtBQUMzQjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUixlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQVc7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBaUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVCQUF1QjtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLFNBQVMsMkNBQUUsS0FBSyw2REFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBLGlCQUFpQixpREFBWTtBQUM3QixvQkFBb0IsaURBQVU7QUFDOUI7QUFDQSxNQUFNLG1EQUFZO0FBQ2xCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQSxxQkFBcUIsMkRBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlLG1EQUFVO0FBQ3pCLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVCQUF1QjtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXLCtDQUFPLENBQUMscURBQVc7QUFDOUI7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUEsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxzQkFBc0IsdURBQVU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFVO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsK0RBQStELG1EQUFVO0FBQ3pFO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsMEZBQTBGLG1EQUFVO0FBQ3BHO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGVBQWUsa0JBQWtCLCtDQUErQztBQUNoRjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0EsV0FBVyx5REFBWTtBQUN2QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhLHdDQUFTO0FBQ3RCO0FBQ0EsV0FBVztBQUNYLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQVU7QUFDckI7QUFDQTtBQUNBLFdBQVcsbURBQVU7QUFDckI7QUFDQTtBQUNBLElBQUksbURBQVU7QUFDZDtBQUNBO0FBQ0EsV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0EsV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDBEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBLGtCQUFrQixzREFBUztBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUSxZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxtREFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQVU7QUFDckI7QUFDQTtBQUNBLHdCQUF3QixpREFBVTtBQUNsQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFVO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQiw0Q0FBNEM7QUFDNUM7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMERBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0EsTUFBTSwwREFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0EsV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0EsV0FBVyxtREFBVTtBQUNyQjtBQUNBLGlCQUFpQixpREFBSTtBQUNyQixNQUFNLDBEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QztBQUN2QyxpRUFBZSxJQUFJLEVBQUM7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL2luZGV4LmpzP2UyZWYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IFBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcImV2ZW50c1wiO1xuaW1wb3J0IHsgaXNOb2RlUGF0dGVybiwgdGhyb3dFcnJvciwgc2Nhbiwgc2Nhbkl0ZXJhdG9yIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5pbXBvcnQgYW55QmFzZSBmcm9tIFwiYW55LWJhc2VcIjtcbmltcG9ydCBwaXhlbE1hdGNoIGZyb20gXCJwaXhlbG1hdGNoXCI7XG5pbXBvcnQgdGlueUNvbG9yIGZyb20gXCJ0aW55Y29sb3IyXCI7XG5pbXBvcnQgSW1hZ2VQSGFzaCBmcm9tIFwiLi9tb2R1bGVzL3BoYXNoXCI7XG5pbXBvcnQgcmVxdWVzdCBmcm9tIFwiLi9yZXF1ZXN0XCI7XG5pbXBvcnQgY29tcG9zaXRlIGZyb20gXCIuL2NvbXBvc2l0ZVwiO1xuaW1wb3J0IHByb21pc2lmeSBmcm9tIFwiLi91dGlscy9wcm9taXNpZnlcIjtcbmltcG9ydCAqIGFzIE1JTUUgZnJvbSBcIi4vdXRpbHMvbWltZVwiO1xuaW1wb3J0IHsgcGFyc2VCaXRtYXAsIGdldEJ1ZmZlciwgZ2V0QnVmZmVyQXN5bmMgfSBmcm9tIFwiLi91dGlscy9pbWFnZS1iaXRtYXBcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmNvbnN0IGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfXCI7XG5cbi8vIGFuIGFycmF5IHN0b3JpbmcgdGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aCBvZiBoYXNoZXMgYXQgdmFyaW91cyBiYXNlc1xuLy8gMCBhbmQgMSBkbyBub3QgZXhpc3QgYXMgcG9zc2libGUgaGFzaCBsZW5ndGhzXG5jb25zdCBtYXhIYXNoTGVuZ3RoID0gW05hTiwgTmFOXTtcbmZvciAobGV0IGkgPSAyOyBpIDwgNjU7IGkrKykge1xuICBjb25zdCBtYXhIYXNoID0gYW55QmFzZShhbnlCYXNlLkJJTiwgYWxwaGFiZXQuc2xpY2UoMCwgaSkpKG5ldyBBcnJheSg2NCArIDEpLmpvaW4oXCIxXCIpKTtcbiAgbWF4SGFzaExlbmd0aC5wdXNoKG1heEhhc2gubGVuZ3RoKTtcbn1cblxuLy8gbm8gb3BlcmF0aW9uXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gZXJyb3IgY2hlY2tpbmcgbWV0aG9kc1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHRlc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0ZXN0KS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcnJheWJ1ZmZlclwiKSA+IC0xO1xufVxuXG4vLyBQcmVwYXJlIGEgQnVmZmVyIG9iamVjdCBmcm9tIHRoZSBhcnJheUJ1ZmZlci4gTmVjZXNzYXJ5IGluIHRoZSBicm93c2VyID4gbm9kZSBjb252ZXJzaW9uLFxuLy8gQnV0IHRoaXMgZnVuY3Rpb24gaXMgbm90IHVzZWZ1bCB3aGVuIHJ1bm5pbmcgaW4gbm9kZSBkaXJlY3RseVxuZnVuY3Rpb24gYnVmZmVyRnJvbUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSB2aWV3W2ldO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBsb2FkRnJvbVVSTChvcHRpb25zLCBjYikge1xuICByZXF1ZXN0KG9wdGlvbnMsIChlcnIsIGRhdGEpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIGNiKG51bGwsIGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIGNiKG51bGwsIGJ1ZmZlckZyb21BcnJheUJ1ZmZlcihkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkIEJ1ZmZlciBmcm9tIDwke29wdGlvbnMudXJsfT5gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBsb2FkQnVmZmVyRnJvbVBhdGgoc3JjLCBjYikge1xuICBpZiAoZnMgJiYgdHlwZW9mIGZzLnJlYWRGaWxlID09PSBcImZ1bmN0aW9uXCIgJiYgIXNyYy5tYXRjaCgvXihodHRwfGZ0cClzPzpcXC9cXC8uLykpIHtcbiAgICBmcy5yZWFkRmlsZShzcmMsIGNiKTtcbiAgfSBlbHNlIHtcbiAgICBsb2FkRnJvbVVSTCh7XG4gICAgICB1cmw6IHNyY1xuICAgIH0sIGNiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNSYXdSR0JBRGF0YShvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoud2lkdGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG9iai5oZWlnaHQgPT09IFwibnVtYmVyXCIgJiYgKEJ1ZmZlci5pc0J1ZmZlcihvYmouZGF0YSkgfHwgb2JqLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5kYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpICYmIChvYmouZGF0YS5sZW5ndGggPT09IG9iai53aWR0aCAqIG9iai5oZWlnaHQgKiA0IHx8IG9iai5kYXRhLmxlbmd0aCA9PT0gb2JqLndpZHRoICogb2JqLmhlaWdodCAqIDMpO1xufVxuZnVuY3Rpb24gbWFrZVJHQkFCdWZmZXJGcm9tUkdCKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgbGVuZ3RoIGlzIGluY29ycmVjdFwiKTtcbiAgfVxuICBjb25zdCByZ2JhQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZmZlci5sZW5ndGggLyAzICogNCk7XG4gIGxldCBqID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICByZ2JhQnVmZmVyW2pdID0gYnVmZmVyW2ldO1xuICAgIGlmICgoaSArIDEpICUgMyA9PT0gMCkge1xuICAgICAgcmdiYUJ1ZmZlclsrK2pdID0gMjU1O1xuICAgIH1cbiAgICBqKys7XG4gIH1cbiAgcmV0dXJuIHJnYmFCdWZmZXI7XG59XG5jb25zdCBlbXB0eUJpdG1hcCA9IHtcbiAgZGF0YTogbnVsbCxcbiAgd2lkdGg6IG51bGwsXG4gIGhlaWdodDogbnVsbFxufTtcblxuLyoqXG4gKiBKaW1wIGNvbnN0cnVjdG9yIChmcm9tIGEgZmlsZSlcbiAqIEBwYXJhbSBwYXRoIGEgcGF0aCB0byB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBpbWFnZSBpcyBwYXJzZWQgdG8gYSBiaXRtYXBcbiAqL1xuXG4vKipcbiAqIEppbXAgY29uc3RydWN0b3IgKGZyb20gYSB1cmwgd2l0aCBvcHRpb25zKVxuICogQHBhcmFtIG9wdGlvbnMgeyB1cmwsIG90aGVyT3B0aW9uc31cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBpbWFnZSBpcyBwYXJzZWQgdG8gYSBiaXRtYXBcbiAqL1xuXG4vKipcbiAqIEppbXAgY29uc3RydWN0b3IgKGZyb20gYW5vdGhlciBKaW1wIGltYWdlIG9yIHJhdyBpbWFnZSBkYXRhKVxuICogQHBhcmFtIGltYWdlIGEgSmltcCBpbWFnZSB0byBjbG9uZVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBpbWFnZSBpcyBwYXJzZWQgdG8gYSBiaXRtYXBcbiAqL1xuXG4vKipcbiAqIEppbXAgY29uc3RydWN0b3IgKGZyb20gYSBCdWZmZXIpXG4gKiBAcGFyYW0gZGF0YSBhIEJ1ZmZlciBjb250YWluaW5nIHRoZSBpbWFnZSBkYXRhXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGltYWdlIGlzIHBhcnNlZCB0byBhIGJpdG1hcFxuICovXG5cbi8qKlxuICogSmltcCBjb25zdHJ1Y3RvciAodG8gZ2VuZXJhdGUgYSBuZXcgaW1hZ2UpXG4gKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGltYWdlIGlzIHBhcnNlZCB0byBhIGJpdG1hcFxuICovXG5cbi8qKlxuICogSmltcCBjb25zdHJ1Y3RvciAodG8gZ2VuZXJhdGUgYSBuZXcgaW1hZ2UpXG4gKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCB0aGUgaW1hZ2Ugd2l0aFxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGltYWdlIGlzIHBhcnNlZCB0byBhIGJpdG1hcFxuICovXG5cbmNsYXNzIEppbXAgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvLyBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgYml0bWFwIGluIG1lbW9yeSwgY29tcHJpc2luZzpcbiAgLy8gIC0gZGF0YTogYSBidWZmZXIgb2YgdGhlIGJpdG1hcCBkYXRhXG4gIC8vICAtIHdpZHRoOiB0aGUgd2lkdGggb2YgdGhlIGltYWdlIGluIHBpeGVsc1xuICAvLyAgLSBoZWlnaHQ6IHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlIGluIHBpeGVsc1xuXG4gIC8vIERlZmF1bHQgY29sb3VyIHRvIHVzZSBmb3IgbmV3IHBpeGVsc1xuXG4gIC8vIERlZmF1bHQgTUlNRSBpcyBQTkdcblxuICAvLyBFeGlmIGRhdGEgZm9yIHRoZSBpbWFnZVxuXG4gIC8vIFdoZXRoZXIgVHJhbnNwYXJlbmN5IHN1cHBvcnRpbmcgZm9ybWF0cyB3aWxsIGJlIGV4cG9ydGVkIGFzIFJHQiBvciBSR0JBXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBzdXBlcigpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJpdG1hcFwiLCBlbXB0eUJpdG1hcCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2JhY2tncm91bmRcIiwgMHgwMDAwMDAwMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29yaWdpbmFsTWltZVwiLCBKaW1wLk1JTUVfUE5HKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZXhpZlwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmdiYVwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZUFzeW5jXCIsIHBhdGggPT4gcHJvbWlzaWZ5KHRoaXMud3JpdGUsIHRoaXMsIHBhdGgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRCYXNlNjRBc3luY1wiLCBtaW1lID0+IHByb21pc2lmeSh0aGlzLmdldEJhc2U2NCwgdGhpcywgbWltZSkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldEJ1ZmZlclwiLCBnZXRCdWZmZXIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldEJ1ZmZlckFzeW5jXCIsIGdldEJ1ZmZlckFzeW5jKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRQaXhlbENvbG91clwiLCB0aGlzLmdldFBpeGVsQ29sb3IpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFBpeGVsQ29sb3VyXCIsIHRoaXMuc2V0UGl4ZWxDb2xvcik7XG4gICAgY29uc3QgamltcEluc3RhbmNlID0gdGhpcztcbiAgICBsZXQgY2IgPSBub29wO1xuICAgIGlmIChpc0FycmF5QnVmZmVyKGFyZ3NbMF0pKSB7XG4gICAgICBhcmdzWzBdID0gYnVmZmVyRnJvbUFycmF5QnVmZmVyKGFyZ3NbMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgY29uc3QgW2Vycl0gPSBhcmdzO1xuICAgICAgY29uc3QgZXZEYXRhID0gZXJyIHx8IHt9O1xuICAgICAgZXZEYXRhLm1ldGhvZE5hbWUgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gcnVuIG9uIG5leHQgdGljay5cbiAgICAgICAgaWYgKGVyciAmJiBjYiA9PT0gbm9vcCkge1xuICAgICAgICAgIGppbXBJbnN0YW5jZS5lbWl0RXJyb3IoXCJjb25zdHJ1Y3RvclwiLCBlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnIpIHtcbiAgICAgICAgICBqaW1wSW5zdGFuY2UuZW1pdE11bHRpKFwiY29uc3RydWN0b3JcIiwgXCJpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYi5jYWxsKGppbXBJbnN0YW5jZSwgLi4uYXJncyk7XG4gICAgICB9LCAxKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBhcmdzWzFdID09PSBcIm51bWJlclwiIHx8IHBhcnNlSW50KGFyZ3NbMF0sIDEwKSAmJiBwYXJzZUludChhcmdzWzFdLCAxMCkpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBpbWFnZVxuICAgICAgY29uc3QgdyA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKTtcbiAgICAgIGNvbnN0IGggPSBwYXJzZUludChhcmdzWzFdLCAxMCk7XG4gICAgICBjYiA9IGFyZ3NbMl07XG5cbiAgICAgIC8vIHdpdGggYSBoZXggY29sb3JcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gYXJnc1syXTtcbiAgICAgICAgY2IgPSBhcmdzWzNdO1xuICAgICAgfVxuXG4gICAgICAvLyB3aXRoIGEgY3NzIGNvbG9yXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IEppbXAuY3NzQ29sb3JUb0hleChhcmdzWzJdKTtcbiAgICAgICAgY2IgPSBhcmdzWzNdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjYiA9IG5vb3A7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImNiIG11c3QgYmUgYSBmdW5jdGlvblwiLCBmaW5pc2gpO1xuICAgICAgfVxuICAgICAgdGhpcy5iaXRtYXAgPSB7XG4gICAgICAgIGRhdGE6IEJ1ZmZlci5hbGxvYyh3ICogaCAqIDQpLFxuICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgaGVpZ2h0OiBoXG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJpdG1hcC5kYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGEud3JpdGVVSW50MzJCRSh0aGlzLl9iYWNrZ3JvdW5kLCBpKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaChudWxsLCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiICYmIGFyZ3NbMF0udXJsKSB7XG4gICAgICBjYiA9IGFyZ3NbMV0gfHwgbm9vcDtcbiAgICAgIGlmICh0eXBlb2YgY2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiY2IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsIGZpbmlzaCk7XG4gICAgICB9XG4gICAgICBsb2FkRnJvbVVSTChhcmdzWzBdLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIGVyciwgZmluaXNoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlQml0bWFwKGRhdGEsIGFyZ3NbMF0udXJsLCBmaW5pc2gpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgSmltcCkge1xuICAgICAgLy8gY2xvbmUgYW4gZXhpc3RpbmcgSmltcFxuICAgICAgY29uc3QgW29yaWdpbmFsXSA9IGFyZ3M7XG4gICAgICBjYiA9IGFyZ3NbMV07XG4gICAgICBpZiAodHlwZW9mIGNiID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNiID0gbm9vcDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiY2IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsIGZpbmlzaCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJpdG1hcCA9IHtcbiAgICAgICAgZGF0YTogQnVmZmVyLmZyb20ob3JpZ2luYWwuYml0bWFwLmRhdGEpLFxuICAgICAgICB3aWR0aDogb3JpZ2luYWwuYml0bWFwLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IG9yaWdpbmFsLmJpdG1hcC5oZWlnaHRcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWFsaXR5ID0gb3JpZ2luYWwuX3F1YWxpdHk7XG4gICAgICB0aGlzLl9kZWZsYXRlTGV2ZWwgPSBvcmlnaW5hbC5fZGVmbGF0ZUxldmVsO1xuICAgICAgdGhpcy5fZGVmbGF0ZVN0cmF0ZWd5ID0gb3JpZ2luYWwuX2RlZmxhdGVTdHJhdGVneTtcbiAgICAgIHRoaXMuX2ZpbHRlclR5cGUgPSBvcmlnaW5hbC5fZmlsdGVyVHlwZTtcbiAgICAgIHRoaXMuX3JnYmEgPSBvcmlnaW5hbC5fcmdiYTtcbiAgICAgIHRoaXMuX2JhY2tncm91bmQgPSBvcmlnaW5hbC5fYmFja2dyb3VuZDtcbiAgICAgIHRoaXMuX29yaWdpbmFsTWltZSA9IG9yaWdpbmFsLl9vcmlnaW5hbE1pbWU7XG4gICAgICBmaW5pc2gobnVsbCwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChpc1Jhd1JHQkFEYXRhKGFyZ3NbMF0pKSB7XG4gICAgICBjb25zdCBbaW1hZ2VEYXRhXSA9IGFyZ3M7XG4gICAgICBjYiA9IGFyZ3NbMV0gfHwgbm9vcDtcbiAgICAgIGNvbnN0IGlzUkdCQSA9IGltYWdlRGF0YS53aWR0aCAqIGltYWdlRGF0YS5oZWlnaHQgKiA0ID09PSBpbWFnZURhdGEuZGF0YS5sZW5ndGg7XG4gICAgICBjb25zdCBidWZmZXIgPSBpc1JHQkEgPyBCdWZmZXIuZnJvbShpbWFnZURhdGEuZGF0YSkgOiBtYWtlUkdCQUJ1ZmZlckZyb21SR0IoaW1hZ2VEYXRhLmRhdGEpO1xuICAgICAgdGhpcy5iaXRtYXAgPSB7XG4gICAgICAgIGRhdGE6IGJ1ZmZlcixcbiAgICAgICAgd2lkdGg6IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpbWFnZURhdGEuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgZmluaXNoKG51bGwsIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIHJlYWQgZnJvbSBhIHBhdGhcbiAgICAgIGNvbnN0IHBhdGggPSBhcmdzWzBdO1xuICAgICAgY2IgPSBhcmdzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjYiA9IG5vb3A7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImNiIG11c3QgYmUgYSBmdW5jdGlvblwiLCBmaW5pc2gpO1xuICAgICAgfVxuICAgICAgbG9hZEJ1ZmZlckZyb21QYXRoKHBhdGgsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgZXJyLCBmaW5pc2gpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VCaXRtYXAoZGF0YSwgcGF0aCwgZmluaXNoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwib2JqZWN0XCIgJiYgQnVmZmVyLmlzQnVmZmVyKGFyZ3NbMF0pKSB7XG4gICAgICAvLyByZWFkIGZyb20gYSBidWZmZXJcbiAgICAgIGNvbnN0IGRhdGEgPSBhcmdzWzBdO1xuICAgICAgY2IgPSBhcmdzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJjYiBtdXN0IGJlIGEgZnVuY3Rpb25cIiwgZmluaXNoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyc2VCaXRtYXAoZGF0YSwgbnVsbCwgZmluaXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWxsb3cgY2xpZW50IGxpYnMgdG8gYWRkIG5ldyB3YXlzIHRvIGJ1aWxkIGEgSmltcCBvYmplY3QuXG4gICAgICAvLyBFeHRyYSBjb25zdHJ1Y3RvcnMgbXVzdCBiZSBhZGRlZCBieSBgSmltcC5hcHBlbmRDb25zdHJ1Y3Rvck9wdGlvbigpYFxuICAgICAgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gVE9ETzogdHJ5IHRvIHNvbHZlIHRoZSBhcmdzIGFmdGVyIGNiIHByb2JsZW0uXG4gICAgICAgIGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDJdO1xuICAgICAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjYiA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4dHJhQ29uc3RydWN0b3IgPSBKaW1wLl9fZXh0cmFDb25zdHJ1Y3RvcnMuZmluZChjID0+IGMudGVzdCguLi5hcmdzKSk7XG4gICAgICBpZiAoZXh0cmFDb25zdHJ1Y3Rvcikge1xuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgZXh0cmFDb25zdHJ1Y3Rvci5ydW4uY2FsbCh0aGlzLCByZXNvbHZlLCByZWplY3QsIC4uLmFyZ3MpO1xuICAgICAgICB9KS50aGVuKCgpID0+IGZpbmlzaChudWxsLCB0aGlzKSkuY2F0Y2goZmluaXNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJObyBtYXRjaGluZyBjb25zdHJ1Y3RvciBvdmVybG9hZGluZyB3YXMgZm91bmQuIFwiICsgXCJQbGVhc2Ugc2VlIHRoZSBkb2NzIGZvciBob3cgdG8gY2FsbCB0aGUgSmltcCBjb25zdHJ1Y3Rvci5cIiwgZmluaXNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBiaXRtYXAgd2l0aCB0aGUgbG9hZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSByYXcgaW1hZ2UgZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBvcHRpb25hbCBwYXRoIHRvIGZpbGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGZpbmlzaCAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQG1lbWJlcm9mIEppbXBcbiAgICovXG4gIHBhcnNlQml0bWFwKGRhdGEsIHBhdGgsIGZpbmlzaCkge1xuICAgIHBhcnNlQml0bWFwLmNhbGwodGhpcywgZGF0YSwgbnVsbCwgZmluaXNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0eXBlIG9mIHRoZSBpbWFnZSAoUkdCIG9yIFJHQkEpIHdoZW4gc2F2aW5nIGluIGEgZm9ybWF0IHRoYXQgc3VwcG9ydHMgdHJhbnNwYXJlbmN5IChkZWZhdWx0IGlzIFJHQkEpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYm9vbCBBIEJvb2xlYW4sIHRydWUgdG8gdXNlIFJHQkEgb3IgZmFsc2UgdG8gdXNlIFJHQlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAqL1xuICByZ2JhKGJvb2wsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBib29sICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImJvb2wgbXVzdCBiZSBhIGJvb2xlYW4sIHRydWUgZm9yIFJHQkEgb3IgZmFsc2UgZm9yIFJHQlwiLCBjYik7XG4gICAgfVxuICAgIHRoaXMuX3JnYmEgPSBib29sO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBmb3IgbXVsdGlwbGUgbGlzdGVuZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBlbWl0IGFuIGVycm9yIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIG5hbWUgb2YgdGhlIGV2ZW50TmFtZSB0byBlbWl0IGFuIGVycm9yIGZvclxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSB0byBlbWl0XG4gICAqL1xuICBlbWl0TXVsdGkobWV0aG9kTmFtZSwgZXZlbnROYW1lKSB7XG4gICAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGRhdGEgPSBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIG1ldGhvZE5hbWUsXG4gICAgICBldmVudE5hbWVcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoXCJhbnlcIiwgZGF0YSk7XG4gICAgaWYgKG1ldGhvZE5hbWUpIHtcbiAgICAgIHRoaXMuZW1pdChtZXRob2ROYW1lLCBkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSk7XG4gIH1cbiAgZW1pdEVycm9yKG1ldGhvZE5hbWUsIGVycikge1xuICAgIHRoaXMuZW1pdE11bHRpKG1ldGhvZE5hbWUsIFwiZXJyb3JcIiwgZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAgICovXG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgaW1hZ2VcbiAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aCBvZiB0aGUgaW1hZ2VcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmJpdG1hcC53aWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBOaWNlbHkgZm9ybWF0IEppbXAgb2JqZWN0IHdoZW4gc2VudCB0byB0aGUgY29uc29sZSBlLmcuIGNvbnNvbGUubG9nKGltYWdlKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwcmV0dHkgcHJpbnRlZFxuICAgKi9cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gXCI8SmltcCBcIiArICh0aGlzLmJpdG1hcCA9PT0gZW1wdHlCaXRtYXAgPyBcInBlbmRpbmcuLi5cIiA6IHRoaXMuYml0bWFwLndpZHRoICsgXCJ4XCIgKyB0aGlzLmJpdG1hcC5oZWlnaHQpICsgXCI+XCI7XG4gIH1cblxuICAvKipcbiAgICogTmljZWx5IGZvcm1hdCBKaW1wIG9iamVjdCB3aGVuIGNvbnZlcnRlZCB0byBhIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwcmV0dHkgcHJpbnRlZFxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBKaW1wXVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIE1JTUUgb2YgdGhlIGltYWdlIChkZWZhdWx0OiBcImltYWdlL3BuZ1wiKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgTUlNRVxuICAgKi9cbiAgZ2V0TUlNRSgpIHtcbiAgICBjb25zdCBtaW1lID0gdGhpcy5fb3JpZ2luYWxNaW1lIHx8IEppbXAuTUlNRV9QTkc7XG4gICAgcmV0dXJuIG1pbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgZmlsZSBleHRlbnNpb24gZm9yIHRoZSBvcmlnaW5hbCBNSU1FIG9mIHRoZSBpbWFnZSAoZGVmYXVsdDogXCJwbmdcIilcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIGZpbGUgZXh0ZW5zaW9uXG4gICAqL1xuICBnZXRFeHRlbnNpb24oKSB7XG4gICAgY29uc3QgbWltZSA9IHRoaXMuZ2V0TUlNRSgpO1xuICAgIHJldHVybiBNSU1FLmdldEV4dGVuc2lvbihtaW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIGltYWdlIHRvIGEgZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBhIHBhdGggdG8gdGhlIGRlc3RpbmF0aW9uIGZpbGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGltYWdlIGlzIHNhdmVkIHRvIGRpc2tcbiAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIHdyaXRlKHBhdGgsIGNiKSB7XG4gICAgaWYgKCFmcyB8fCAhZnMuY3JlYXRlV3JpdGVTdHJlYW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnQgYWNjZXNzIHRoZSBmaWxlc3lzdGVtLiBZb3UgY2FuIHVzZSB0aGUgZ2V0QmFzZTY0IG1ldGhvZC5cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInBhdGggbXVzdCBiZSBhIHN0cmluZ1wiLCBjYik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNiID0gbm9vcDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiY2IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsIGNiKTtcbiAgICB9XG4gICAgY29uc3QgbWltZSA9IE1JTUUuZ2V0VHlwZShwYXRoKSB8fCB0aGlzLmdldE1JTUUoKTtcbiAgICBjb25zdCBwYXRoT2JqID0gUGF0aC5wYXJzZShwYXRoKTtcbiAgICBpZiAocGF0aE9iai5kaXIpIHtcbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoT2JqLmRpciwge1xuICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmdldEJ1ZmZlcihtaW1lLCAoZXJyLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBlcnIsIGNiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHBhdGgpO1xuICAgICAgc3RyZWFtLm9uKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgIHN0cmVhbS53cml0ZShidWZmZXIpO1xuICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICB9KS5vbihcImVycm9yXCIsIGVyciA9PiB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgZXJyLCBjYik7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5vbihcImZpbmlzaFwiLCAoKSA9PiB7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGltYWdlIHRvIGEgYmFzZSA2NCBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1pbWUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgaW1hZ2UgZGF0YSB0byBiZSBjcmVhdGVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiBhIE5vZGUtc3R5bGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBidWZmZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgKi9cbiAgZ2V0QmFzZTY0KG1pbWUsIGNiKSB7XG4gICAgaWYgKG1pbWUgPT09IEppbXAuQVVUTykge1xuICAgICAgLy8gYWxsb3cgYXV0byBNSU1FIGRldGVjdGlvblxuICAgICAgbWltZSA9IHRoaXMuZ2V0TUlNRSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1pbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJtaW1lIG11c3QgYmUgYSBzdHJpbmdcIiwgY2IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJjYiBtdXN0IGJlIGEgZnVuY3Rpb25cIiwgY2IpO1xuICAgIH1cbiAgICB0aGlzLmdldEJ1ZmZlcihtaW1lLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgZXJyLCBjYik7XG4gICAgICB9XG4gICAgICBjb25zdCBzcmMgPSBcImRhdGE6XCIgKyBtaW1lICsgXCI7YmFzZTY0LFwiICsgZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgc3JjKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcGVyY2VwdHVhbCBoYXNoIG9mIHRoZSBpbWFnZSA8aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVyY2VwdHVhbF9oYXNoaW5nPi4gQW5kIHBhZHMgdGhlIHN0cmluZy4gQ2FuIGNvbmZpZ3VyZSBiYXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZSAob3B0aW9uYWwpIGEgbnVtYmVyIGJldHdlZW4gMiBhbmQgNjQgcmVwcmVzZW50aW5nIHRoZSBiYXNlIGZvciB0aGUgaGFzaCAoZS5nLiAyIGlzIGJpbmFyeSwgMTAgaXMgZGVjaW1hbCwgMTYgaXMgaGV4LCA2NCBpcyBiYXNlIDY0KS4gRGVmYXVsdHMgdG8gNjQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge3N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBoYXNoXG4gICAqL1xuICBoYXNoKGJhc2UsIGNiKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgNjQ7XG4gICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNiID0gYmFzZTtcbiAgICAgIGJhc2UgPSA2NDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiYXNlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiYmFzZSBtdXN0IGJlIGEgbnVtYmVyXCIsIGNiKTtcbiAgICB9XG4gICAgaWYgKGJhc2UgPCAyIHx8IGJhc2UgPiA2NCkge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImJhc2UgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDIgYW5kIDY0XCIsIGNiKTtcbiAgICB9XG4gICAgbGV0IGhhc2ggPSB0aGlzLnBIYXNoKCk7XG4gICAgaGFzaCA9IGFueUJhc2UoYW55QmFzZS5CSU4sIGFscGhhYmV0LnNsaWNlKDAsIGJhc2UpKShoYXNoKTtcbiAgICB3aGlsZSAoaGFzaC5sZW5ndGggPCBtYXhIYXNoTGVuZ3RoW2Jhc2VdKSB7XG4gICAgICBoYXNoID0gXCIwXCIgKyBoYXNoOyAvLyBwYWQgb3V0IHdpdGggbGVhZGluZyB6ZXJvc1xuICAgIH1cblxuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCBoYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcGVyY2VwdHVhbCBoYXNoXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBwZXJjZXB0dWFsIGhhc2hcbiAgICovXG4gIHBIYXNoKCkge1xuICAgIGNvbnN0IHBIYXNoID0gbmV3IEltYWdlUEhhc2goKTtcbiAgICByZXR1cm4gcEhhc2guZ2V0SGFzaCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBoYW1taW5nIGRpc3RhbmNlIG9mIHRoZSBjdXJyZW50IGltYWdlIGFuZCBhIGhhc2ggYmFzZWQgb24gdGhlaXIgcGVyY2VwdHVhbCBoYXNoXG4gICAqIEBwYXJhbSB7aGFzaH0gY29tcGFyZUhhc2ggaGFzaCB0byBjb21wYXJlIHRvXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IGEgbnVtYmVyIHJhbmdpbmcgZnJvbSAwIHRvIDEsIDAgbWVhbnMgdGhleSBhcmUgYmVsaWV2ZWQgdG8gYmUgaWRlbnRpY2FsXG4gICAqL1xuICBkaXN0YW5jZUZyb21IYXNoKGNvbXBhcmVIYXNoKSB7XG4gICAgY29uc3QgcEhhc2ggPSBuZXcgSW1hZ2VQSGFzaCgpO1xuICAgIGNvbnN0IGN1cnJlbnRIYXNoID0gcEhhc2guZ2V0SGFzaCh0aGlzKTtcbiAgICByZXR1cm4gcEhhc2guZGlzdGFuY2UoY3VycmVudEhhc2gsIGNvbXBhcmVIYXNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW1hZ2UgdG8gYSBidWZmZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1pbWUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgaW1hZ2UgYnVmZmVyIHRvIGJlIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIGEgTm9kZS1zdHlsZSBmdW5jdGlvbiB0byBjYWxsIHdpdGggdGhlIGJ1ZmZlciBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgYSBwaXhlbCBpbiB0aGUgYml0bWFwIGJ1ZmZlclxuICAgKiBAcGFyYW0ge251bWJlcn0geCB0aGUgeCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VIYW5kbGluZyAob3B0aW9uYWwpIGRlZmluZSBob3cgdG8gc3VtIHBpeGVscyBmcm9tIG91dHNpZGUgdGhlIGJvcmRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgcGl4ZWwgb3IgLTEgaWYgbm90IGZvdW5kXG4gICAqL1xuICBnZXRQaXhlbEluZGV4KHgsIHksIGVkZ2VIYW5kbGluZywgY2IpIHtcbiAgICBsZXQgeGk7XG4gICAgbGV0IHlpO1xuICAgIGlmICh0eXBlb2YgZWRnZUhhbmRsaW5nID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNiID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjYiA9IGVkZ2VIYW5kbGluZztcbiAgICAgIGVkZ2VIYW5kbGluZyA9IG51bGw7XG4gICAgfVxuICAgIGlmICghZWRnZUhhbmRsaW5nKSB7XG4gICAgICBlZGdlSGFuZGxpbmcgPSBKaW1wLkVER0VfRVhURU5EO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHggIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ4IGFuZCB5IG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gICAgfVxuXG4gICAgLy8gcm91bmQgaW5wdXRcbiAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB4aSA9IHg7XG4gICAgeWkgPSB5O1xuICAgIGlmIChlZGdlSGFuZGxpbmcgPT09IEppbXAuRURHRV9FWFRFTkQpIHtcbiAgICAgIGlmICh4IDwgMCkgeGkgPSAwO1xuICAgICAgaWYgKHggPj0gdGhpcy5iaXRtYXAud2lkdGgpIHhpID0gdGhpcy5iaXRtYXAud2lkdGggLSAxO1xuICAgICAgaWYgKHkgPCAwKSB5aSA9IDA7XG4gICAgICBpZiAoeSA+PSB0aGlzLmJpdG1hcC5oZWlnaHQpIHlpID0gdGhpcy5iaXRtYXAuaGVpZ2h0IC0gMTtcbiAgICB9XG4gICAgaWYgKGVkZ2VIYW5kbGluZyA9PT0gSmltcC5FREdFX1dSQVApIHtcbiAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICB4aSA9IHRoaXMuYml0bWFwLndpZHRoICsgeDtcbiAgICAgIH1cbiAgICAgIGlmICh4ID49IHRoaXMuYml0bWFwLndpZHRoKSB7XG4gICAgICAgIHhpID0geCAlIHRoaXMuYml0bWFwLndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHlpID0gdGhpcy5iaXRtYXAuaGVpZ2h0ICsgeTtcbiAgICAgIH1cbiAgICAgIGlmICh5ID49IHRoaXMuYml0bWFwLmhlaWdodCkge1xuICAgICAgICB5aSA9IHkgJSB0aGlzLmJpdG1hcC5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpID0gdGhpcy5iaXRtYXAud2lkdGggKiB5aSArIHhpIDw8IDI7XG5cbiAgICAvLyBpZiBvdXQgb2YgYm91bmRzIGluZGV4IGlzIC0xXG4gICAgaWYgKHhpIDwgMCB8fCB4aSA+PSB0aGlzLmJpdG1hcC53aWR0aCkge1xuICAgICAgaSA9IC0xO1xuICAgIH1cbiAgICBpZiAoeWkgPCAwIHx8IHlpID49IHRoaXMuYml0bWFwLmhlaWdodCkge1xuICAgICAgaSA9IC0xO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgaSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhleCBjb2xvdXIgdmFsdWUgb2YgYSBwaXhlbFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB0aGUgeCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIHBpeGVsXG4gICAqL1xuICBnZXRQaXhlbENvbG9yKHgsIHksIGNiKSB7XG4gICAgaWYgKHR5cGVvZiB4ICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB5ICE9PSBcIm51bWJlclwiKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwieCBhbmQgeSBtdXN0IGJlIG51bWJlcnNcIiwgY2IpO1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuZ2V0UGl4ZWxJbmRleCh4LCB5KTtcbiAgICBjb25zdCBoZXggPSB0aGlzLmJpdG1hcC5kYXRhLnJlYWRVSW50MzJCRShpZHgpO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCBoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZXggY29sb3VyIHZhbHVlIG9mIGEgcGl4ZWxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhleCBjb2xvciB0byBzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBwaXhlbCBvciAtMSBpZiBub3QgZm91bmRcbiAgICovXG4gIHNldFBpeGVsQ29sb3IoaGV4LCB4LCB5LCBjYikge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB4ICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB5ICE9PSBcIm51bWJlclwiKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiaGV4LCB4IGFuZCB5IG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5nZXRQaXhlbEluZGV4KHgsIHkpO1xuICAgIHRoaXMuYml0bWFwLmRhdGEud3JpdGVVSW50MzJCRShoZXgsIGlkeCk7XG4gICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBpbWFnZSBjb250YWlucyBvcGFxdWUgcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBoYXNBbHBoYSB3aGV0aGVyIHRoZSBpbWFnZSBjb250YWlucyBvcGFxdWUgcGl4ZWxzXG4gICAqL1xuICBoYXNBbHBoYSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcy5iaXRtYXA7XG4gICAgY29uc3QgYnl0ZUxlbiA9IHdpZHRoICogaGVpZ2h0IDw8IDI7XG4gICAgZm9yIChsZXQgaWR4ID0gMzsgaWR4IDwgYnl0ZUxlbjsgaWR4ICs9IDQpIHtcbiAgICAgIGlmIChkYXRhW2lkeF0gIT09IDB4ZmYpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHNjYW4gdGhyb3VnaCBhIHJlZ2lvbiBvZiB0aGUgYml0bWFwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSB4IGNvb3JkaW5hdGUgdG8gYmVnaW4gdGhlIHNjYW4gYXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgdGhlIHkgY29vcmRpbmF0ZSB0byBiZWdpbiB0aGUgc2NhbiBhdFxuICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIHNjYW4gcmVnaW9uXG4gICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIHNjYW4gcmVnaW9uXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPHt4OiBudW1iZXIsIHk6IG51bWJlciwgaWR4OiBudW1iZXIsIGltYWdlOiBKaW1wfT59XG4gICAqL1xuICBzY2FuSXRlcmF0b3IoeCwgeSwgdywgaCkge1xuICAgIGlmICh0eXBlb2YgeCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInggYW5kIHkgbXVzdCBiZSBudW1iZXJzXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHcgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ3IGFuZCBoIG11c3QgYmUgbnVtYmVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYW5JdGVyYXRvcih0aGlzLCB4LCB5LCB3LCBoKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbnN0YW50cyhjb25zdGFudHMpIHtcbiAgbGV0IGppbXBJbnN0YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogSmltcDtcbiAgT2JqZWN0LmVudHJpZXMoY29uc3RhbnRzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgIGxldCBbbmFtZSwgdmFsdWVdID0gX3JlZjtcbiAgICBqaW1wSW5zdGFuY2VbbmFtZV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkSmltcE1ldGhvZHMobWV0aG9kcykge1xuICBsZXQgamltcEluc3RhbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBKaW1wO1xuICBPYmplY3QuZW50cmllcyhtZXRob2RzKS5mb3JFYWNoKF9yZWYyID0+IHtcbiAgICBsZXQgW25hbWUsIHZhbHVlXSA9IF9yZWYyO1xuICAgIGppbXBJbnN0YW5jZS5wcm90b3R5cGVbbmFtZV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5hZGRDb25zdGFudHMoY29uc3RhbnRzKTtcbmFkZEppbXBNZXRob2RzKHtcbiAgY29tcG9zaXRlXG59KTtcbkppbXAuX19leHRyYUNvbnN0cnVjdG9ycyA9IFtdO1xuXG4vKipcbiAqIEFsbG93IGNsaWVudCBsaWJzIHRvIGFkZCBuZXcgd2F5cyB0byBidWlsZCBhIEppbXAgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgaWRlbnRpZnkgdGhlIGV4dHJhIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdGVzdCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIHdoZW4gaXQgYWNjZXB0cyB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWFpbiBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJ1biB3aGVyZSB0aGUgbWFnaWMgaGFwcGVucy5cbiAqL1xuSmltcC5hcHBlbmRDb25zdHJ1Y3Rvck9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB0ZXN0LCBydW4pIHtcbiAgSmltcC5fX2V4dHJhQ29uc3RydWN0b3JzLnB1c2goe1xuICAgIG5hbWUsXG4gICAgdGVzdCxcbiAgICBydW5cbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlYWQgYW4gaW1hZ2UgZnJvbSBhIGZpbGUgb3IgYSBCdWZmZXIuIFRha2VzIHRoZSBzYW1lIGFyZ3MgYXMgdGhlIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlXG4gKi9cbkppbXAucmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xuICAgIG5ldyBKaW1wKC4uLmFyZ3MsIChlcnIsIGltYWdlKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZWplY3QoZXJyKTtlbHNlIHJlc29sdmUoaW1hZ2UpO1xuICAgIH0pO1xuICB9KTtcbn07XG5KaW1wLmNyZWF0ZSA9IEppbXAucmVhZDtcblxuLyoqXG4gKiBBIHN0YXRpYyBoZWxwZXIgbWV0aG9kIHRoYXQgY29udmVydHMgUkdCQSB2YWx1ZXMgdG8gYSBzaW5nbGUgaW50ZWdlciB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgdGhlIHJlZCB2YWx1ZSAoMC0yNTUpXG4gKiBAcGFyYW0ge251bWJlcn0gZyB0aGUgZ3JlZW4gdmFsdWUgKDAtMjU1KVxuICogQHBhcmFtIHtudW1iZXJ9IGIgdGhlIGJsdWUgdmFsdWUgKDAtMjU1KVxuICogQHBhcmFtIHtudW1iZXJ9IGEgdGhlIGFscGhhIHZhbHVlICgwLTI1NSlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIEEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFuIHNpbmdsZSBpbnRlZ2VyIGNvbG91ciB2YWx1ZVxuICovXG5KaW1wLnJnYmFUb0ludCA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhLCBjYikge1xuICBpZiAodHlwZW9mIHIgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGcgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGIgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGEgIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiciwgZywgYiBhbmQgYSBtdXN0IGJlIG51bWJlcnNcIiwgY2IpO1xuICB9XG4gIGlmIChyIDwgMCB8fCByID4gMjU1KSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInIgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NVwiLCBjYik7XG4gIH1cbiAgaWYgKGcgPCAwIHx8IGcgPiAyNTUpIHtcbiAgICB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJnIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTVcIiwgY2IpO1xuICB9XG4gIGlmIChiIDwgMCB8fCBiID4gMjU1KSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImIgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NVwiLCBjYik7XG4gIH1cbiAgaWYgKGEgPCAwIHx8IGEgPiAyNTUpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiYSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1XCIsIGNiKTtcbiAgfVxuICBsZXQgaSA9IHIgJiAweGZmO1xuICBpIDw8PSA4O1xuICBpIHw9IGcgJiAweGZmO1xuICBpIDw8PSA4O1xuICBpIHw9IGIgJiAweGZmO1xuICBpIDw8PSA4O1xuICBpIHw9IGEgJiAweGZmO1xuXG4gIC8vIEVuc3VyZSBzaWduIGlzIGNvcnJlY3RcbiAgaSA+Pj49IDA7XG4gIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgIGNiLmNhbGwodGhpcywgbnVsbCwgaSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuXG4vKipcbiAqIEEgc3RhdGljIGhlbHBlciBtZXRob2QgdGhhdCBjb252ZXJ0cyBSR0JBIHZhbHVlcyB0byBhIHNpbmdsZSBpbnRlZ2VyIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaSBhIHNpbmdsZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGluZyBhbiBSR0JBIGNvbG91ciAoZS5nLiAweEZGMDAwMEZGIGZvciByZWQpXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBBIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyByLCBnLCBiIGFuZCBhIHJlcHJlc2VudGluZyBSR0JBIHZhbHVlc1xuICovXG5KaW1wLmludFRvUkdCQSA9IGZ1bmN0aW9uIChpLCBjYikge1xuICBpZiAodHlwZW9mIGkgIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiaSBtdXN0IGJlIGEgbnVtYmVyXCIsIGNiKTtcbiAgfVxuICBjb25zdCByZ2JhID0ge307XG4gIHJnYmEuciA9IE1hdGguZmxvb3IoaSAvIE1hdGgucG93KDI1NiwgMykpO1xuICByZ2JhLmcgPSBNYXRoLmZsb29yKChpIC0gcmdiYS5yICogTWF0aC5wb3coMjU2LCAzKSkgLyBNYXRoLnBvdygyNTYsIDIpKTtcbiAgcmdiYS5iID0gTWF0aC5mbG9vcigoaSAtIHJnYmEuciAqIE1hdGgucG93KDI1NiwgMykgLSByZ2JhLmcgKiBNYXRoLnBvdygyNTYsIDIpKSAvIE1hdGgucG93KDI1NiwgMSkpO1xuICByZ2JhLmEgPSBNYXRoLmZsb29yKChpIC0gcmdiYS5yICogTWF0aC5wb3coMjU2LCAzKSAtIHJnYmEuZyAqIE1hdGgucG93KDI1NiwgMikgLSByZ2JhLmIgKiBNYXRoLnBvdygyNTYsIDEpKSAvIE1hdGgucG93KDI1NiwgMCkpO1xuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHJnYmEpO1xuICB9XG4gIHJldHVybiByZ2JhO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGNzcyBjb2xvciAoSGV4LCA4LWRpZ2l0IChSR0JBKSBIZXgsIFJHQiwgUkdCQSwgSFNMLCBIU0xBLCBIU1YsIEhTVkEsIE5hbWVkKSB0byBhIGhleCBudW1iZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NDb2xvciBhIG51bWJlclxuICogQHJldHVybnMge251bWJlcn0gYSBoZXggbnVtYmVyIHJlcHJlc2VudGluZyBhIGNvbG9yXG4gKi9cbkppbXAuY3NzQ29sb3JUb0hleCA9IGZ1bmN0aW9uIChjc3NDb2xvcikge1xuICBjc3NDb2xvciA9IGNzc0NvbG9yIHx8IDA7IC8vIDAsIG51bGwsIHVuZGVmaW5lZCwgTmFOXG5cbiAgaWYgKHR5cGVvZiBjc3NDb2xvciA9PT0gXCJudW1iZXJcIikgcmV0dXJuIE51bWJlcihjc3NDb2xvcik7XG4gIHJldHVybiBwYXJzZUludCh0aW55Q29sb3IoY3NzQ29sb3IpLnRvSGV4OCgpLCAxNik7XG59O1xuXG4vKipcbiAqIExpbWl0cyBhIG51bWJlciB0byBiZXR3ZWVuIDAgb3IgMjU1XG4gKiBAcGFyYW0ge251bWJlcn0gbiBhIG51bWJlclxuICogQHJldHVybnMge251bWJlcn0gdGhlIG51bWJlciBsaW1pdGVkIHRvIGJldHdlZW4gMCBvciAyNTVcbiAqL1xuSmltcC5saW1pdDI1NSA9IGZ1bmN0aW9uIChuKSB7XG4gIG4gPSBNYXRoLm1heChuLCAwKTtcbiAgbiA9IE1hdGgubWluKG4sIDI1NSk7XG4gIHJldHVybiBuO1xufTtcblxuLyoqXG4gKiBEaWZmcyB0d28gaW1hZ2VzIGFuZCByZXR1cm5zXG4gKiBAcGFyYW0ge0ppbXB9IGltZzEgYSBKaW1wIGltYWdlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7SmltcH0gaW1nMiBhIEppbXAgaW1hZ2UgdG8gY29tcGFyZVxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCAob3B0aW9uYWwpIGEgbnVtYmVyLCAwIHRvIDEsIHRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbW9yZSBzZW5zaXRpdmUgdGhlIGNvbXBhcmlzb24gKGRlZmF1bHQ6IDAuMSlcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFuIG9iamVjdCB7IHBlcmNlbnQ6IHBlcmNlbnQgc2ltaWxhciwgZGlmZjogYSBKaW1wIGltYWdlIGhpZ2hsaWdodGluZyBkaWZmZXJlbmNlcyB9XG4gKi9cbkppbXAuZGlmZiA9IGZ1bmN0aW9uIChpbWcxLCBpbWcyKSB7XG4gIGxldCB0aHJlc2hvbGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDAuMTtcbiAgaWYgKCEoaW1nMSBpbnN0YW5jZW9mIEppbXApIHx8ICEoaW1nMiBpbnN0YW5jZW9mIEppbXApKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiaW1nMSBhbmQgaW1nMiBtdXN0IGJlIGFuIEppbXAgaW1hZ2VzXCIpO1xuICBjb25zdCBibXAxID0gaW1nMS5iaXRtYXA7XG4gIGNvbnN0IGJtcDIgPSBpbWcyLmJpdG1hcDtcbiAgaWYgKGJtcDEud2lkdGggIT09IGJtcDIud2lkdGggfHwgYm1wMS5oZWlnaHQgIT09IGJtcDIuaGVpZ2h0KSB7XG4gICAgaWYgKGJtcDEud2lkdGggKiBibXAxLmhlaWdodCA+IGJtcDIud2lkdGggKiBibXAyLmhlaWdodCkge1xuICAgICAgLy8gaW1nMSBpcyBiaWdnZXJcbiAgICAgIGltZzEgPSBpbWcxLmNsb25lUXVpZXQoKS5yZXNpemUoYm1wMi53aWR0aCwgYm1wMi5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbWcyIGlzIGJpZ2dlciAob3IgdGhleSBhcmUgdGhlIHNhbWUgaW4gYXJlYSlcbiAgICAgIGltZzIgPSBpbWcyLmNsb25lUXVpZXQoKS5yZXNpemUoYm1wMS53aWR0aCwgYm1wMS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gXCJudW1iZXJcIiB8fCB0aHJlc2hvbGQgPCAwIHx8IHRocmVzaG9sZCA+IDEpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwidGhyZXNob2xkIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXCIpO1xuICB9XG4gIGNvbnN0IGRpZmYgPSBuZXcgSmltcChibXAxLndpZHRoLCBibXAxLmhlaWdodCwgMHhmZmZmZmZmZik7XG4gIGNvbnN0IG51bURpZmZQaXhlbHMgPSBwaXhlbE1hdGNoKGJtcDEuZGF0YSwgYm1wMi5kYXRhLCBkaWZmLmJpdG1hcC5kYXRhLCBkaWZmLmJpdG1hcC53aWR0aCwgZGlmZi5iaXRtYXAuaGVpZ2h0LCB7XG4gICAgdGhyZXNob2xkXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHBlcmNlbnQ6IG51bURpZmZQaXhlbHMgLyAoZGlmZi5iaXRtYXAud2lkdGggKiBkaWZmLmJpdG1hcC5oZWlnaHQpLFxuICAgIGltYWdlOiBkaWZmXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGhhbW1pbmcgZGlzdGFuY2Ugb2YgdHdvIGltYWdlcyBiYXNlZCBvbiB0aGVpciBwZXJjZXB0dWFsIGhhc2hcbiAqIEBwYXJhbSB7SmltcH0gaW1nMSBhIEppbXAgaW1hZ2UgdG8gY29tcGFyZVxuICogQHBhcmFtIHtKaW1wfSBpbWcyIGEgSmltcCBpbWFnZSB0byBjb21wYXJlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhIG51bWJlciByYW5naW5nIGZyb20gMCB0byAxLCAwIG1lYW5zIHRoZXkgYXJlIGJlbGlldmVkIHRvIGJlIGlkZW50aWNhbFxuICovXG5KaW1wLmRpc3RhbmNlID0gZnVuY3Rpb24gKGltZzEsIGltZzIpIHtcbiAgY29uc3QgcGhhc2ggPSBuZXcgSW1hZ2VQSGFzaCgpO1xuICBjb25zdCBoYXNoMSA9IHBoYXNoLmdldEhhc2goaW1nMSk7XG4gIGNvbnN0IGhhc2gyID0gcGhhc2guZ2V0SGFzaChpbWcyKTtcbiAgcmV0dXJuIHBoYXNoLmRpc3RhbmNlKGhhc2gxLCBoYXNoMik7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGhhbW1pbmcgZGlzdGFuY2Ugb2YgdHdvIGltYWdlcyBiYXNlZCBvbiB0aGVpciBwZXJjZXB0dWFsIGhhc2hcbiAqIEBwYXJhbSB7aGFzaH0gaGFzaDEgYSBwSGFzaFxuICogQHBhcmFtIHtoYXNofSBoYXNoMiBhIHBIYXNoXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhIG51bWJlciByYW5naW5nIGZyb20gMCB0byAxLCAwIG1lYW5zIHRoZXkgYXJlIGJlbGlldmVkIHRvIGJlIGlkZW50aWNhbFxuICovXG5KaW1wLmNvbXBhcmVIYXNoZXMgPSBmdW5jdGlvbiAoaGFzaDEsIGhhc2gyKSB7XG4gIGNvbnN0IHBoYXNoID0gbmV3IEltYWdlUEhhc2goKTtcbiAgcmV0dXJuIHBoYXNoLmRpc3RhbmNlKGhhc2gxLCBoYXNoMik7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgY29sb3IgZGlmZmVyZW5jZVxuICogMCBtZWFucyBubyBkaWZmZXJlbmNlLCAxIG1lYW5zIG1heGltdW0gZGlmZmVyZW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZ2JhMTogICAgZmlyc3QgY29sb3IgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZ2JhMjogICAgc2Vjb25kIGNvbG9yIHRvIGNvbXBhcmUuXG4gKiBCb3RoIHBhcmFtZXRlcnMgbXVzdCBiZSBhbiBjb2xvciBvYmplY3Qge3I6dmFsLCBnOnZhbCwgYjp2YWwsIGE6dmFsfVxuICogV2hlcmUgYGFgIGlzIG9wdGlvbmFsIGFuZCBgdmFsYCBpcyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjU1LlxuICogQHJldHVybnMge251bWJlcn0gZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICovXG5KaW1wLmNvbG9yRGlmZiA9IGZ1bmN0aW9uIChyZ2JhMSwgcmdiYTIpIHtcbiAgY29uc3QgcG93ID0gbiA9PiBNYXRoLnBvdyhuLCAyKTtcbiAgY29uc3Qge1xuICAgIG1heFxuICB9ID0gTWF0aDtcbiAgY29uc3QgbWF4VmFsID0gMjU1ICogMjU1ICogMztcbiAgaWYgKHJnYmExLmEgIT09IDAgJiYgIXJnYmExLmEpIHtcbiAgICByZ2JhMS5hID0gMjU1O1xuICB9XG4gIGlmIChyZ2JhMi5hICE9PSAwICYmICFyZ2JhMi5hKSB7XG4gICAgcmdiYTIuYSA9IDI1NTtcbiAgfVxuICByZXR1cm4gKG1heChwb3cocmdiYTEuciAtIHJnYmEyLnIpLCBwb3cocmdiYTEuciAtIHJnYmEyLnIgLSByZ2JhMS5hICsgcmdiYTIuYSkpICsgbWF4KHBvdyhyZ2JhMS5nIC0gcmdiYTIuZyksIHBvdyhyZ2JhMS5nIC0gcmdiYTIuZyAtIHJnYmExLmEgKyByZ2JhMi5hKSkgKyBtYXgocG93KHJnYmExLmIgLSByZ2JhMi5iKSwgcG93KHJnYmExLmIgLSByZ2JhMi5iIC0gcmdiYTEuYSArIHJnYmEyLmEpKSkgLyBtYXhWYWw7XG59O1xuXG4vKipcbiAqIEhlbHBlciB0byBjcmVhdGUgSmltcCBtZXRob2RzIHRoYXQgZW1pdCBldmVudHMgYmVmb3JlIGFuZCBhZnRlciBpdHMgZXhlY3V0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgICBUaGUgbmFtZSB0byBiZSBhcHBlbmRlZCB0byBKaW1wIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldk5hbWUgICAgICAgVGhlIGV2ZW50IG5hbWUgdG8gYmUgY2FsbGVkLlxuICogICAgICAgICAgICAgICAgICAgICBJdCB3aWxsIGJlIHByZWZpeGVkIGJ5IGBiZWZvcmUtYCBhbmQgZW1pdHRlZCB3aGVuIG9uIG1ldGhvZCBjYWxsLlxuICogICAgICAgICAgICAgICAgICAgICBJdCB3aWxsIGJlIGFwcGVuZGVkIGJ5IGBlZGAgYW5kIGVtaXR0ZWQgYWZ0ZXIgdGhlIG1ldGhvZCBydW4uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgICAgICAgQSBmdW5jdGlvbiBpbXBsZW1lbnRpbmcgdGhlIG1ldGhvZCBpdHNlbGYuXG4gKiBJdCB3aWxsIGFsc28gY3JlYXRlIGEgcXVpZXQgdmVyc2lvbiB0aGF0IHdpbGwgbm90IGVtaXQgZXZlbnRzLCB0byBub3RcbiAqIG1lc3MgdGhlIHVzZXIgY29kZSB3aXRoIG1hbnkgYGNoYW5nZWRgIGV2ZW50IGNhbGxzLiBZb3UgY2FuIGNhbGwgd2l0aFxuICogYG1ldGhvZE5hbWUgKyBcIlF1aWV0XCJgLlxuICpcbiAqIFRoZSBlbWl0dGVkIGV2ZW50IGNvbWVzIHdpdGggYSBvYmplY3QgcGFyYW1ldGVyIHRvIHRoZSBsaXN0ZW5lciB3aXRoIHRoZVxuICogYG1ldGhvZE5hbWVgIGFzIG9uZSBhdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqaW1wRXZNZXRob2QobWV0aG9kTmFtZSwgZXZOYW1lLCBtZXRob2QpIHtcbiAgY29uc3QgZXZOYW1lQmVmb3JlID0gXCJiZWZvcmUtXCIgKyBldk5hbWU7XG4gIGNvbnN0IGV2TmFtZUFmdGVyID0gZXZOYW1lLnJlcGxhY2UoL2UkLywgXCJcIikgKyBcImVkXCI7XG4gIEppbXAucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCB3cmFwcGVkQ2I7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIGNvbnN0IGNiID0gYXJnc1ttZXRob2QubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgamltcEluc3RhbmNlID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHdyYXBwZWRDYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtlcnIsIGRhdGFdID0gYXJncztcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGppbXBJbnN0YW5jZS5lbWl0RXJyb3IobWV0aG9kTmFtZSwgZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqaW1wSW5zdGFuY2UuZW1pdE11bHRpKG1ldGhvZE5hbWUsIGV2TmFtZUFmdGVyLCB7XG4gICAgICAgICAgICBbbWV0aG9kTmFtZV06IGRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSB3cmFwcGVkQ2I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyYXBwZWRDYiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmVtaXRNdWx0aShtZXRob2ROYW1lLCBldk5hbWVCZWZvcmUpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIGlmICghd3JhcHBlZENiKSB7XG4gICAgICAgIHRoaXMuZW1pdE11bHRpKG1ldGhvZE5hbWUsIGV2TmFtZUFmdGVyLCB7XG4gICAgICAgICAgW21ldGhvZE5hbWVdOiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgdGhpcy5lbWl0RXJyb3IobWV0aG9kTmFtZSwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBKaW1wLnByb3RvdHlwZVttZXRob2ROYW1lICsgXCJRdWlldFwiXSA9IG1ldGhvZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGltYWdlIHRoYXQgaXMgYSBjbG9uZSBvZiB0aGlzIG9uZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIEEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHRoZSBuZXcgaW1hZ2VcbiAqL1xuamltcEV2TWV0aG9kKFwiY2xvbmVcIiwgXCJjbG9uZVwiLCBmdW5jdGlvbiAoY2IpIHtcbiAgY29uc3QgY2xvbmUgPSBuZXcgSmltcCh0aGlzKTtcbiAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgY2IuY2FsbChjbG9uZSwgbnVsbCwgY2xvbmUpO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn0pO1xuXG4vKipcbiAqIFNpbXBsaWZ5IGppbXBFdk1ldGhvZCBjYWxsIGZvciB0aGUgY29tbW9uIGBjaGFuZ2VgIGV2TmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIG5hbWUgb2YgdGhlIG1ldGhvZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIHRvIHdhdGNoIGNoYW5nZXMgZm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqaW1wRXZDaGFuZ2UobWV0aG9kTmFtZSwgbWV0aG9kKSB7XG4gIGppbXBFdk1ldGhvZChtZXRob2ROYW1lLCBcImNoYW5nZVwiLCBtZXRob2QpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgdGhlIGltYWdlIChSR0Igb3IgUkdCQSkgd2hlbiBzYXZpbmcgYXMgUE5HIGZvcm1hdCAoZGVmYXVsdCBpcyBSR0JBKVxuICogQHBhcmFtIGIgQSBCb29sZWFuLCB0cnVlIHRvIHVzZSBSR0JBIG9yIGZhbHNlIHRvIHVzZSBSR0JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cbmppbXBFdkNoYW5nZShcImJhY2tncm91bmRcIiwgZnVuY3Rpb24gKGhleCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBoZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiaGV4IG11c3QgYmUgYSBoZXhhZGVjaW1hbCByZ2JhIHZhbHVlXCIsIGNiKTtcbiAgfVxuICB0aGlzLl9iYWNrZ3JvdW5kID0gaGV4O1xuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufSk7XG5cbi8qKlxuICogU2NhbnMgdGhyb3VnaCBhIHJlZ2lvbiBvZiB0aGUgYml0bWFwLCBjYWxsaW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggcGl4ZWwuXG4gKiBAcGFyYW0ge251bWJlcn0geCB0aGUgeCBjb29yZGluYXRlIHRvIGJlZ2luIHRoZSBzY2FuIGF0XG4gKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIHRvIGJlZ2luIHRoZSBzY2FuIGF0XG4gKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIHNjYW4gcmVnaW9uXG4gKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IG9mIHRoZSBzY2FuIHJlZ2lvblxuICogQHBhcmFtIGYgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGV2ZW4gcGl4ZWw7IHRoZSAoeCwgeSkgcG9zaXRpb24gb2YgdGhlIHBpeGVsXG4gKiBhbmQgdGhlIGluZGV4IG9mIHRoZSBwaXhlbCBpbiB0aGUgYml0bWFwIGJ1ZmZlciBhcmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAqL1xuamltcEV2Q2hhbmdlKFwic2NhblwiLCBmdW5jdGlvbiAoeCwgeSwgdywgaCwgZiwgY2IpIHtcbiAgaWYgKHR5cGVvZiB4ICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInggYW5kIHkgbXVzdCBiZSBudW1iZXJzXCIsIGNiKTtcbiAgfVxuICBpZiAodHlwZW9mIHcgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGggIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwidyBhbmQgaCBtdXN0IGJlIG51bWJlcnNcIiwgY2IpO1xuICB9XG4gIGlmICh0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImYgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsIGNiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBzY2FuKHRoaXMsIHgsIHksIHcsIGgsIGYpO1xuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuaWYgKHByb2Nlc3MuZW52LkVOVklST05NRU5UID09PSBcIkJST1dTRVJcIikge1xuICAvLyBGb3IgdXNlIGluIGEgd2ViIGJyb3dzZXIgb3Igd2ViIHdvcmtlclxuICAvKiBnbG9iYWwgc2VsZiAqL1xuICBsZXQgZ2w7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbCA9IHdpbmRvdztcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbCA9IHNlbGY7XG4gIH1cbiAgZ2wuSmltcCA9IEppbXA7XG4gIGdsLkJ1ZmZlciA9IEJ1ZmZlcjtcbn1cbmV4cG9ydCB7IGFkZFR5cGUgfSBmcm9tIFwiLi91dGlscy9taW1lXCI7XG5leHBvcnQgZGVmYXVsdCBKaW1wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/modules/phash.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/core/es/modules/phash.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\nCopyright (c) 2011 Elliot Shepherd\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// https://code.google.com/p/ironchef-team21/source/browse/ironchef_team21/src/ImagePHash.java\n\n/*\n * pHash-like image hash.\n * Author: Elliot Shepherd (elliot@jarofworms.com\n * Based On: http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\n */\n\nfunction ImagePHash(size, smallerSize) {\n  this.size = this.size || size;\n  this.smallerSize = this.smallerSize || smallerSize;\n  initCoefficients(this.size);\n}\nImagePHash.prototype.size = 32;\nImagePHash.prototype.smallerSize = 8;\nImagePHash.prototype.distance = function (s1, s2) {\n  let counter = 0;\n  for (let k = 0; k < s1.length; k++) {\n    if (s1[k] !== s2[k]) {\n      counter++;\n    }\n  }\n  return counter / s1.length;\n};\n\n// Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on.\nImagePHash.prototype.getHash = function (img) {\n  /* 1. Reduce size.\n   * Like Average Hash, pHash starts with a small image.\n   * However, the image is larger than 8x8; 32x32 is a good size.\n   * This is really done to simplify the DCT computation and not\n   * because it is needed to reduce the high frequencies.\n   */\n  img = img.clone().resize(this.size, this.size);\n\n  /* 2. Reduce color.\n   * The image is reduced to a grayscale just to further simplify\n   * the number of computations.\n   */\n  img.grayscale();\n  const vals = [];\n  for (let x = 0; x < img.bitmap.width; x++) {\n    vals[x] = [];\n    for (let y = 0; y < img.bitmap.height; y++) {\n      vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;\n    }\n  }\n\n  /* 3. Compute the DCT.\n   * The DCT separates the image into a collection of frequencies\n   * and scalars. While JPEG uses an 8x8 DCT, this algorithm uses\n   * a 32x32 DCT.\n   */\n  const dctVals = applyDCT(vals, this.size);\n\n  /* 4. Reduce the DCT.\n   * This is the magic step. While the DCT is 32x32, just keep the\n   * top-left 8x8. Those represent the lowest frequencies in the\n   * picture.\n   */\n  /* 5. Compute the average value.\n   * Like the Average Hash, compute the mean DCT value (using only\n   * the 8x8 DCT low-frequency values and excluding the first term\n   * since the DC coefficient can be significantly different from\n   * the other values and will throw off the average).\n   */\n  let total = 0;\n  for (let x = 0; x < this.smallerSize; x++) {\n    for (let y = 0; y < this.smallerSize; y++) {\n      total += dctVals[x][y];\n    }\n  }\n  const avg = total / (this.smallerSize * this.smallerSize);\n\n  /* 6. Further reduce the DCT.\n   * This is the magic step. Set the 64 hash bits to 0 or 1\n   * depending on whether each of the 64 DCT values is above or\n   * below the average value. The result doesn't tell us the\n   * actual low frequencies; it just tells us the very-rough\n   * relative scale of the frequencies to the mean. The result\n   * will not vary as long as the overall structure of the image\n   * remains the same; this can survive gamma and color histogram\n   * adjustments without a problem.\n   */\n  let hash = \"\";\n  for (let x = 0; x < this.smallerSize; x++) {\n    for (let y = 0; y < this.smallerSize; y++) {\n      hash += dctVals[x][y] > avg ? \"1\" : \"0\";\n    }\n  }\n  return hash;\n};\n\n// DCT function stolen from http://stackoverflow.com/questions/4240490/problems-with-dct-and-idct-algorithm-in-java\n\n/**\n Convert a 32-bit integer color value to an RGBA object.\n */\nfunction intToRGBA(i) {\n  const a = i & 0xff;\n  i >>>= 8;\n  const b = i & 0xff;\n  i >>>= 8;\n  const g = i & 0xff;\n  i >>>= 8;\n  const r = i & 0xff;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nconst c = [];\nfunction initCoefficients(size) {\n  for (let i = 1; i < size; i++) {\n    c[i] = 1;\n  }\n  c[0] = 1 / Math.sqrt(2.0);\n}\nfunction applyDCT(f, size) {\n  const N = size;\n  const F = [];\n  for (let u = 0; u < N; u++) {\n    F[u] = [];\n    for (let v = 0; v < N; v++) {\n      let sum = 0;\n      for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n          sum += Math.cos((2 * i + 1) / (2.0 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2.0 * N) * v * Math.PI) * f[i][j];\n        }\n      }\n      sum *= c[u] * c[v] / 4;\n      F[u][v] = sum;\n    }\n  }\n  return F;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImagePHash);\n//# sourceMappingURL=phash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL21vZHVsZXMvcGhhc2guanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxzQkFBc0IsT0FBTztBQUM3Qix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxVQUFVLEVBQUM7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL21vZHVsZXMvcGhhc2guanM/MzQxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSAyMDExIEVsbGlvdCBTaGVwaGVyZFxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9pcm9uY2hlZi10ZWFtMjEvc291cmNlL2Jyb3dzZS9pcm9uY2hlZl90ZWFtMjEvc3JjL0ltYWdlUEhhc2guamF2YVxuXG4vKlxuICogcEhhc2gtbGlrZSBpbWFnZSBoYXNoLlxuICogQXV0aG9yOiBFbGxpb3QgU2hlcGhlcmQgKGVsbGlvdEBqYXJvZndvcm1zLmNvbVxuICogQmFzZWQgT246IGh0dHA6Ly93d3cuaGFja2VyZmFjdG9yLmNvbS9ibG9nL2luZGV4LnBocD8vYXJjaGl2ZXMvNDMyLUxvb2tzLUxpa2UtSXQuaHRtbFxuICovXG5cbmZ1bmN0aW9uIEltYWdlUEhhc2goc2l6ZSwgc21hbGxlclNpemUpIHtcbiAgdGhpcy5zaXplID0gdGhpcy5zaXplIHx8IHNpemU7XG4gIHRoaXMuc21hbGxlclNpemUgPSB0aGlzLnNtYWxsZXJTaXplIHx8IHNtYWxsZXJTaXplO1xuICBpbml0Q29lZmZpY2llbnRzKHRoaXMuc2l6ZSk7XG59XG5JbWFnZVBIYXNoLnByb3RvdHlwZS5zaXplID0gMzI7XG5JbWFnZVBIYXNoLnByb3RvdHlwZS5zbWFsbGVyU2l6ZSA9IDg7XG5JbWFnZVBIYXNoLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIChzMSwgczIpIHtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICBmb3IgKGxldCBrID0gMDsgayA8IHMxLmxlbmd0aDsgaysrKSB7XG4gICAgaWYgKHMxW2tdICE9PSBzMltrXSkge1xuICAgICAgY291bnRlcisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnRlciAvIHMxLmxlbmd0aDtcbn07XG5cbi8vIFJldHVybnMgYSAnYmluYXJ5IHN0cmluZycgKGxpa2UuIDAwMTAxMDExMTAxMTEwMDAxMCkgd2hpY2ggaXMgZWFzeSB0byBkbyBhIGhhbW1pbmcgZGlzdGFuY2Ugb24uXG5JbWFnZVBIYXNoLnByb3RvdHlwZS5nZXRIYXNoID0gZnVuY3Rpb24gKGltZykge1xuICAvKiAxLiBSZWR1Y2Ugc2l6ZS5cbiAgICogTGlrZSBBdmVyYWdlIEhhc2gsIHBIYXNoIHN0YXJ0cyB3aXRoIGEgc21hbGwgaW1hZ2UuXG4gICAqIEhvd2V2ZXIsIHRoZSBpbWFnZSBpcyBsYXJnZXIgdGhhbiA4eDg7IDMyeDMyIGlzIGEgZ29vZCBzaXplLlxuICAgKiBUaGlzIGlzIHJlYWxseSBkb25lIHRvIHNpbXBsaWZ5IHRoZSBEQ1QgY29tcHV0YXRpb24gYW5kIG5vdFxuICAgKiBiZWNhdXNlIGl0IGlzIG5lZWRlZCB0byByZWR1Y2UgdGhlIGhpZ2ggZnJlcXVlbmNpZXMuXG4gICAqL1xuICBpbWcgPSBpbWcuY2xvbmUoKS5yZXNpemUodGhpcy5zaXplLCB0aGlzLnNpemUpO1xuXG4gIC8qIDIuIFJlZHVjZSBjb2xvci5cbiAgICogVGhlIGltYWdlIGlzIHJlZHVjZWQgdG8gYSBncmF5c2NhbGUganVzdCB0byBmdXJ0aGVyIHNpbXBsaWZ5XG4gICAqIHRoZSBudW1iZXIgb2YgY29tcHV0YXRpb25zLlxuICAgKi9cbiAgaW1nLmdyYXlzY2FsZSgpO1xuICBjb25zdCB2YWxzID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgaW1nLmJpdG1hcC53aWR0aDsgeCsrKSB7XG4gICAgdmFsc1t4XSA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaW1nLmJpdG1hcC5oZWlnaHQ7IHkrKykge1xuICAgICAgdmFsc1t4XVt5XSA9IGludFRvUkdCQShpbWcuZ2V0UGl4ZWxDb2xvcih4LCB5KSkuYjtcbiAgICB9XG4gIH1cblxuICAvKiAzLiBDb21wdXRlIHRoZSBEQ1QuXG4gICAqIFRoZSBEQ1Qgc2VwYXJhdGVzIHRoZSBpbWFnZSBpbnRvIGEgY29sbGVjdGlvbiBvZiBmcmVxdWVuY2llc1xuICAgKiBhbmQgc2NhbGFycy4gV2hpbGUgSlBFRyB1c2VzIGFuIDh4OCBEQ1QsIHRoaXMgYWxnb3JpdGhtIHVzZXNcbiAgICogYSAzMngzMiBEQ1QuXG4gICAqL1xuICBjb25zdCBkY3RWYWxzID0gYXBwbHlEQ1QodmFscywgdGhpcy5zaXplKTtcblxuICAvKiA0LiBSZWR1Y2UgdGhlIERDVC5cbiAgICogVGhpcyBpcyB0aGUgbWFnaWMgc3RlcC4gV2hpbGUgdGhlIERDVCBpcyAzMngzMiwganVzdCBrZWVwIHRoZVxuICAgKiB0b3AtbGVmdCA4eDguIFRob3NlIHJlcHJlc2VudCB0aGUgbG93ZXN0IGZyZXF1ZW5jaWVzIGluIHRoZVxuICAgKiBwaWN0dXJlLlxuICAgKi9cbiAgLyogNS4gQ29tcHV0ZSB0aGUgYXZlcmFnZSB2YWx1ZS5cbiAgICogTGlrZSB0aGUgQXZlcmFnZSBIYXNoLCBjb21wdXRlIHRoZSBtZWFuIERDVCB2YWx1ZSAodXNpbmcgb25seVxuICAgKiB0aGUgOHg4IERDVCBsb3ctZnJlcXVlbmN5IHZhbHVlcyBhbmQgZXhjbHVkaW5nIHRoZSBmaXJzdCB0ZXJtXG4gICAqIHNpbmNlIHRoZSBEQyBjb2VmZmljaWVudCBjYW4gYmUgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgZnJvbVxuICAgKiB0aGUgb3RoZXIgdmFsdWVzIGFuZCB3aWxsIHRocm93IG9mZiB0aGUgYXZlcmFnZSkuXG4gICAqL1xuICBsZXQgdG90YWwgPSAwO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc21hbGxlclNpemU7IHgrKykge1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zbWFsbGVyU2l6ZTsgeSsrKSB7XG4gICAgICB0b3RhbCArPSBkY3RWYWxzW3hdW3ldO1xuICAgIH1cbiAgfVxuICBjb25zdCBhdmcgPSB0b3RhbCAvICh0aGlzLnNtYWxsZXJTaXplICogdGhpcy5zbWFsbGVyU2l6ZSk7XG5cbiAgLyogNi4gRnVydGhlciByZWR1Y2UgdGhlIERDVC5cbiAgICogVGhpcyBpcyB0aGUgbWFnaWMgc3RlcC4gU2V0IHRoZSA2NCBoYXNoIGJpdHMgdG8gMCBvciAxXG4gICAqIGRlcGVuZGluZyBvbiB3aGV0aGVyIGVhY2ggb2YgdGhlIDY0IERDVCB2YWx1ZXMgaXMgYWJvdmUgb3JcbiAgICogYmVsb3cgdGhlIGF2ZXJhZ2UgdmFsdWUuIFRoZSByZXN1bHQgZG9lc24ndCB0ZWxsIHVzIHRoZVxuICAgKiBhY3R1YWwgbG93IGZyZXF1ZW5jaWVzOyBpdCBqdXN0IHRlbGxzIHVzIHRoZSB2ZXJ5LXJvdWdoXG4gICAqIHJlbGF0aXZlIHNjYWxlIG9mIHRoZSBmcmVxdWVuY2llcyB0byB0aGUgbWVhbi4gVGhlIHJlc3VsdFxuICAgKiB3aWxsIG5vdCB2YXJ5IGFzIGxvbmcgYXMgdGhlIG92ZXJhbGwgc3RydWN0dXJlIG9mIHRoZSBpbWFnZVxuICAgKiByZW1haW5zIHRoZSBzYW1lOyB0aGlzIGNhbiBzdXJ2aXZlIGdhbW1hIGFuZCBjb2xvciBoaXN0b2dyYW1cbiAgICogYWRqdXN0bWVudHMgd2l0aG91dCBhIHByb2JsZW0uXG4gICAqL1xuICBsZXQgaGFzaCA9IFwiXCI7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zbWFsbGVyU2l6ZTsgeCsrKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNtYWxsZXJTaXplOyB5KyspIHtcbiAgICAgIGhhc2ggKz0gZGN0VmFsc1t4XVt5XSA+IGF2ZyA/IFwiMVwiIDogXCIwXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNoO1xufTtcblxuLy8gRENUIGZ1bmN0aW9uIHN0b2xlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDI0MDQ5MC9wcm9ibGVtcy13aXRoLWRjdC1hbmQtaWRjdC1hbGdvcml0aG0taW4tamF2YVxuXG4vKipcbiBDb252ZXJ0IGEgMzItYml0IGludGVnZXIgY29sb3IgdmFsdWUgdG8gYW4gUkdCQSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGludFRvUkdCQShpKSB7XG4gIGNvbnN0IGEgPSBpICYgMHhmZjtcbiAgaSA+Pj49IDg7XG4gIGNvbnN0IGIgPSBpICYgMHhmZjtcbiAgaSA+Pj49IDg7XG4gIGNvbnN0IGcgPSBpICYgMHhmZjtcbiAgaSA+Pj49IDg7XG4gIGNvbnN0IHIgPSBpICYgMHhmZjtcbiAgcmV0dXJuIHtcbiAgICByLFxuICAgIGcsXG4gICAgYixcbiAgICBhXG4gIH07XG59XG5jb25zdCBjID0gW107XG5mdW5jdGlvbiBpbml0Q29lZmZpY2llbnRzKHNpemUpIHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICBjW2ldID0gMTtcbiAgfVxuICBjWzBdID0gMSAvIE1hdGguc3FydCgyLjApO1xufVxuZnVuY3Rpb24gYXBwbHlEQ1QoZiwgc2l6ZSkge1xuICBjb25zdCBOID0gc2l6ZTtcbiAgY29uc3QgRiA9IFtdO1xuICBmb3IgKGxldCB1ID0gMDsgdSA8IE47IHUrKykge1xuICAgIEZbdV0gPSBbXTtcbiAgICBmb3IgKGxldCB2ID0gMDsgdiA8IE47IHYrKykge1xuICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47IGorKykge1xuICAgICAgICAgIHN1bSArPSBNYXRoLmNvcygoMiAqIGkgKyAxKSAvICgyLjAgKiBOKSAqIHUgKiBNYXRoLlBJKSAqIE1hdGguY29zKCgyICogaiArIDEpIC8gKDIuMCAqIE4pICogdiAqIE1hdGguUEkpICogZltpXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3VtICo9IGNbdV0gKiBjW3ZdIC8gNDtcbiAgICAgIEZbdV1bdl0gPSBzdW07XG4gICAgfVxuICB9XG4gIHJldHVybiBGO1xufVxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VQSGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBoYXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/modules/phash.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/request.js":
/*!***********************************************!*\
  !*** ./node_modules/@jimp/core/es/request.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! isomorphic-fetch */ \"(action-browser)/./node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((_ref, cb) => {\n  let {\n    url,\n    ...options\n  } = _ref;\n  fetch(url, options).then(response => {\n    if (response.ok) {\n      return response.arrayBuffer().catch(error => {\n        throw new Error(`Response is not a buffer for url ${url}. Error: ${error.message}`);\n      });\n    }\n    throw new Error(`HTTP Status ${response.status} for url ${url}`);\n  }).then(data => cb(null, data)).catch(error => cb(error));\n});\n//# sourceMappingURL=request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBCO0FBQzFCLGlFQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNERBQTRELElBQUksV0FBVyxjQUFjO0FBQ3pGLE9BQU87QUFDUDtBQUNBLG1DQUFtQyxpQkFBaUIsVUFBVSxJQUFJO0FBQ2xFLEdBQUc7QUFDSCxDQUFDLEVBQUU7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZXMvcmVxdWVzdC5qcz82NDA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcImlzb21vcnBoaWMtZmV0Y2hcIjtcbmV4cG9ydCBkZWZhdWx0ICgoX3JlZiwgY2IpID0+IHtcbiAgbGV0IHtcbiAgICB1cmwsXG4gICAgLi4ub3B0aW9uc1xuICB9ID0gX3JlZjtcbiAgZmV0Y2godXJsLCBvcHRpb25zKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNwb25zZSBpcyBub3QgYSBidWZmZXIgZm9yIHVybCAke3VybH0uIEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIFN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c30gZm9yIHVybCAke3VybH1gKTtcbiAgfSkudGhlbihkYXRhID0+IGNiKG51bGwsIGRhdGEpKS5jYXRjaChlcnJvciA9PiBjYihlcnJvcikpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/request.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/utils/image-bitmap.js":
/*!**********************************************************!*\
  !*** ./node_modules/@jimp/core/es/utils/image-bitmap.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBuffer: () => (/* binding */ getBuffer),\n/* harmony export */   getBufferAsync: () => (/* binding */ getBufferAsync),\n/* harmony export */   parseBitmap: () => (/* binding */ parseBitmap)\n/* harmony export */ });\n/* harmony import */ var file_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! file-type */ \"(action-browser)/./node_modules/file-type/index.js\");\n/* harmony import */ var file_type__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(file_type__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var exif_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! exif-parser */ \"(action-browser)/./node_modules/exif-parser/index.js\");\n/* harmony import */ var exif_parser__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(exif_parser__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ \"(action-browser)/./node_modules/@jimp/core/es/constants.js\");\n/* harmony import */ var _mime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mime */ \"(action-browser)/./node_modules/@jimp/core/es/utils/mime.js\");\n/* harmony import */ var _promisify__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./promisify */ \"(action-browser)/./node_modules/@jimp/core/es/utils/promisify.js\");\n\n\n\n\n\n\nasync function getMIMEFromBuffer(buffer, path) {\n  const fileTypeFromBuffer = await file_type__WEBPACK_IMPORTED_MODULE_0___default().fromBuffer(buffer);\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return _mime__WEBPACK_IMPORTED_MODULE_3__.getType(path);\n  }\n  return null;\n}\n\n/*\n * Obtains image orientation from EXIF metadata.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {number} a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\nfunction getExifOrientation(img) {\n  return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;\n}\n\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {function} transformation function for transformBitmap().\n */\nfunction getExifOrientationTransformation(img) {\n  const w = img.getWidth();\n  const h = img.getHeight();\n  switch (getExifOrientation(img)) {\n    case 1:\n      // Horizontal (normal)\n      // does not need to be supported here\n      return null;\n    case 2:\n      // Mirror horizontal\n      return function (x, y) {\n        return [w - x - 1, y];\n      };\n    case 3:\n      // Rotate 180\n      return function (x, y) {\n        return [w - x - 1, h - y - 1];\n      };\n    case 4:\n      // Mirror vertical\n      return function (x, y) {\n        return [x, h - y - 1];\n      };\n    case 5:\n      // Mirror horizontal and rotate 270 CW\n      return function (x, y) {\n        return [y, x];\n      };\n    case 6:\n      // Rotate 90 CW\n      return function (x, y) {\n        return [y, h - x - 1];\n      };\n    case 7:\n      // Mirror horizontal and rotate 90 CW\n      return function (x, y) {\n        return [w - y - 1, h - x - 1];\n      };\n    case 8:\n      // Rotate 270 CW\n      return function (x, y) {\n        return [w - y - 1, x];\n      };\n    default:\n      return null;\n  }\n}\n\n/*\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img {Jimp} a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width {number} bitmap width after the transformation\n * @param height {number} bitmap height after the transformation\n * @param transformation {function} transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\nfunction transformBitmap(img, width, height, transformation) {\n  // Underscore-prefixed values are related to the source bitmap\n  // Their counterparts with no prefix are related to the target bitmap\n  const _data = img.bitmap.data;\n  const _width = img.bitmap.width;\n  const data = Buffer.alloc(_data.length);\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const [_x, _y] = transformation(x, y);\n      const idx = width * y + x << 2;\n      const _idx = _width * _y + _x << 2;\n      const pixel = _data.readUInt32BE(_idx);\n      data.writeUInt32BE(pixel, idx);\n    }\n  }\n  img.bitmap.data = data;\n  img.bitmap.width = width;\n  img.bitmap.height = height;\n}\n\n/*\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img {Jimp} a Jimp image object\n */\nfunction exifRotate(img) {\n  if (getExifOrientation(img) < 2) return;\n  const transformation = getExifOrientationTransformation(img);\n  const swapDimensions = getExifOrientation(img) > 4;\n  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n  transformBitmap(img, newWidth, newHeight, transformation);\n}\n\n// parses a bitmap from the constructor to the JIMP bitmap property\nasync function parseBitmap(data, path, cb) {\n  const mime = await getMIMEFromBuffer(data, path);\n  if (typeof mime !== \"string\") {\n    return cb(new Error(\"Could not find MIME for Buffer <\" + path + \">\"));\n  }\n  this._originalMime = mime.toLowerCase();\n  try {\n    const mime = this.getMIME();\n    if (this.constructor.decoders[mime]) {\n      this.bitmap = this.constructor.decoders[mime](data);\n    } else {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"Unsupported MIME type: \" + mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n  try {\n    this._exif = exif_parser__WEBPACK_IMPORTED_MODULE_1___default().create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n  cb.call(this, null, this);\n  return this;\n}\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;\n}\n\n/**\n * Converts the image to a buffer\n * @param {(string|number)} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\nfunction getBuffer(mime, cb) {\n  if (mime === _constants__WEBPACK_IMPORTED_MODULE_4__.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n  if (typeof mime !== \"string\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"mime must be a string\", cb);\n  }\n  if (typeof cb !== \"function\") {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"cb must be a function\", cb);\n  }\n  mime = mime.toLowerCase();\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;\n  }\n  if (this.constructor.encoders[mime]) {\n    const buffer = this.constructor.encoders[mime](this);\n    // Typically, buffers return a string or map.  However, the gif library \"gifwrap\" seemingly returns promises.\n    if (buffer instanceof Promise) {\n      // trigger the callback when the promise has been resolved\n      buffer.then(buff => {\n        cb.call(this, null, buff);\n      });\n    } else {\n      cb.call(this, null, buffer);\n    }\n  } else {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"Unsupported MIME type: \" + mime, cb);\n  }\n  return this;\n}\nfunction getBufferAsync(mime) {\n  return (0,_promisify__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(getBuffer, this, mime);\n}\n//# sourceMappingURL=image-bitmap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL3V0aWxzL2ltYWdlLWJpdG1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFpQztBQUNJO0FBQ0k7QUFDQztBQUNYO0FBQ0s7QUFDcEM7QUFDQSxtQ0FBbUMsMkRBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBWTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsa0JBQWtCLFFBQVE7QUFDMUIsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBaUI7QUFDbEMsc0JBQXNCO0FBQ3RCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLE1BQU07QUFDbkI7QUFDTztBQUNQLGVBQWUsNENBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFVO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXLG1EQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsc0RBQVM7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZXMvdXRpbHMvaW1hZ2UtYml0bWFwLmpzPzAxYWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEZpbGVUeXBlIGZyb20gXCJmaWxlLXR5cGVcIjtcbmltcG9ydCBFWElGUGFyc2VyIGZyb20gXCJleGlmLXBhcnNlclwiO1xuaW1wb3J0IHsgdGhyb3dFcnJvciB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCAqIGFzIE1JTUUgZnJvbSBcIi4vbWltZVwiO1xuaW1wb3J0IHByb21pc2lmeSBmcm9tIFwiLi9wcm9taXNpZnlcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldE1JTUVGcm9tQnVmZmVyKGJ1ZmZlciwgcGF0aCkge1xuICBjb25zdCBmaWxlVHlwZUZyb21CdWZmZXIgPSBhd2FpdCBGaWxlVHlwZS5mcm9tQnVmZmVyKGJ1ZmZlcik7XG4gIGlmIChmaWxlVHlwZUZyb21CdWZmZXIpIHtcbiAgICAvLyBJZiBmaWxlVHlwZSByZXR1cm5zIHNvbWV0aGluZyBmb3IgYnVmZmVyLCB0aGVuIHJldHVybiB0aGUgbWltZSBnaXZlblxuICAgIHJldHVybiBmaWxlVHlwZUZyb21CdWZmZXIubWltZTtcbiAgfVxuICBpZiAocGF0aCkge1xuICAgIC8vIElmIGEgcGF0aCBpcyBzdXBwbGllZCwgYW5kIGZpbGVUeXBlIHlpZWxkcyBubyByZXN1bHRzLCB0aGVuIHJldHJ5IHdpdGggTUlNRVxuICAgIC8vIFBhdGggY2FuIGJlIGVpdGhlciBhIGZpbGUgcGF0aCBvciBhIHVybFxuICAgIHJldHVybiBNSU1FLmdldFR5cGUocGF0aCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qXG4gKiBPYnRhaW5zIGltYWdlIG9yaWVudGF0aW9uIGZyb20gRVhJRiBtZXRhZGF0YS5cbiAqXG4gKiBAcGFyYW0gaW1nIHtKaW1wfSBhIEppbXAgaW1hZ2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhIG51bWJlciAxLTggcmVwcmVzZW50aW5nIEVYSUYgb3JpZW50YXRpb24sXG4gKiAgICAgICAgICBpbiBwYXJ0aWN1bGFyIDEgaWYgb3JpZW50YXRpb24gdGFnIGlzIG1pc3NpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0RXhpZk9yaWVudGF0aW9uKGltZykge1xuICByZXR1cm4gaW1nLl9leGlmICYmIGltZy5fZXhpZi50YWdzICYmIGltZy5fZXhpZi50YWdzLk9yaWVudGF0aW9uIHx8IDE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRyYW5zbGF0ZXMgRVhJRi1yb3RhdGVkIGNvb3JkaW5hdGVzIGludG9cbiAqIG5vbi1yb3RhdGVkIG9uZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb24gcmVmZXJlbmNlOiBodHRwOi8vc3lsdmFuYS5uZXQvanBlZ2Nyb3AvZXhpZl9vcmllbnRhdGlvbi5odG1sLlxuICpcbiAqIEBwYXJhbSBpbWcge0ppbXB9IGEgSmltcCBpbWFnZSBvYmplY3RcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gZm9yIHRyYW5zZm9ybUJpdG1hcCgpLlxuICovXG5mdW5jdGlvbiBnZXRFeGlmT3JpZW50YXRpb25UcmFuc2Zvcm1hdGlvbihpbWcpIHtcbiAgY29uc3QgdyA9IGltZy5nZXRXaWR0aCgpO1xuICBjb25zdCBoID0gaW1nLmdldEhlaWdodCgpO1xuICBzd2l0Y2ggKGdldEV4aWZPcmllbnRhdGlvbihpbWcpKSB7XG4gICAgY2FzZSAxOlxuICAgICAgLy8gSG9yaXpvbnRhbCAobm9ybWFsKVxuICAgICAgLy8gZG9lcyBub3QgbmVlZCB0byBiZSBzdXBwb3J0ZWQgaGVyZVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAyOlxuICAgICAgLy8gTWlycm9yIGhvcml6b250YWxcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gW3cgLSB4IC0gMSwgeV07XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIC8vIFJvdGF0ZSAxODBcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gW3cgLSB4IC0gMSwgaCAtIHkgLSAxXTtcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgICAgLy8gTWlycm9yIHZlcnRpY2FsXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFt4LCBoIC0geSAtIDFdO1xuICAgICAgfTtcbiAgICBjYXNlIDU6XG4gICAgICAvLyBNaXJyb3IgaG9yaXpvbnRhbCBhbmQgcm90YXRlIDI3MCBDV1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbeSwgeF07XG4gICAgICB9O1xuICAgIGNhc2UgNjpcbiAgICAgIC8vIFJvdGF0ZSA5MCBDV1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbeSwgaCAtIHggLSAxXTtcbiAgICAgIH07XG4gICAgY2FzZSA3OlxuICAgICAgLy8gTWlycm9yIGhvcml6b250YWwgYW5kIHJvdGF0ZSA5MCBDV1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbdyAtIHkgLSAxLCBoIC0geCAtIDFdO1xuICAgICAgfTtcbiAgICBjYXNlIDg6XG4gICAgICAvLyBSb3RhdGUgMjcwIENXXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFt3IC0geSAtIDEsIHhdO1xuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLypcbiAqIFRyYW5zZm9ybXMgYml0bWFwIGluIHBsYWNlIChtb3ZlcyBwaXhlbHMgYXJvdW5kKSBhY2NvcmRpbmcgdG8gZ2l2ZW5cbiAqIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBpbWcge0ppbXB9IGEgSmltcCBpbWFnZSBvYmplY3QsIHdoaWNoIGJpdG1hcCBpcyBzdXBwb3NlZCB0b1xuICogICAgICAgIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gYml0bWFwIHdpZHRoIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvblxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBiaXRtYXAgaGVpZ2h0IGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvblxuICogQHBhcmFtIHRyYW5zZm9ybWF0aW9uIHtmdW5jdGlvbn0gdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gd2hpY2ggZGVmaW5lcyBwaXhlbFxuICogICAgICAgIG1hcHBpbmcgYmV0d2VlbiBuZXcgYW5kIHNvdXJjZSBiaXRtYXAuIEl0IHRha2VzIGEgcGFpciBvZiBjb29yZGluYXRlc1xuICogICAgICAgIGluIHRoZSB0YXJnZXQsIGFuZCByZXR1cm5zIGEgcmVzcGVjdGl2ZSBwYWlyIG9mIGNvb3JkaW5hdGVzIGluXG4gKiAgICAgICAgdGhlIHNvdXJjZSBiaXRtYXAsIGkuZS4gaGFzIGZvbGxvd2luZyBmb3JtOlxuICogICAgICAgIGBmdW5jdGlvbihuZXdfeCwgbmV3X3kpIHsgcmV0dXJuIFtzcmNfeCwgc3JjX3ldIH1gLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1CaXRtYXAoaW1nLCB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm1hdGlvbikge1xuICAvLyBVbmRlcnNjb3JlLXByZWZpeGVkIHZhbHVlcyBhcmUgcmVsYXRlZCB0byB0aGUgc291cmNlIGJpdG1hcFxuICAvLyBUaGVpciBjb3VudGVycGFydHMgd2l0aCBubyBwcmVmaXggYXJlIHJlbGF0ZWQgdG8gdGhlIHRhcmdldCBiaXRtYXBcbiAgY29uc3QgX2RhdGEgPSBpbWcuYml0bWFwLmRhdGE7XG4gIGNvbnN0IF93aWR0aCA9IGltZy5iaXRtYXAud2lkdGg7XG4gIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoX2RhdGEubGVuZ3RoKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgW194LCBfeV0gPSB0cmFuc2Zvcm1hdGlvbih4LCB5KTtcbiAgICAgIGNvbnN0IGlkeCA9IHdpZHRoICogeSArIHggPDwgMjtcbiAgICAgIGNvbnN0IF9pZHggPSBfd2lkdGggKiBfeSArIF94IDw8IDI7XG4gICAgICBjb25zdCBwaXhlbCA9IF9kYXRhLnJlYWRVSW50MzJCRShfaWR4KTtcbiAgICAgIGRhdGEud3JpdGVVSW50MzJCRShwaXhlbCwgaWR4KTtcbiAgICB9XG4gIH1cbiAgaW1nLmJpdG1hcC5kYXRhID0gZGF0YTtcbiAgaW1nLmJpdG1hcC53aWR0aCA9IHdpZHRoO1xuICBpbWcuYml0bWFwLmhlaWdodCA9IGhlaWdodDtcbn1cblxuLypcbiAqIEF1dG9tYWdpY2FsbHkgcm90YXRlcyBhbiBpbWFnZSBiYXNlZCBvbiBpdHMgRVhJRiBkYXRhIChpZiBwcmVzZW50KS5cbiAqIEBwYXJhbSBpbWcge0ppbXB9IGEgSmltcCBpbWFnZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZXhpZlJvdGF0ZShpbWcpIHtcbiAgaWYgKGdldEV4aWZPcmllbnRhdGlvbihpbWcpIDwgMikgcmV0dXJuO1xuICBjb25zdCB0cmFuc2Zvcm1hdGlvbiA9IGdldEV4aWZPcmllbnRhdGlvblRyYW5zZm9ybWF0aW9uKGltZyk7XG4gIGNvbnN0IHN3YXBEaW1lbnNpb25zID0gZ2V0RXhpZk9yaWVudGF0aW9uKGltZykgPiA0O1xuICBjb25zdCBuZXdXaWR0aCA9IHN3YXBEaW1lbnNpb25zID8gaW1nLmJpdG1hcC5oZWlnaHQgOiBpbWcuYml0bWFwLndpZHRoO1xuICBjb25zdCBuZXdIZWlnaHQgPSBzd2FwRGltZW5zaW9ucyA/IGltZy5iaXRtYXAud2lkdGggOiBpbWcuYml0bWFwLmhlaWdodDtcbiAgdHJhbnNmb3JtQml0bWFwKGltZywgbmV3V2lkdGgsIG5ld0hlaWdodCwgdHJhbnNmb3JtYXRpb24pO1xufVxuXG4vLyBwYXJzZXMgYSBiaXRtYXAgZnJvbSB0aGUgY29uc3RydWN0b3IgdG8gdGhlIEpJTVAgYml0bWFwIHByb3BlcnR5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VCaXRtYXAoZGF0YSwgcGF0aCwgY2IpIHtcbiAgY29uc3QgbWltZSA9IGF3YWl0IGdldE1JTUVGcm9tQnVmZmVyKGRhdGEsIHBhdGgpO1xuICBpZiAodHlwZW9mIG1pbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgTUlNRSBmb3IgQnVmZmVyIDxcIiArIHBhdGggKyBcIj5cIikpO1xuICB9XG4gIHRoaXMuX29yaWdpbmFsTWltZSA9IG1pbWUudG9Mb3dlckNhc2UoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaW1lID0gdGhpcy5nZXRNSU1FKCk7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZGVjb2RlcnNbbWltZV0pIHtcbiAgICAgIHRoaXMuYml0bWFwID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWNvZGVyc1ttaW1lXShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIlVuc3VwcG9ydGVkIE1JTUUgdHlwZTogXCIgKyBtaW1lLCBjYik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBjYi5jYWxsKHRoaXMsIGVycm9yLCB0aGlzKTtcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuX2V4aWYgPSBFWElGUGFyc2VyLmNyZWF0ZShkYXRhKS5wYXJzZSgpO1xuICAgIGV4aWZSb3RhdGUodGhpcyk7IC8vIEVYSUYgZGF0YVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIG1laCAqL1xuICB9XG4gIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gY29tcG9zaXRlQml0bWFwT3ZlckJhY2tncm91bmQoSmltcCwgaW1hZ2UpIHtcbiAgcmV0dXJuIG5ldyBKaW1wKGltYWdlLmJpdG1hcC53aWR0aCwgaW1hZ2UuYml0bWFwLmhlaWdodCwgaW1hZ2UuX2JhY2tncm91bmQpLmNvbXBvc2l0ZShpbWFnZSwgMCwgMCkuYml0bWFwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBpbWFnZSB0byBhIGJ1ZmZlclxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IG1pbWUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgaW1hZ2UgYnVmZmVyIHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiBhIE5vZGUtc3R5bGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBidWZmZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1ZmZlcihtaW1lLCBjYikge1xuICBpZiAobWltZSA9PT0gY29uc3RhbnRzLkFVVE8pIHtcbiAgICAvLyBhbGxvdyBhdXRvIE1JTUUgZGV0ZWN0aW9uXG4gICAgbWltZSA9IHRoaXMuZ2V0TUlNRSgpO1xuICB9XG4gIGlmICh0eXBlb2YgbWltZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJtaW1lIG11c3QgYmUgYSBzdHJpbmdcIiwgY2IpO1xuICB9XG4gIGlmICh0eXBlb2YgY2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJjYiBtdXN0IGJlIGEgZnVuY3Rpb25cIiwgY2IpO1xuICB9XG4gIG1pbWUgPSBtaW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmICh0aGlzLl9yZ2JhICYmIHRoaXMuY29uc3RydWN0b3IuaGFzQWxwaGFbbWltZV0pIHtcbiAgICB0aGlzLmJpdG1hcC5kYXRhID0gQnVmZmVyLmZyb20odGhpcy5iaXRtYXAuZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiBmb3JtYXQgZG9lc24ndCBzdXBwb3J0IGFscGhhXG4gICAgLy8gY29tcG9zaXRlIG9udG8gYSBuZXcgaW1hZ2Ugc28gdGhhdCB0aGUgYmFja2dyb3VuZCBzaG93cyB0aHJvdWdoIGFscGhhIGNoYW5uZWxzXG4gICAgdGhpcy5iaXRtYXAuZGF0YSA9IGNvbXBvc2l0ZUJpdG1hcE92ZXJCYWNrZ3JvdW5kKHRoaXMuY29uc3RydWN0b3IsIHRoaXMpLmRhdGE7XG4gIH1cbiAgaWYgKHRoaXMuY29uc3RydWN0b3IuZW5jb2RlcnNbbWltZV0pIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN0cnVjdG9yLmVuY29kZXJzW21pbWVdKHRoaXMpO1xuICAgIC8vIFR5cGljYWxseSwgYnVmZmVycyByZXR1cm4gYSBzdHJpbmcgb3IgbWFwLiAgSG93ZXZlciwgdGhlIGdpZiBsaWJyYXJ5IFwiZ2lmd3JhcFwiIHNlZW1pbmdseSByZXR1cm5zIHByb21pc2VzLlxuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBjYWxsYmFjayB3aGVuIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkXG4gICAgICBidWZmZXIudGhlbihidWZmID0+IHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCBidWZmKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIGJ1ZmZlcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJVbnN1cHBvcnRlZCBNSU1FIHR5cGU6IFwiICsgbWltZSwgY2IpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1ZmZlckFzeW5jKG1pbWUpIHtcbiAgcmV0dXJuIHByb21pc2lmeShnZXRCdWZmZXIsIHRoaXMsIG1pbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYml0bWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/utils/image-bitmap.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/utils/mime.js":
/*!**************************************************!*\
  !*** ./node_modules/@jimp/core/es/utils/mime.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addType: () => (/* binding */ addType),\n/* harmony export */   getExtension: () => (/* binding */ getExtension),\n/* harmony export */   getType: () => (/* binding */ getType)\n/* harmony export */ });\nconst mimeTypes = {};\nconst findType = extension => Object.entries(mimeTypes).find(type => type[1].includes(extension)) || [];\nconst addType = (mime, extensions) => {\n  mimeTypes[mime] = extensions;\n};\n\n/**\n * Lookup a mime type based on extension\n * @param {string} path path to find extension for\n * @returns {string} mime found mime type\n */\nconst getType = path => {\n  const pathParts = path.split(\"/\").slice(-1);\n  const extension = pathParts[pathParts.length - 1].split(\".\").pop();\n  const type = findType(extension);\n  return type[0];\n};\n\n/**\n * Return file extension associated with a mime type\n * @param {string} type mime type to look up\n * @returns {string} extension file extension\n */\nconst getExtension = type => (mimeTypes[type.toLowerCase()] || [])[0];\n//# sourceMappingURL=mime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL3V0aWxzL21pbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL3V0aWxzL21pbWUuanM/MzgzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBtaW1lVHlwZXMgPSB7fTtcbmNvbnN0IGZpbmRUeXBlID0gZXh0ZW5zaW9uID0+IE9iamVjdC5lbnRyaWVzKG1pbWVUeXBlcykuZmluZCh0eXBlID0+IHR5cGVbMV0uaW5jbHVkZXMoZXh0ZW5zaW9uKSkgfHwgW107XG5leHBvcnQgY29uc3QgYWRkVHlwZSA9IChtaW1lLCBleHRlbnNpb25zKSA9PiB7XG4gIG1pbWVUeXBlc1ttaW1lXSA9IGV4dGVuc2lvbnM7XG59O1xuXG4vKipcbiAqIExvb2t1cCBhIG1pbWUgdHlwZSBiYXNlZCBvbiBleHRlbnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gZmluZCBleHRlbnNpb24gZm9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBtaW1lIGZvdW5kIG1pbWUgdHlwZVxuICovXG5leHBvcnQgY29uc3QgZ2V0VHlwZSA9IHBhdGggPT4ge1xuICBjb25zdCBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKS5zbGljZSgtMSk7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV0uc3BsaXQoXCIuXCIpLnBvcCgpO1xuICBjb25zdCB0eXBlID0gZmluZFR5cGUoZXh0ZW5zaW9uKTtcbiAgcmV0dXJuIHR5cGVbMF07XG59O1xuXG4vKipcbiAqIFJldHVybiBmaWxlIGV4dGVuc2lvbiBhc3NvY2lhdGVkIHdpdGggYSBtaW1lIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIG1pbWUgdHlwZSB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBleHRlbnNpb24gZmlsZSBleHRlbnNpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEV4dGVuc2lvbiA9IHR5cGUgPT4gKG1pbWVUeXBlc1t0eXBlLnRvTG93ZXJDYXNlKCldIHx8IFtdKVswXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/utils/mime.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/core/es/utils/promisify.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jimp/core/es/utils/promisify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst promisify = function (fun, ctx) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n  return new Promise((resolve, reject) => {\n    args.push((err, data) => {\n      if (err) {\n        reject(err);\n      }\n      resolve(data);\n    });\n    fun.bind(ctx)(...args);\n  });\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (promisify);\n//# sourceMappingURL=promisify.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2VzL3V0aWxzL3Byb21pc2lmeS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUVBQWUsU0FBUyxFQUFDO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvY29yZS9lcy91dGlscy9wcm9taXNpZnkuanM/ZDg3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwcm9taXNpZnkgPSBmdW5jdGlvbiAoZnVuLCBjdHgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXJncy5wdXNoKChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIGZ1bi5iaW5kKGN0eCkoLi4uYXJncyk7XG4gIH0pO1xufTtcbmV4cG9ydCBkZWZhdWx0IHByb21pc2lmeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2lmeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/core/es/utils/promisify.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/custom/es/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@jimp/custom/es/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ configure)\n/* harmony export */ });\n/* harmony import */ var _jimp_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/core */ \"(action-browser)/./node_modules/@jimp/core/es/index.js\");\n\nfunction configure(configuration) {\n  let jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _jimp_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n  const jimpConfig = {\n    hasAlpha: {},\n    encoders: {},\n    decoders: {},\n    class: {},\n    constants: {}\n  };\n  function addToConfig(newConfig) {\n    Object.entries(newConfig).forEach(_ref => {\n      let [key, value] = _ref;\n      jimpConfig[key] = {\n        ...jimpConfig[key],\n        ...value\n      };\n    });\n  }\n  function addImageType(typeModule) {\n    const type = typeModule();\n    if (Array.isArray(type.mime)) {\n      (0,_jimp_core__WEBPACK_IMPORTED_MODULE_0__.addType)(...type.mime);\n    } else {\n      Object.entries(type.mime).forEach(mimeType => (0,_jimp_core__WEBPACK_IMPORTED_MODULE_0__.addType)(...mimeType));\n    }\n    delete type.mime;\n    addToConfig(type);\n  }\n  function addPlugin(pluginModule) {\n    const plugin = pluginModule(_jimp_core__WEBPACK_IMPORTED_MODULE_0__.jimpEvChange) || {};\n    if (!plugin.class && !plugin.constants) {\n      // Default to class function\n      addToConfig({\n        class: plugin\n      });\n    } else {\n      addToConfig(plugin);\n    }\n  }\n  if (configuration.types) {\n    configuration.types.forEach(addImageType);\n    jimpInstance.decoders = {\n      ...jimpInstance.decoders,\n      ...jimpConfig.decoders\n    };\n    jimpInstance.encoders = {\n      ...jimpInstance.encoders,\n      ...jimpConfig.encoders\n    };\n    jimpInstance.hasAlpha = {\n      ...jimpInstance.hasAlpha,\n      ...jimpConfig.hasAlpha\n    };\n  }\n  if (configuration.plugins) {\n    configuration.plugins.forEach(addPlugin);\n  }\n  (0,_jimp_core__WEBPACK_IMPORTED_MODULE_0__.addJimpMethods)(jimpConfig.class, jimpInstance);\n  (0,_jimp_core__WEBPACK_IMPORTED_MODULE_0__.addConstants)(jimpConfig.constants, jimpInstance);\n  return _jimp_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9jdXN0b20vZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUY7QUFDeEU7QUFDZix5RkFBeUYsa0RBQUk7QUFDN0Y7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtREFBTztBQUNiLE1BQU07QUFDTixvREFBb0QsbURBQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvREFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwREFBYztBQUNoQixFQUFFLHdEQUFZO0FBQ2QsU0FBUyxrREFBSTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9jdXN0b20vZXMvaW5kZXguanM/NjI5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSmltcCwgeyBhZGRUeXBlLCBhZGRKaW1wTWV0aG9kcywgYWRkQ29uc3RhbnRzLCBqaW1wRXZDaGFuZ2UgfSBmcm9tIFwiQGppbXAvY29yZVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uZmlndXJlKGNvbmZpZ3VyYXRpb24pIHtcbiAgbGV0IGppbXBJbnN0YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogSmltcDtcbiAgY29uc3QgamltcENvbmZpZyA9IHtcbiAgICBoYXNBbHBoYToge30sXG4gICAgZW5jb2RlcnM6IHt9LFxuICAgIGRlY29kZXJzOiB7fSxcbiAgICBjbGFzczoge30sXG4gICAgY29uc3RhbnRzOiB7fVxuICB9O1xuICBmdW5jdGlvbiBhZGRUb0NvbmZpZyhuZXdDb25maWcpIHtcbiAgICBPYmplY3QuZW50cmllcyhuZXdDb25maWcpLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgIGppbXBDb25maWdba2V5XSA9IHtcbiAgICAgICAgLi4uamltcENvbmZpZ1trZXldLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhZGRJbWFnZVR5cGUodHlwZU1vZHVsZSkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlTW9kdWxlKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZS5taW1lKSkge1xuICAgICAgYWRkVHlwZSguLi50eXBlLm1pbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZW50cmllcyh0eXBlLm1pbWUpLmZvckVhY2gobWltZVR5cGUgPT4gYWRkVHlwZSguLi5taW1lVHlwZSkpO1xuICAgIH1cbiAgICBkZWxldGUgdHlwZS5taW1lO1xuICAgIGFkZFRvQ29uZmlnKHR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFBsdWdpbihwbHVnaW5Nb2R1bGUpIHtcbiAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5Nb2R1bGUoamltcEV2Q2hhbmdlKSB8fCB7fTtcbiAgICBpZiAoIXBsdWdpbi5jbGFzcyAmJiAhcGx1Z2luLmNvbnN0YW50cykge1xuICAgICAgLy8gRGVmYXVsdCB0byBjbGFzcyBmdW5jdGlvblxuICAgICAgYWRkVG9Db25maWcoe1xuICAgICAgICBjbGFzczogcGx1Z2luXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkVG9Db25maWcocGx1Z2luKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbmZpZ3VyYXRpb24udHlwZXMpIHtcbiAgICBjb25maWd1cmF0aW9uLnR5cGVzLmZvckVhY2goYWRkSW1hZ2VUeXBlKTtcbiAgICBqaW1wSW5zdGFuY2UuZGVjb2RlcnMgPSB7XG4gICAgICAuLi5qaW1wSW5zdGFuY2UuZGVjb2RlcnMsXG4gICAgICAuLi5qaW1wQ29uZmlnLmRlY29kZXJzXG4gICAgfTtcbiAgICBqaW1wSW5zdGFuY2UuZW5jb2RlcnMgPSB7XG4gICAgICAuLi5qaW1wSW5zdGFuY2UuZW5jb2RlcnMsXG4gICAgICAuLi5qaW1wQ29uZmlnLmVuY29kZXJzXG4gICAgfTtcbiAgICBqaW1wSW5zdGFuY2UuaGFzQWxwaGEgPSB7XG4gICAgICAuLi5qaW1wSW5zdGFuY2UuaGFzQWxwaGEsXG4gICAgICAuLi5qaW1wQ29uZmlnLmhhc0FscGhhXG4gICAgfTtcbiAgfVxuICBpZiAoY29uZmlndXJhdGlvbi5wbHVnaW5zKSB7XG4gICAgY29uZmlndXJhdGlvbi5wbHVnaW5zLmZvckVhY2goYWRkUGx1Z2luKTtcbiAgfVxuICBhZGRKaW1wTWV0aG9kcyhqaW1wQ29uZmlnLmNsYXNzLCBqaW1wSW5zdGFuY2UpO1xuICBhZGRDb25zdGFudHMoamltcENvbmZpZy5jb25zdGFudHMsIGppbXBJbnN0YW5jZSk7XG4gIHJldHVybiBKaW1wO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/custom/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/gif/es/index.js":
/*!********************************************!*\
  !*** ./node_modules/@jimp/gif/es/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var omggif__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! omggif */ \"(action-browser)/./node_modules/omggif/omggif.js\");\n/* harmony import */ var gifwrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gifwrap */ \"(action-browser)/./node_modules/gifwrap/src/index.js\");\n/* harmony import */ var gifwrap__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gifwrap__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst MIME_TYPE = \"image/gif\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  mime: {\n    [MIME_TYPE]: [\"gif\"]\n  },\n  constants: {\n    MIME_GIF: MIME_TYPE\n  },\n  decoders: {\n    [MIME_TYPE]: data => {\n      const gifObj = new omggif__WEBPACK_IMPORTED_MODULE_0__.GifReader(data);\n      const gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);\n      gifObj.decodeAndBlitFrameRGBA(0, gifData);\n      return {\n        data: gifData,\n        width: gifObj.width,\n        height: gifObj.height\n      };\n    }\n  },\n  encoders: {\n    [MIME_TYPE]: data => {\n      const bitmap = new gifwrap__WEBPACK_IMPORTED_MODULE_1__.BitmapImage(data.bitmap);\n      gifwrap__WEBPACK_IMPORTED_MODULE_1__.GifUtil.quantizeDekker(bitmap, 256);\n      const newFrame = new gifwrap__WEBPACK_IMPORTED_MODULE_1__.GifFrame(bitmap);\n      const gifCodec = new gifwrap__WEBPACK_IMPORTED_MODULE_1__.GifCodec();\n      return gifCodec.encodeGif([newFrame], {}).then(newGif => {\n        return newGif.buffer;\n      });\n    }\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9naWYvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QjtBQUMwQztBQUNuRTtBQUNBLGlFQUFnQjtBQUNoQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQVc7QUFDcEMsTUFBTSw0Q0FBTztBQUNiLDJCQUEyQiw2Q0FBUTtBQUNuQywyQkFBMkIsNkNBQVE7QUFDbkMsOENBQThDO0FBQzlDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDLENBQUMsRUFBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvZ2lmL2VzL2luZGV4LmpzPzk0YzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdJRiBmcm9tIFwib21nZ2lmXCI7XG5pbXBvcnQgeyBHaWZVdGlsLCBHaWZGcmFtZSwgQml0bWFwSW1hZ2UsIEdpZkNvZGVjIH0gZnJvbSBcImdpZndyYXBcIjtcbmNvbnN0IE1JTUVfVFlQRSA9IFwiaW1hZ2UvZ2lmXCI7XG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgbWltZToge1xuICAgIFtNSU1FX1RZUEVdOiBbXCJnaWZcIl1cbiAgfSxcbiAgY29uc3RhbnRzOiB7XG4gICAgTUlNRV9HSUY6IE1JTUVfVFlQRVxuICB9LFxuICBkZWNvZGVyczoge1xuICAgIFtNSU1FX1RZUEVdOiBkYXRhID0+IHtcbiAgICAgIGNvbnN0IGdpZk9iaiA9IG5ldyBHSUYuR2lmUmVhZGVyKGRhdGEpO1xuICAgICAgY29uc3QgZ2lmRGF0YSA9IEJ1ZmZlci5hbGxvYyhnaWZPYmoud2lkdGggKiBnaWZPYmouaGVpZ2h0ICogNCk7XG4gICAgICBnaWZPYmouZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSgwLCBnaWZEYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGdpZkRhdGEsXG4gICAgICAgIHdpZHRoOiBnaWZPYmoud2lkdGgsXG4gICAgICAgIGhlaWdodDogZ2lmT2JqLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGVuY29kZXJzOiB7XG4gICAgW01JTUVfVFlQRV06IGRhdGEgPT4ge1xuICAgICAgY29uc3QgYml0bWFwID0gbmV3IEJpdG1hcEltYWdlKGRhdGEuYml0bWFwKTtcbiAgICAgIEdpZlV0aWwucXVhbnRpemVEZWtrZXIoYml0bWFwLCAyNTYpO1xuICAgICAgY29uc3QgbmV3RnJhbWUgPSBuZXcgR2lmRnJhbWUoYml0bWFwKTtcbiAgICAgIGNvbnN0IGdpZkNvZGVjID0gbmV3IEdpZkNvZGVjKCk7XG4gICAgICByZXR1cm4gZ2lmQ29kZWMuZW5jb2RlR2lmKFtuZXdGcmFtZV0sIHt9KS50aGVuKG5ld0dpZiA9PiB7XG4gICAgICAgIHJldHVybiBuZXdHaWYuYnVmZmVyO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/gif/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/jpeg/es/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@jimp/jpeg/es/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var jpeg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jpeg-js */ \"(action-browser)/./node_modules/jpeg-js/index.js\");\n/* harmony import */ var jpeg_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jpeg_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\nconst MIME_TYPE = \"image/jpeg\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  mime: {\n    [MIME_TYPE]: [\"jpeg\", \"jpg\", \"jpe\"]\n  },\n  constants: {\n    MIME_JPEG: MIME_TYPE\n  },\n  decoders: {\n    [MIME_TYPE]: (jpeg_js__WEBPACK_IMPORTED_MODULE_0___default().decode)\n  },\n  encoders: {\n    [MIME_TYPE]: image => jpeg_js__WEBPACK_IMPORTED_MODULE_0___default().encode(image.bitmap, image._quality).data\n  },\n  class: {\n    // The quality to be used when saving JPEG images\n    _quality: 100,\n    /**\n     * Sets the quality of the image when saving as JPEG format (default is 100)\n     * @param {number} n The quality to use 0-100\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    quality(n, cb) {\n      if (typeof n !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"n must be a number\", cb);\n      }\n      if (n < 0 || n > 100) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"n must be a number 0 - 100\", cb);\n      }\n      this._quality = Math.round(n);\n      if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    }\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9qcGVnL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkI7QUFDNkI7QUFDeEQ7QUFDQSxpRUFBZ0I7QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHVEQUFXO0FBQzVCLEdBQUc7QUFDSDtBQUNBLDBCQUEwQixxREFBVztBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQSxVQUFVLDBEQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsRUFBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvanBlZy9lcy9pbmRleC5qcz85ZDgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBKUEVHIGZyb20gXCJqcGVnLWpzXCI7XG5pbXBvcnQgeyB0aHJvd0Vycm9yLCBpc05vZGVQYXR0ZXJuIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5jb25zdCBNSU1FX1RZUEUgPSBcImltYWdlL2pwZWdcIjtcbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiAoe1xuICBtaW1lOiB7XG4gICAgW01JTUVfVFlQRV06IFtcImpwZWdcIiwgXCJqcGdcIiwgXCJqcGVcIl1cbiAgfSxcbiAgY29uc3RhbnRzOiB7XG4gICAgTUlNRV9KUEVHOiBNSU1FX1RZUEVcbiAgfSxcbiAgZGVjb2RlcnM6IHtcbiAgICBbTUlNRV9UWVBFXTogSlBFRy5kZWNvZGVcbiAgfSxcbiAgZW5jb2RlcnM6IHtcbiAgICBbTUlNRV9UWVBFXTogaW1hZ2UgPT4gSlBFRy5lbmNvZGUoaW1hZ2UuYml0bWFwLCBpbWFnZS5fcXVhbGl0eSkuZGF0YVxuICB9LFxuICBjbGFzczoge1xuICAgIC8vIFRoZSBxdWFsaXR5IHRvIGJlIHVzZWQgd2hlbiBzYXZpbmcgSlBFRyBpbWFnZXNcbiAgICBfcXVhbGl0eTogMTAwLFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHF1YWxpdHkgb2YgdGhlIGltYWdlIHdoZW4gc2F2aW5nIGFzIEpQRUcgZm9ybWF0IChkZWZhdWx0IGlzIDEwMClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgcXVhbGl0eSB0byB1c2UgMC0xMDBcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgKi9cbiAgICBxdWFsaXR5KG4sIGNiKSB7XG4gICAgICBpZiAodHlwZW9mIG4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIm4gbXVzdCBiZSBhIG51bWJlclwiLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAobiA8IDAgfHwgbiA+IDEwMCkge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwibiBtdXN0IGJlIGEgbnVtYmVyIDAgLSAxMDBcIiwgY2IpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcXVhbGl0eSA9IE1hdGgucm91bmQobik7XG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/jpeg/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-blit/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-blit/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  /**\n   * Blits a source image on to this image\n   * @param {Jimp} src the source Jimp instance\n   * @param {number} x the x position to blit the image\n   * @param {number} y the y position to blit the image\n   * @param {number} srcx (optional) the x position from which to crop the source image\n   * @param {number} srcy (optional) the y position from which to crop the source image\n   * @param {number} srcw (optional) the width to which to crop the source image\n   * @param {number} srch (optional) the height to which to crop the source image\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  blit(src, x, y, srcx, srcy, srcw, srch, cb) {\n    if (!(src instanceof this.constructor)) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"The source must be a Jimp image\", cb);\n    }\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"x and y must be numbers\", cb);\n    }\n    if (typeof srcx === \"function\") {\n      cb = srcx;\n      srcx = 0;\n      srcy = 0;\n      srcw = src.bitmap.width;\n      srch = src.bitmap.height;\n    } else if (typeof srcx === typeof srcy && typeof srcy === typeof srcw && typeof srcw === typeof srch) {\n      srcx = srcx || 0;\n      srcy = srcy || 0;\n      srcw = srcw || src.bitmap.width;\n      srch = srch || src.bitmap.height;\n    } else {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"srcx, srcy, srcw, srch must be numbers\", cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    // round input\n    srcx = Math.round(srcx);\n    srcy = Math.round(srcy);\n    srcw = Math.round(srcw);\n    srch = Math.round(srch);\n    const maxWidth = this.bitmap.width;\n    const maxHeight = this.bitmap.height;\n    const baseImage = this;\n    src.scanQuiet(srcx, srcy, srcw, srch, function (sx, sy, idx) {\n      const xOffset = x + sx - srcx;\n      const yOffset = y + sy - srcy;\n      if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {\n        const dstIdx = baseImage.getPixelIndex(xOffset, yOffset);\n        const src = {\n          r: this.bitmap.data[idx],\n          g: this.bitmap.data[idx + 1],\n          b: this.bitmap.data[idx + 2],\n          a: this.bitmap.data[idx + 3]\n        };\n        const dst = {\n          r: baseImage.bitmap.data[dstIdx],\n          g: baseImage.bitmap.data[dstIdx + 1],\n          b: baseImage.bitmap.data[dstIdx + 2],\n          a: baseImage.bitmap.data[dstIdx + 3]\n        };\n        baseImage.bitmap.data[dstIdx] = (src.a * (src.r - dst.r) - dst.r + 255 >> 8) + dst.r;\n        baseImage.bitmap.data[dstIdx + 1] = (src.a * (src.g - dst.g) - dst.g + 255 >> 8) + dst.g;\n        baseImage.bitmap.data[dstIdx + 2] = (src.a * (src.b - dst.b) - dst.b + 255 >> 8) + dst.b;\n        baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + src.a);\n      }\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tYmxpdC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDtBQUN4RCxpRUFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVCQUF1QjtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhLG1EQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tYmxpdC9lcy9pbmRleC5qcz85OGUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRocm93RXJyb3IsIGlzTm9kZVBhdHRlcm4gfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiAoe1xuICAvKipcbiAgICogQmxpdHMgYSBzb3VyY2UgaW1hZ2Ugb24gdG8gdGhpcyBpbWFnZVxuICAgKiBAcGFyYW0ge0ppbXB9IHNyYyB0aGUgc291cmNlIEppbXAgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggcG9zaXRpb24gdG8gYmxpdCB0aGUgaW1hZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgdGhlIHkgcG9zaXRpb24gdG8gYmxpdCB0aGUgaW1hZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNyY3ggKG9wdGlvbmFsKSB0aGUgeCBwb3NpdGlvbiBmcm9tIHdoaWNoIHRvIGNyb3AgdGhlIHNvdXJjZSBpbWFnZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3JjeSAob3B0aW9uYWwpIHRoZSB5IHBvc2l0aW9uIGZyb20gd2hpY2ggdG8gY3JvcCB0aGUgc291cmNlIGltYWdlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcmN3IChvcHRpb25hbCkgdGhlIHdpZHRoIHRvIHdoaWNoIHRvIGNyb3AgdGhlIHNvdXJjZSBpbWFnZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3JjaCAob3B0aW9uYWwpIHRoZSBoZWlnaHQgdG8gd2hpY2ggdG8gY3JvcCB0aGUgc291cmNlIGltYWdlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIGJsaXQoc3JjLCB4LCB5LCBzcmN4LCBzcmN5LCBzcmN3LCBzcmNoLCBjYikge1xuICAgIGlmICghKHNyYyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiVGhlIHNvdXJjZSBtdXN0IGJlIGEgSmltcCBpbWFnZVwiLCBjYik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInggYW5kIHkgbXVzdCBiZSBudW1iZXJzXCIsIGNiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmN4ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNiID0gc3JjeDtcbiAgICAgIHNyY3ggPSAwO1xuICAgICAgc3JjeSA9IDA7XG4gICAgICBzcmN3ID0gc3JjLmJpdG1hcC53aWR0aDtcbiAgICAgIHNyY2ggPSBzcmMuYml0bWFwLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcmN4ID09PSB0eXBlb2Ygc3JjeSAmJiB0eXBlb2Ygc3JjeSA9PT0gdHlwZW9mIHNyY3cgJiYgdHlwZW9mIHNyY3cgPT09IHR5cGVvZiBzcmNoKSB7XG4gICAgICBzcmN4ID0gc3JjeCB8fCAwO1xuICAgICAgc3JjeSA9IHNyY3kgfHwgMDtcbiAgICAgIHNyY3cgPSBzcmN3IHx8IHNyYy5iaXRtYXAud2lkdGg7XG4gICAgICBzcmNoID0gc3JjaCB8fCBzcmMuYml0bWFwLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInNyY3gsIHNyY3ksIHNyY3csIHNyY2ggbXVzdCBiZSBudW1iZXJzXCIsIGNiKTtcbiAgICB9XG5cbiAgICAvLyByb3VuZCBpbnB1dFxuICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuXG4gICAgLy8gcm91bmQgaW5wdXRcbiAgICBzcmN4ID0gTWF0aC5yb3VuZChzcmN4KTtcbiAgICBzcmN5ID0gTWF0aC5yb3VuZChzcmN5KTtcbiAgICBzcmN3ID0gTWF0aC5yb3VuZChzcmN3KTtcbiAgICBzcmNoID0gTWF0aC5yb3VuZChzcmNoKTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IHRoaXMuYml0bWFwLndpZHRoO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuYml0bWFwLmhlaWdodDtcbiAgICBjb25zdCBiYXNlSW1hZ2UgPSB0aGlzO1xuICAgIHNyYy5zY2FuUXVpZXQoc3JjeCwgc3JjeSwgc3Jjdywgc3JjaCwgZnVuY3Rpb24gKHN4LCBzeSwgaWR4KSB7XG4gICAgICBjb25zdCB4T2Zmc2V0ID0geCArIHN4IC0gc3JjeDtcbiAgICAgIGNvbnN0IHlPZmZzZXQgPSB5ICsgc3kgLSBzcmN5O1xuICAgICAgaWYgKHhPZmZzZXQgPj0gMCAmJiB5T2Zmc2V0ID49IDAgJiYgbWF4V2lkdGggLSB4T2Zmc2V0ID4gMCAmJiBtYXhIZWlnaHQgLSB5T2Zmc2V0ID4gMCkge1xuICAgICAgICBjb25zdCBkc3RJZHggPSBiYXNlSW1hZ2UuZ2V0UGl4ZWxJbmRleCh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc3JjID0ge1xuICAgICAgICAgIHI6IHRoaXMuYml0bWFwLmRhdGFbaWR4XSxcbiAgICAgICAgICBnOiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdLFxuICAgICAgICAgIGI6IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0sXG4gICAgICAgICAgYTogdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAzXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkc3QgPSB7XG4gICAgICAgICAgcjogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeF0sXG4gICAgICAgICAgZzogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDFdLFxuICAgICAgICAgIGI6IGJhc2VJbWFnZS5iaXRtYXAuZGF0YVtkc3RJZHggKyAyXSxcbiAgICAgICAgICBhOiBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgM11cbiAgICAgICAgfTtcbiAgICAgICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeF0gPSAoc3JjLmEgKiAoc3JjLnIgLSBkc3QucikgLSBkc3QuciArIDI1NSA+PiA4KSArIGRzdC5yO1xuICAgICAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgMV0gPSAoc3JjLmEgKiAoc3JjLmcgLSBkc3QuZykgLSBkc3QuZyArIDI1NSA+PiA4KSArIGRzdC5nO1xuICAgICAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgMl0gPSAoc3JjLmEgKiAoc3JjLmIgLSBkc3QuYikgLSBkc3QuYiArIDI1NSA+PiA4KSArIGRzdC5iO1xuICAgICAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgM10gPSB0aGlzLmNvbnN0cnVjdG9yLmxpbWl0MjU1KGRzdC5hICsgc3JjLmEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-blit/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-blur/es/blur-tables.js":
/*!**********************************************************!*\
  !*** ./node_modules/@jimp/plugin-blur/es/blur-tables.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mulTable: () => (/* binding */ mulTable),\n/* harmony export */   shgTable: () => (/* binding */ shgTable)\n/* harmony export */ });\nconst mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];\nconst shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];\n//# sourceMappingURL=blur-tables.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tYmx1ci9lcy9ibHVyLXRhYmxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1ibHVyL2VzL2JsdXItdGFibGVzLmpzPzZiNDIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IG11bFRhYmxlID0gWzEsIDU3LCA0MSwgMjEsIDIwMywgMzQsIDk3LCA3MywgMjI3LCA5MSwgMTQ5LCA2MiwgMTA1LCA0NSwgMzksIDEzNywgMjQxLCAxMDcsIDMsIDE3MywgMzksIDcxLCA2NSwgMjM4LCAyMTksIDEwMSwgMTg3LCA4NywgODEsIDE1MSwgMTQxLCAxMzMsIDI0OSwgMTE3LCAyMjEsIDIwOSwgMTk3LCAxODcsIDE3NywgMTY5LCA1LCAxNTMsIDczLCAxMzksIDEzMywgMTI3LCAyNDMsIDIzMywgMjIzLCAxMDcsIDEwMywgOTksIDE5MSwgMjMsIDE3NywgMTcxLCAxNjUsIDE1OSwgNzcsIDE0OSwgOSwgMTM5LCAxMzUsIDEzMSwgMjUzLCAyNDUsIDExOSwgMjMxLCAyMjQsIDEwOSwgMjExLCAxMDMsIDI1LCAxOTUsIDE4OSwgMjMsIDQ1LCAxNzUsIDE3MSwgODMsIDgxLCA3OSwgMTU1LCAxNTEsIDE0NywgOSwgMTQxLCAxMzcsIDY3LCAxMzEsIDEyOSwgMjUxLCAxMjMsIDMwLCAyMzUsIDExNSwgMTEzLCAyMjEsIDIxNywgNTMsIDEzLCA1MSwgNTAsIDQ5LCAxOTMsIDE4OSwgMTg1LCA5MSwgMTc5LCAxNzUsIDQzLCAxNjksIDgzLCAxNjMsIDUsIDc5LCAxNTUsIDE5LCA3NSwgMTQ3LCAxNDUsIDE0MywgMzUsIDY5LCAxNywgNjcsIDMzLCA2NSwgMjU1LCAyNTEsIDI0NywgMjQzLCAyMzksIDU5LCAyOSwgMjI5LCAxMTMsIDExMSwgMjE5LCAyNywgMjEzLCAxMDUsIDIwNywgNTEsIDIwMSwgMTk5LCA0OSwgMTkzLCAxOTEsIDQ3LCA5MywgMTgzLCAxODEsIDE3OSwgMTEsIDg3LCA0MywgODUsIDE2NywgMTY1LCAxNjMsIDE2MSwgMTU5LCAxNTcsIDE1NSwgNzcsIDE5LCA3NSwgMzcsIDczLCAxNDUsIDE0MywgMTQxLCAzNSwgMTM4LCAxMzcsIDEzNSwgNjcsIDMzLCAxMzEsIDEyOSwgMjU1LCA2MywgMjUwLCAyNDcsIDYxLCAxMjEsIDIzOSwgMjM3LCAxMTcsIDI5LCAyMjksIDIyNywgMjI1LCAxMTEsIDU1LCAxMDksIDIxNiwgMjEzLCAyMTEsIDIwOSwgMjA3LCAyMDUsIDIwMywgMjAxLCAxOTksIDE5NywgMTk1LCAxOTMsIDQ4LCAxOTAsIDQ3LCA5MywgMTg1LCAxODMsIDE4MSwgMTc5LCAxNzgsIDE3NiwgMTc1LCAxNzMsIDE3MSwgODUsIDIxLCAxNjcsIDE2NSwgNDEsIDE2MywgMTYxLCA1LCA3OSwgMTU3LCA3OCwgMTU0LCAxNTMsIDE5LCA3NSwgMTQ5LCA3NCwgMTQ3LCA3MywgMTQ0LCAxNDMsIDcxLCAxNDEsIDE0MCwgMTM5LCAxMzcsIDE3LCAxMzUsIDEzNCwgMTMzLCA2NiwgMTMxLCA2NSwgMTI5LCAxXTtcbmV4cG9ydCBjb25zdCBzaGdUYWJsZSA9IFswLCA5LCAxMCwgMTAsIDE0LCAxMiwgMTQsIDE0LCAxNiwgMTUsIDE2LCAxNSwgMTYsIDE1LCAxNSwgMTcsIDE4LCAxNywgMTIsIDE4LCAxNiwgMTcsIDE3LCAxOSwgMTksIDE4LCAxOSwgMTgsIDE4LCAxOSwgMTksIDE5LCAyMCwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDE1LCAyMCwgMTksIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIwLCAyMCwgMjAsIDIxLCAxOCwgMjEsIDIxLCAyMSwgMjEsIDIwLCAyMSwgMTcsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjEsIDIyLCAyMiwgMjEsIDIyLCAyMSwgMTksIDIyLCAyMiwgMTksIDIwLCAyMiwgMjIsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDE4LCAyMiwgMjIsIDIxLCAyMiwgMjIsIDIzLCAyMiwgMjAsIDIzLCAyMiwgMjIsIDIzLCAyMywgMjEsIDE5LCAyMSwgMjEsIDIxLCAyMywgMjMsIDIzLCAyMiwgMjMsIDIzLCAyMSwgMjMsIDIyLCAyMywgMTgsIDIyLCAyMywgMjAsIDIyLCAyMywgMjMsIDIzLCAyMSwgMjIsIDIwLCAyMiwgMjEsIDIyLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDIyLCAyMSwgMjQsIDIzLCAyMywgMjQsIDIxLCAyNCwgMjMsIDI0LCAyMiwgMjQsIDI0LCAyMiwgMjQsIDI0LCAyMiwgMjMsIDI0LCAyNCwgMjQsIDIwLCAyMywgMjIsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjMsIDIxLCAyMywgMjIsIDIzLCAyNCwgMjQsIDI0LCAyMiwgMjQsIDI0LCAyNCwgMjMsIDIyLCAyNCwgMjQsIDI1LCAyMywgMjUsIDI1LCAyMywgMjQsIDI1LCAyNSwgMjQsIDIyLCAyNSwgMjUsIDI1LCAyNCwgMjMsIDI0LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyMywgMjUsIDIzLCAyNCwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjQsIDIyLCAyNSwgMjUsIDIzLCAyNSwgMjUsIDIwLCAyNCwgMjUsIDI0LCAyNSwgMjUsIDIyLCAyNCwgMjUsIDI0LCAyNSwgMjQsIDI1LCAyNSwgMjQsIDI1LCAyNSwgMjUsIDI1LCAyMiwgMjUsIDI1LCAyNSwgMjQsIDI1LCAyNCwgMjUsIDE4XTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsdXItdGFibGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-blur/es/blur-tables.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-blur/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-blur/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n/* harmony import */ var _blur_tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blur-tables */ \"(action-browser)/./node_modules/@jimp/plugin-blur/es/blur-tables.js\");\n\n\n\n/*\n    Superfast Blur (0.5)\n    http://www.quasimondo.com/BoxBlurForCanvas/FastBlur.js\n\n    Copyright (c) 2011 Mario Klingemann\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  /**\n   * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker\n   * @param {number} r the pixel radius of the blur\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  blur(r, cb) {\n    if (typeof r !== \"number\") return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"r must be a number\", cb);\n    if (r < 1) return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"r must be greater than 0\", cb);\n    let rsum;\n    let gsum;\n    let bsum;\n    let asum;\n    let x;\n    let y;\n    let i;\n    let p;\n    let p1;\n    let p2;\n    let yp;\n    let yi;\n    let yw;\n    let pa;\n    const wm = this.bitmap.width - 1;\n    const hm = this.bitmap.height - 1;\n    // const wh = this.bitmap.width * this.bitmap.height;\n    const rad1 = r + 1;\n    const mulSum = _blur_tables__WEBPACK_IMPORTED_MODULE_1__.mulTable[r];\n    const shgSum = _blur_tables__WEBPACK_IMPORTED_MODULE_1__.shgTable[r];\n    const red = [];\n    const green = [];\n    const blue = [];\n    const alpha = [];\n    const vmin = [];\n    const vmax = [];\n    let iterations = 2;\n    while (iterations-- > 0) {\n      yi = 0;\n      yw = 0;\n      for (y = 0; y < this.bitmap.height; y++) {\n        rsum = this.bitmap.data[yw] * rad1;\n        gsum = this.bitmap.data[yw + 1] * rad1;\n        bsum = this.bitmap.data[yw + 2] * rad1;\n        asum = this.bitmap.data[yw + 3] * rad1;\n        for (i = 1; i <= r; i++) {\n          p = yw + ((i > wm ? wm : i) << 2);\n          rsum += this.bitmap.data[p++];\n          gsum += this.bitmap.data[p++];\n          bsum += this.bitmap.data[p++];\n          asum += this.bitmap.data[p];\n        }\n        for (x = 0; x < this.bitmap.width; x++) {\n          red[yi] = rsum;\n          green[yi] = gsum;\n          blue[yi] = bsum;\n          alpha[yi] = asum;\n          if (y === 0) {\n            vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;\n            vmax[x] = (p = x - r) > 0 ? p << 2 : 0;\n          }\n          p1 = yw + vmin[x];\n          p2 = yw + vmax[x];\n          rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];\n          gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];\n          bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];\n          asum += this.bitmap.data[p1] - this.bitmap.data[p2];\n          yi++;\n        }\n        yw += this.bitmap.width << 2;\n      }\n      for (x = 0; x < this.bitmap.width; x++) {\n        yp = x;\n        rsum = red[yp] * rad1;\n        gsum = green[yp] * rad1;\n        bsum = blue[yp] * rad1;\n        asum = alpha[yp] * rad1;\n        for (i = 1; i <= r; i++) {\n          yp += i > hm ? 0 : this.bitmap.width;\n          rsum += red[yp];\n          gsum += green[yp];\n          bsum += blue[yp];\n          asum += alpha[yp];\n        }\n        yi = x << 2;\n        for (y = 0; y < this.bitmap.height; y++) {\n          pa = asum * mulSum >>> shgSum;\n          this.bitmap.data[yi + 3] = pa;\n\n          // normalize alpha\n          if (pa > 255) {\n            this.bitmap.data[yi + 3] = 255;\n          }\n          if (pa > 0) {\n            pa = 255 / pa;\n            this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa;\n            this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa;\n            this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa;\n          } else {\n            this.bitmap.data[yi + 2] = 0;\n            this.bitmap.data[yi + 1] = 0;\n            this.bitmap.data[yi] = 0;\n          }\n          if (x === 0) {\n            vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width;\n            vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0;\n          }\n          p1 = x + vmin[y];\n          p2 = x + vmax[y];\n          rsum += red[p1] - red[p2];\n          gsum += green[p1] - green[p2];\n          bsum += blue[p1] - blue[p2];\n          asum += alpha[p1] - alpha[p2];\n          yi += this.bitmap.width << 2;\n        }\n      }\n    }\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tYmx1ci9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0Q7QUFDTDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxzQ0FBc0MsbURBQVU7QUFDaEQsc0JBQXNCLG1EQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBUTtBQUMzQixtQkFBbUIsa0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tYmx1ci9lcy9pbmRleC5qcz81NGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRocm93RXJyb3IsIGlzTm9kZVBhdHRlcm4gfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbmltcG9ydCB7IG11bFRhYmxlLCBzaGdUYWJsZSB9IGZyb20gXCIuL2JsdXItdGFibGVzXCI7XG5cbi8qXG4gICAgU3VwZXJmYXN0IEJsdXIgKDAuNSlcbiAgICBodHRwOi8vd3d3LnF1YXNpbW9uZG8uY29tL0JveEJsdXJGb3JDYW52YXMvRmFzdEJsdXIuanNcblxuICAgIENvcHlyaWdodCAoYykgMjAxMSBNYXJpbyBLbGluZ2VtYW5uXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiAoe1xuICAvKipcbiAgICogQSBmYXN0IGJsdXIgYWxnb3JpdGhtIHRoYXQgcHJvZHVjZXMgc2ltaWxhciBlZmZlY3QgdG8gYSBHYXVzc2lhbiBibHVyIC0gYnV0IE1VQ0ggcXVpY2tlclxuICAgKiBAcGFyYW0ge251bWJlcn0gciB0aGUgcGl4ZWwgcmFkaXVzIG9mIHRoZSBibHVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIGJsdXIociwgY2IpIHtcbiAgICBpZiAodHlwZW9mIHIgIT09IFwibnVtYmVyXCIpIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJyIG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgIGlmIChyIDwgMSkgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInIgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiLCBjYik7XG4gICAgbGV0IHJzdW07XG4gICAgbGV0IGdzdW07XG4gICAgbGV0IGJzdW07XG4gICAgbGV0IGFzdW07XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IGk7XG4gICAgbGV0IHA7XG4gICAgbGV0IHAxO1xuICAgIGxldCBwMjtcbiAgICBsZXQgeXA7XG4gICAgbGV0IHlpO1xuICAgIGxldCB5dztcbiAgICBsZXQgcGE7XG4gICAgY29uc3Qgd20gPSB0aGlzLmJpdG1hcC53aWR0aCAtIDE7XG4gICAgY29uc3QgaG0gPSB0aGlzLmJpdG1hcC5oZWlnaHQgLSAxO1xuICAgIC8vIGNvbnN0IHdoID0gdGhpcy5iaXRtYXAud2lkdGggKiB0aGlzLmJpdG1hcC5oZWlnaHQ7XG4gICAgY29uc3QgcmFkMSA9IHIgKyAxO1xuICAgIGNvbnN0IG11bFN1bSA9IG11bFRhYmxlW3JdO1xuICAgIGNvbnN0IHNoZ1N1bSA9IHNoZ1RhYmxlW3JdO1xuICAgIGNvbnN0IHJlZCA9IFtdO1xuICAgIGNvbnN0IGdyZWVuID0gW107XG4gICAgY29uc3QgYmx1ZSA9IFtdO1xuICAgIGNvbnN0IGFscGhhID0gW107XG4gICAgY29uc3Qgdm1pbiA9IFtdO1xuICAgIGNvbnN0IHZtYXggPSBbXTtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDI7XG4gICAgd2hpbGUgKGl0ZXJhdGlvbnMtLSA+IDApIHtcbiAgICAgIHlpID0gMDtcbiAgICAgIHl3ID0gMDtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCB0aGlzLmJpdG1hcC5oZWlnaHQ7IHkrKykge1xuICAgICAgICByc3VtID0gdGhpcy5iaXRtYXAuZGF0YVt5d10gKiByYWQxO1xuICAgICAgICBnc3VtID0gdGhpcy5iaXRtYXAuZGF0YVt5dyArIDFdICogcmFkMTtcbiAgICAgICAgYnN1bSA9IHRoaXMuYml0bWFwLmRhdGFbeXcgKyAyXSAqIHJhZDE7XG4gICAgICAgIGFzdW0gPSB0aGlzLmJpdG1hcC5kYXRhW3l3ICsgM10gKiByYWQxO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHI7IGkrKykge1xuICAgICAgICAgIHAgPSB5dyArICgoaSA+IHdtID8gd20gOiBpKSA8PCAyKTtcbiAgICAgICAgICByc3VtICs9IHRoaXMuYml0bWFwLmRhdGFbcCsrXTtcbiAgICAgICAgICBnc3VtICs9IHRoaXMuYml0bWFwLmRhdGFbcCsrXTtcbiAgICAgICAgICBic3VtICs9IHRoaXMuYml0bWFwLmRhdGFbcCsrXTtcbiAgICAgICAgICBhc3VtICs9IHRoaXMuYml0bWFwLmRhdGFbcF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHRoaXMuYml0bWFwLndpZHRoOyB4KyspIHtcbiAgICAgICAgICByZWRbeWldID0gcnN1bTtcbiAgICAgICAgICBncmVlblt5aV0gPSBnc3VtO1xuICAgICAgICAgIGJsdWVbeWldID0gYnN1bTtcbiAgICAgICAgICBhbHBoYVt5aV0gPSBhc3VtO1xuICAgICAgICAgIGlmICh5ID09PSAwKSB7XG4gICAgICAgICAgICB2bWluW3hdID0gKChwID0geCArIHJhZDEpIDwgd20gPyBwIDogd20pIDw8IDI7XG4gICAgICAgICAgICB2bWF4W3hdID0gKHAgPSB4IC0gcikgPiAwID8gcCA8PCAyIDogMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcDEgPSB5dyArIHZtaW5beF07XG4gICAgICAgICAgcDIgPSB5dyArIHZtYXhbeF07XG4gICAgICAgICAgcnN1bSArPSB0aGlzLmJpdG1hcC5kYXRhW3AxKytdIC0gdGhpcy5iaXRtYXAuZGF0YVtwMisrXTtcbiAgICAgICAgICBnc3VtICs9IHRoaXMuYml0bWFwLmRhdGFbcDErK10gLSB0aGlzLmJpdG1hcC5kYXRhW3AyKytdO1xuICAgICAgICAgIGJzdW0gKz0gdGhpcy5iaXRtYXAuZGF0YVtwMSsrXSAtIHRoaXMuYml0bWFwLmRhdGFbcDIrK107XG4gICAgICAgICAgYXN1bSArPSB0aGlzLmJpdG1hcC5kYXRhW3AxXSAtIHRoaXMuYml0bWFwLmRhdGFbcDJdO1xuICAgICAgICAgIHlpKys7XG4gICAgICAgIH1cbiAgICAgICAgeXcgKz0gdGhpcy5iaXRtYXAud2lkdGggPDwgMjtcbiAgICAgIH1cbiAgICAgIGZvciAoeCA9IDA7IHggPCB0aGlzLmJpdG1hcC53aWR0aDsgeCsrKSB7XG4gICAgICAgIHlwID0geDtcbiAgICAgICAgcnN1bSA9IHJlZFt5cF0gKiByYWQxO1xuICAgICAgICBnc3VtID0gZ3JlZW5beXBdICogcmFkMTtcbiAgICAgICAgYnN1bSA9IGJsdWVbeXBdICogcmFkMTtcbiAgICAgICAgYXN1bSA9IGFscGhhW3lwXSAqIHJhZDE7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gcjsgaSsrKSB7XG4gICAgICAgICAgeXAgKz0gaSA+IGhtID8gMCA6IHRoaXMuYml0bWFwLndpZHRoO1xuICAgICAgICAgIHJzdW0gKz0gcmVkW3lwXTtcbiAgICAgICAgICBnc3VtICs9IGdyZWVuW3lwXTtcbiAgICAgICAgICBic3VtICs9IGJsdWVbeXBdO1xuICAgICAgICAgIGFzdW0gKz0gYWxwaGFbeXBdO1xuICAgICAgICB9XG4gICAgICAgIHlpID0geCA8PCAyO1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgdGhpcy5iaXRtYXAuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICBwYSA9IGFzdW0gKiBtdWxTdW0gPj4+IHNoZ1N1bTtcbiAgICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW3lpICsgM10gPSBwYTtcblxuICAgICAgICAgIC8vIG5vcm1hbGl6ZSBhbHBoYVxuICAgICAgICAgIGlmIChwYSA+IDI1NSkge1xuICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVt5aSArIDNdID0gMjU1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGEgPiAwKSB7XG4gICAgICAgICAgICBwYSA9IDI1NSAvIHBhO1xuICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVt5aV0gPSAocnN1bSAqIG11bFN1bSA+Pj4gc2hnU3VtKSAqIHBhO1xuICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVt5aSArIDFdID0gKGdzdW0gKiBtdWxTdW0gPj4+IHNoZ1N1bSkgKiBwYTtcbiAgICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGFbeWkgKyAyXSA9IChic3VtICogbXVsU3VtID4+PiBzaGdTdW0pICogcGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGFbeWkgKyAyXSA9IDA7XG4gICAgICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW3lpICsgMV0gPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVt5aV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgICAgdm1pblt5XSA9ICgocCA9IHkgKyByYWQxKSA8IGhtID8gcCA6IGhtKSAqIHRoaXMuYml0bWFwLndpZHRoO1xuICAgICAgICAgICAgdm1heFt5XSA9IChwID0geSAtIHIpID4gMCA/IHAgKiB0aGlzLmJpdG1hcC53aWR0aCA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHAxID0geCArIHZtaW5beV07XG4gICAgICAgICAgcDIgPSB4ICsgdm1heFt5XTtcbiAgICAgICAgICByc3VtICs9IHJlZFtwMV0gLSByZWRbcDJdO1xuICAgICAgICAgIGdzdW0gKz0gZ3JlZW5bcDFdIC0gZ3JlZW5bcDJdO1xuICAgICAgICAgIGJzdW0gKz0gYmx1ZVtwMV0gLSBibHVlW3AyXTtcbiAgICAgICAgICBhc3VtICs9IGFscGhhW3AxXSAtIGFscGhhW3AyXTtcbiAgICAgICAgICB5aSArPSB0aGlzLmJpdG1hcC53aWR0aCA8PCAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-blur/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-circle/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-circle/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Creates a circle out of an image.\n * @param {function(Error, Jimp)} options (optional) radius, x, y\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  circle() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cb = arguments.length > 1 ? arguments[1] : undefined;\n    if (typeof options === \"function\") {\n      cb = options;\n      options = {};\n    }\n    const radius = options.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2;\n    const center = {\n      x: typeof options.x === \"number\" ? options.x : this.bitmap.width / 2,\n      y: typeof options.y === \"number\" ? options.y : this.bitmap.height / 2\n    };\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      const curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));\n      if (radius - curR <= 0.0) {\n        this.bitmap.data[idx + 3] = 0;\n      } else if (radius - curR < 1.0) {\n        this.bitmap.data[idx + 3] = 255 * (radius - curR);\n      }\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY2lyY2xlL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDOztBQUU1QztBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY2lyY2xlL2VzL2luZGV4LmpzPzlhNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXJjbGUgb3V0IG9mIGFuIGltYWdlLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IG9wdGlvbnMgKG9wdGlvbmFsKSByYWRpdXMsIHgsIHlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiAoe1xuICBjaXJjbGUoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8ICh0aGlzLmJpdG1hcC53aWR0aCA+IHRoaXMuYml0bWFwLmhlaWdodCA/IHRoaXMuYml0bWFwLmhlaWdodCA6IHRoaXMuYml0bWFwLndpZHRoKSAvIDI7XG4gICAgY29uc3QgY2VudGVyID0ge1xuICAgICAgeDogdHlwZW9mIG9wdGlvbnMueCA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMueCA6IHRoaXMuYml0bWFwLndpZHRoIC8gMixcbiAgICAgIHk6IHR5cGVvZiBvcHRpb25zLnkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnkgOiB0aGlzLmJpdG1hcC5oZWlnaHQgLyAyXG4gICAgfTtcbiAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICBjb25zdCBjdXJSID0gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBjZW50ZXIueCwgMikgKyBNYXRoLnBvdyh5IC0gY2VudGVyLnksIDIpKTtcbiAgICAgIGlmIChyYWRpdXMgLSBjdXJSIDw9IDAuMCkge1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXVzIC0gY3VyUiA8IDEuMCkge1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdID0gMjU1ICogKHJhZGl1cyAtIGN1clIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-circle/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-color/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/plugin-color/es/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColorActionName: () => (/* binding */ ColorActionName),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tinycolor2 */ \"(action-browser)/./node_modules/tinycolor2/esm/tinycolor.js\");\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\nfunction applyKernel(im, kernel, x, y) {\n  const value = [0, 0, 0];\n  const size = (kernel.length - 1) / 2;\n  for (let kx = 0; kx < kernel.length; kx += 1) {\n    for (let ky = 0; ky < kernel[kx].length; ky += 1) {\n      const idx = im.getPixelIndex(x + kx - size, y + ky - size);\n      value[0] += im.bitmap.data[idx] * kernel[kx][ky];\n      value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];\n      value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];\n    }\n  }\n  return value;\n}\nconst isDef = v => typeof v !== \"undefined\" && v !== null;\nfunction greyscale(cb) {\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n    const grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);\n    this.bitmap.data[idx] = grey;\n    this.bitmap.data[idx + 1] = grey;\n    this.bitmap.data[idx + 2] = grey;\n  });\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}\nfunction mix(clr, clr2) {\n  let p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;\n  return {\n    r: (clr2.r - clr.r) * (p / 100) + clr.r,\n    g: (clr2.g - clr.g) * (p / 100) + clr.g,\n    b: (clr2.b - clr.b) * (p / 100) + clr.b\n  };\n}\nfunction colorFn(actions, cb) {\n  if (!actions || !Array.isArray(actions)) {\n    return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"actions must be an array\", cb);\n  }\n  actions = actions.map(action => {\n    if (action.apply === \"xor\" || action.apply === \"mix\") {\n      action.params[0] = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(action.params[0]).toRgb();\n    }\n    return action;\n  });\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {\n    let clr = {\n      r: this.bitmap.data[idx],\n      g: this.bitmap.data[idx + 1],\n      b: this.bitmap.data[idx + 2]\n    };\n    const colorModifier = (i, amount) => this.constructor.limit255(clr[i] + amount);\n    actions.forEach(action => {\n      if (action.apply === \"mix\") {\n        clr = mix(clr, action.params[0], action.params[1]);\n      } else if (action.apply === \"tint\") {\n        clr = mix(clr, {\n          r: 255,\n          g: 255,\n          b: 255\n        }, action.params[0]);\n      } else if (action.apply === \"shade\") {\n        clr = mix(clr, {\n          r: 0,\n          g: 0,\n          b: 0\n        }, action.params[0]);\n      } else if (action.apply === \"xor\") {\n        clr = {\n          r: clr.r ^ action.params[0].r,\n          g: clr.g ^ action.params[0].g,\n          b: clr.b ^ action.params[0].b\n        };\n      } else if (action.apply === \"red\") {\n        clr.r = colorModifier(\"r\", action.params[0]);\n      } else if (action.apply === \"green\") {\n        clr.g = colorModifier(\"g\", action.params[0]);\n      } else if (action.apply === \"blue\") {\n        clr.b = colorModifier(\"b\", action.params[0]);\n      } else {\n        if (action.apply === \"hue\") {\n          action.apply = \"spin\";\n        }\n        clr = (0,tinycolor2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(clr);\n        if (!clr[action.apply]) {\n          return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"action \" + action.apply + \" not supported\", cb);\n        }\n        clr = clr[action.apply](...action.params).toRgb();\n      }\n    });\n    this.bitmap.data[idx] = clr.r;\n    this.bitmap.data[idx + 1] = clr.g;\n    this.bitmap.data[idx + 2] = clr.b;\n  });\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}\nconst ColorActionName = Object.freeze({\n  LIGHTEN: \"lighten\",\n  BRIGHTEN: \"brighten\",\n  DARKEN: \"darken\",\n  DESATURATE: \"desaturate\",\n  SATURATE: \"saturate\",\n  GREYSCALE: \"greyscale\",\n  SPIN: \"spin\",\n  HUE: \"hue\",\n  MIX: \"mix\",\n  TINT: \"tint\",\n  SHADE: \"shade\",\n  XOR: \"xor\",\n  RED: \"red\",\n  GREEN: \"green\",\n  BLUE: \"blue\"\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  /**\n   * Adjusts the brightness of the image\n   * @param {number} val the amount to adjust the brightness, a number between -1 and +1\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  brightness(val, cb) {\n    if (typeof val !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"val must be numbers\", cb);\n    }\n    if (val < -1 || val > +1) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"val must be a number between -1 and +1\", cb);\n    }\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      if (val < 0.0) {\n        this.bitmap.data[idx] *= 1 + val;\n        this.bitmap.data[idx + 1] *= 1 + val;\n        this.bitmap.data[idx + 2] *= 1 + val;\n      } else {\n        this.bitmap.data[idx] += (255 - this.bitmap.data[idx]) * val;\n        this.bitmap.data[idx + 1] += (255 - this.bitmap.data[idx + 1]) * val;\n        this.bitmap.data[idx + 2] += (255 - this.bitmap.data[idx + 2]) * val;\n      }\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Adjusts the contrast of the image\n   * @param {number} val the amount to adjust the contrast, a number between -1 and +1\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  contrast(val, cb) {\n    if (typeof val !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"val must be numbers\", cb);\n    }\n    if (val < -1 || val > +1) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"val must be a number between -1 and +1\", cb);\n    }\n    const factor = (val + 1) / (1 - val);\n    function adjust(value) {\n      value = Math.floor(factor * (value - 127) + 127);\n      return value < 0 ? 0 : value > 255 ? 255 : value;\n    }\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);\n      this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);\n      this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Apply a posterize effect\n   * @param {number} n the amount to adjust the contrast, minimum threshold is two\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  posterize(n, cb) {\n    if (typeof n !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"n must be numbers\", cb);\n    }\n    if (n < 2) {\n      n = 2;\n    } // minimum of 2 levels\n\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;\n      this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;\n      this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Removes colour from the image using ITU Rec 709 luminance values\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  greyscale,\n  // Alias of greyscale for our American friends\n  grayscale: greyscale,\n  /**\n   * Multiplies the opacity of each pixel by a factor between 0 and 1\n   * @param {number} f A number, the factor by which to multiply the opacity of each pixel\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  opacity(f, cb) {\n    if (typeof f !== \"number\") return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"f must be a number\", cb);\n    if (f < 0 || f > 1) return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"f must be a number from 0 to 1\", cb);\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      const v = this.bitmap.data[idx + 3] * f;\n      this.bitmap.data[idx + 3] = v;\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Applies a sepia tone to the image\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  sepia(cb) {\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      let red = this.bitmap.data[idx];\n      let green = this.bitmap.data[idx + 1];\n      let blue = this.bitmap.data[idx + 2];\n      red = red * 0.393 + green * 0.769 + blue * 0.189;\n      green = red * 0.349 + green * 0.686 + blue * 0.168;\n      blue = red * 0.272 + green * 0.534 + blue * 0.131;\n      this.bitmap.data[idx] = red < 255 ? red : 255;\n      this.bitmap.data[idx + 1] = green < 255 ? green : 255;\n      this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Fades each pixel by a factor between 0 and 1\n   * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  fade(f, cb) {\n    if (typeof f !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"f must be a number\", cb);\n    }\n    if (f < 0 || f > 1) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"f must be a number from 0 to 1\", cb);\n    }\n\n    // this method is an alternative to opacity (which may be deprecated)\n    this.opacity(1 - f);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Adds each element of the image to its local neighbors, weighted by the kernel\n   * @param {array} kernel a matrix to weight the neighbors sum\n   * @param {number} edgeHandling (optional) define how to sum pixels from outside the border\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  convolution(kernel, edgeHandling, cb) {\n    if (typeof edgeHandling === \"function\" && typeof cb === \"undefined\") {\n      cb = edgeHandling;\n      edgeHandling = null;\n    }\n    if (!edgeHandling) {\n      edgeHandling = this.constructor.EDGE_EXTEND;\n    }\n    const newData = Buffer.from(this.bitmap.data);\n    const kRows = kernel.length;\n    const kCols = kernel[0].length;\n    const rowEnd = Math.floor(kRows / 2);\n    const colEnd = Math.floor(kCols / 2);\n    const rowIni = -rowEnd;\n    const colIni = -colEnd;\n    let weight;\n    let rSum;\n    let gSum;\n    let bSum;\n    let ri;\n    let gi;\n    let bi;\n    let xi;\n    let yi;\n    let idxi;\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      bSum = 0;\n      gSum = 0;\n      rSum = 0;\n      for (let row = rowIni; row <= rowEnd; row++) {\n        for (let col = colIni; col <= colEnd; col++) {\n          xi = x + col;\n          yi = y + row;\n          weight = kernel[row + rowEnd][col + colEnd];\n          idxi = this.getPixelIndex(xi, yi, edgeHandling);\n          if (idxi === -1) {\n            bi = 0;\n            gi = 0;\n            ri = 0;\n          } else {\n            ri = this.bitmap.data[idxi + 0];\n            gi = this.bitmap.data[idxi + 1];\n            bi = this.bitmap.data[idxi + 2];\n          }\n          rSum += weight * ri;\n          gSum += weight * gi;\n          bSum += weight * bi;\n        }\n      }\n      if (rSum < 0) {\n        rSum = 0;\n      }\n      if (gSum < 0) {\n        gSum = 0;\n      }\n      if (bSum < 0) {\n        bSum = 0;\n      }\n      if (rSum > 255) {\n        rSum = 255;\n      }\n      if (gSum > 255) {\n        gSum = 255;\n      }\n      if (bSum > 255) {\n        bSum = 255;\n      }\n      newData[idx + 0] = rSum;\n      newData[idx + 1] = gSum;\n      newData[idx + 2] = bSum;\n    });\n    this.bitmap.data = newData;\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Set the alpha channel on every pixel to fully opaque\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  opaque(cb) {\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data[idx + 3] = 255;\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Pixelates the image or a region\n   * @param {number} size the size of the pixels\n   * @param {number} x (optional) the x position of the region to pixelate\n   * @param {number} y (optional) the y position of the region to pixelate\n   * @param {number} w (optional) the width of the region to pixelate\n   * @param {number} h (optional) the height of the region to pixelate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  pixelate(size, x, y, w, h, cb) {\n    if (typeof x === \"function\") {\n      cb = x;\n      h = null;\n      w = null;\n      y = null;\n      x = null;\n    } else {\n      if (typeof size !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"size must be a number\", cb);\n      }\n      if (isDef(x) && typeof x !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"x must be a number\", cb);\n      }\n      if (isDef(y) && typeof y !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"y must be a number\", cb);\n      }\n      if (isDef(w) && typeof w !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"w must be a number\", cb);\n      }\n      if (isDef(h) && typeof h !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"h must be a number\", cb);\n      }\n    }\n    const kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];\n    x = x || 0;\n    y = y || 0;\n    w = isDef(w) ? w : this.bitmap.width - x;\n    h = isDef(h) ? h : this.bitmap.height - y;\n    const source = this.cloneQuiet();\n    this.scanQuiet(x, y, w, h, function (xx, yx, idx) {\n      xx = size * Math.floor(xx / size);\n      yx = size * Math.floor(yx / size);\n      const value = applyKernel(source, kernel, xx, yx);\n      this.bitmap.data[idx] = value[0];\n      this.bitmap.data[idx + 1] = value[1];\n      this.bitmap.data[idx + 2] = value[2];\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Applies a convolution kernel to the image or a region\n   * @param {array} kernel the convolution kernel\n   * @param {number} x (optional) the x position of the region to apply convolution to\n   * @param {number} y (optional) the y position of the region to apply convolution to\n   * @param {number} w (optional) the width of the region to apply convolution to\n   * @param {number} h (optional) the height of the region to apply convolution to\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  convolute(kernel, x, y, w, h, cb) {\n    if (!Array.isArray(kernel)) return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"the kernel must be an array\", cb);\n    if (typeof x === \"function\") {\n      cb = x;\n      x = null;\n      y = null;\n      w = null;\n      h = null;\n    } else {\n      if (isDef(x) && typeof x !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"x must be a number\", cb);\n      }\n      if (isDef(y) && typeof y !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"y must be a number\", cb);\n      }\n      if (isDef(w) && typeof w !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"w must be a number\", cb);\n      }\n      if (isDef(h) && typeof h !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"h must be a number\", cb);\n      }\n    }\n    x = isDef(x) ? x : 0;\n    y = isDef(y) ? y : 0;\n    w = isDef(w) ? w : this.bitmap.width - x;\n    h = isDef(h) ? h : this.bitmap.height - y;\n    const source = this.cloneQuiet();\n    this.scanQuiet(x, y, w, h, function (xx, yx, idx) {\n      const value = applyKernel(source, kernel, xx, yx);\n      this.bitmap.data[idx] = this.constructor.limit255(value[0]);\n      this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);\n      this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Apply multiple color modification rules\n   * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp }this for chaining of methods\n   */\n  color: colorFn,\n  colour: colorFn\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY29sb3IvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtQztBQUNxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE1BQU0sMERBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFTO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQVM7QUFDdkI7QUFDQSxpQkFBaUIsbURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxNQUFNLDBEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVCQUF1QjtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0Esc0NBQXNDLG1EQUFVO0FBQ2hELCtCQUErQixtREFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVCQUF1QjtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVCQUF1QjtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsdUNBQXVDLG1EQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLE9BQU8saUVBQWlFO0FBQ3JGLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsRUFBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWNvbG9yL2VzL2luZGV4LmpzPzMyNjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHRpbnlDb2xvciBmcm9tIFwidGlueWNvbG9yMlwiO1xuaW1wb3J0IHsgdGhyb3dFcnJvciwgaXNOb2RlUGF0dGVybiB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuZnVuY3Rpb24gYXBwbHlLZXJuZWwoaW0sIGtlcm5lbCwgeCwgeSkge1xuICBjb25zdCB2YWx1ZSA9IFswLCAwLCAwXTtcbiAgY29uc3Qgc2l6ZSA9IChrZXJuZWwubGVuZ3RoIC0gMSkgLyAyO1xuICBmb3IgKGxldCBreCA9IDA7IGt4IDwga2VybmVsLmxlbmd0aDsga3ggKz0gMSkge1xuICAgIGZvciAobGV0IGt5ID0gMDsga3kgPCBrZXJuZWxba3hdLmxlbmd0aDsga3kgKz0gMSkge1xuICAgICAgY29uc3QgaWR4ID0gaW0uZ2V0UGl4ZWxJbmRleCh4ICsga3ggLSBzaXplLCB5ICsga3kgLSBzaXplKTtcbiAgICAgIHZhbHVlWzBdICs9IGltLmJpdG1hcC5kYXRhW2lkeF0gKiBrZXJuZWxba3hdW2t5XTtcbiAgICAgIHZhbHVlWzFdICs9IGltLmJpdG1hcC5kYXRhW2lkeCArIDFdICoga2VybmVsW2t4XVtreV07XG4gICAgICB2YWx1ZVsyXSArPSBpbS5iaXRtYXAuZGF0YVtpZHggKyAyXSAqIGtlcm5lbFtreF1ba3ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBpc0RlZiA9IHYgPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCIgJiYgdiAhPT0gbnVsbDtcbmZ1bmN0aW9uIGdyZXlzY2FsZShjYikge1xuICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgY29uc3QgZ3JleSA9IHBhcnNlSW50KDAuMjEyNiAqIHRoaXMuYml0bWFwLmRhdGFbaWR4XSArIDAuNzE1MiAqIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gKyAwLjA3MjIgKiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdLCAxMCk7XG4gICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gZ3JleTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gZ3JleTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gZ3JleTtcbiAgfSk7XG4gIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBtaXgoY2xyLCBjbHIyKSB7XG4gIGxldCBwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA1MDtcbiAgcmV0dXJuIHtcbiAgICByOiAoY2xyMi5yIC0gY2xyLnIpICogKHAgLyAxMDApICsgY2xyLnIsXG4gICAgZzogKGNscjIuZyAtIGNsci5nKSAqIChwIC8gMTAwKSArIGNsci5nLFxuICAgIGI6IChjbHIyLmIgLSBjbHIuYikgKiAocCAvIDEwMCkgKyBjbHIuYlxuICB9O1xufVxuZnVuY3Rpb24gY29sb3JGbihhY3Rpb25zLCBjYikge1xuICBpZiAoIWFjdGlvbnMgfHwgIUFycmF5LmlzQXJyYXkoYWN0aW9ucykpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiYWN0aW9ucyBtdXN0IGJlIGFuIGFycmF5XCIsIGNiKTtcbiAgfVxuICBhY3Rpb25zID0gYWN0aW9ucy5tYXAoYWN0aW9uID0+IHtcbiAgICBpZiAoYWN0aW9uLmFwcGx5ID09PSBcInhvclwiIHx8IGFjdGlvbi5hcHBseSA9PT0gXCJtaXhcIikge1xuICAgICAgYWN0aW9uLnBhcmFtc1swXSA9IHRpbnlDb2xvcihhY3Rpb24ucGFyYW1zWzBdKS50b1JnYigpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9KTtcbiAgdGhpcy5zY2FuUXVpZXQoMCwgMCwgdGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgKHgsIHksIGlkeCkgPT4ge1xuICAgIGxldCBjbHIgPSB7XG4gICAgICByOiB0aGlzLmJpdG1hcC5kYXRhW2lkeF0sXG4gICAgICBnOiB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdLFxuICAgICAgYjogdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXVxuICAgIH07XG4gICAgY29uc3QgY29sb3JNb2RpZmllciA9IChpLCBhbW91bnQpID0+IHRoaXMuY29uc3RydWN0b3IubGltaXQyNTUoY2xyW2ldICsgYW1vdW50KTtcbiAgICBhY3Rpb25zLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgIGlmIChhY3Rpb24uYXBwbHkgPT09IFwibWl4XCIpIHtcbiAgICAgICAgY2xyID0gbWl4KGNsciwgYWN0aW9uLnBhcmFtc1swXSwgYWN0aW9uLnBhcmFtc1sxXSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi5hcHBseSA9PT0gXCJ0aW50XCIpIHtcbiAgICAgICAgY2xyID0gbWl4KGNsciwge1xuICAgICAgICAgIHI6IDI1NSxcbiAgICAgICAgICBnOiAyNTUsXG4gICAgICAgICAgYjogMjU1XG4gICAgICAgIH0sIGFjdGlvbi5wYXJhbXNbMF0pO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24uYXBwbHkgPT09IFwic2hhZGVcIikge1xuICAgICAgICBjbHIgPSBtaXgoY2xyLCB7XG4gICAgICAgICAgcjogMCxcbiAgICAgICAgICBnOiAwLFxuICAgICAgICAgIGI6IDBcbiAgICAgICAgfSwgYWN0aW9uLnBhcmFtc1swXSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi5hcHBseSA9PT0gXCJ4b3JcIikge1xuICAgICAgICBjbHIgPSB7XG4gICAgICAgICAgcjogY2xyLnIgXiBhY3Rpb24ucGFyYW1zWzBdLnIsXG4gICAgICAgICAgZzogY2xyLmcgXiBhY3Rpb24ucGFyYW1zWzBdLmcsXG4gICAgICAgICAgYjogY2xyLmIgXiBhY3Rpb24ucGFyYW1zWzBdLmJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLmFwcGx5ID09PSBcInJlZFwiKSB7XG4gICAgICAgIGNsci5yID0gY29sb3JNb2RpZmllcihcInJcIiwgYWN0aW9uLnBhcmFtc1swXSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi5hcHBseSA9PT0gXCJncmVlblwiKSB7XG4gICAgICAgIGNsci5nID0gY29sb3JNb2RpZmllcihcImdcIiwgYWN0aW9uLnBhcmFtc1swXSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi5hcHBseSA9PT0gXCJibHVlXCIpIHtcbiAgICAgICAgY2xyLmIgPSBjb2xvck1vZGlmaWVyKFwiYlwiLCBhY3Rpb24ucGFyYW1zWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhY3Rpb24uYXBwbHkgPT09IFwiaHVlXCIpIHtcbiAgICAgICAgICBhY3Rpb24uYXBwbHkgPSBcInNwaW5cIjtcbiAgICAgICAgfVxuICAgICAgICBjbHIgPSB0aW55Q29sb3IoY2xyKTtcbiAgICAgICAgaWYgKCFjbHJbYWN0aW9uLmFwcGx5XSkge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJhY3Rpb24gXCIgKyBhY3Rpb24uYXBwbHkgKyBcIiBub3Qgc3VwcG9ydGVkXCIsIGNiKTtcbiAgICAgICAgfVxuICAgICAgICBjbHIgPSBjbHJbYWN0aW9uLmFwcGx5XSguLi5hY3Rpb24ucGFyYW1zKS50b1JnYigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4XSA9IGNsci5yO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSBjbHIuZztcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gY2xyLmI7XG4gIH0pO1xuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZXhwb3J0IGNvbnN0IENvbG9yQWN0aW9uTmFtZSA9IE9iamVjdC5mcmVlemUoe1xuICBMSUdIVEVOOiBcImxpZ2h0ZW5cIixcbiAgQlJJR0hURU46IFwiYnJpZ2h0ZW5cIixcbiAgREFSS0VOOiBcImRhcmtlblwiLFxuICBERVNBVFVSQVRFOiBcImRlc2F0dXJhdGVcIixcbiAgU0FUVVJBVEU6IFwic2F0dXJhdGVcIixcbiAgR1JFWVNDQUxFOiBcImdyZXlzY2FsZVwiLFxuICBTUElOOiBcInNwaW5cIixcbiAgSFVFOiBcImh1ZVwiLFxuICBNSVg6IFwibWl4XCIsXG4gIFRJTlQ6IFwidGludFwiLFxuICBTSEFERTogXCJzaGFkZVwiLFxuICBYT1I6IFwieG9yXCIsXG4gIFJFRDogXCJyZWRcIixcbiAgR1JFRU46IFwiZ3JlZW5cIixcbiAgQkxVRTogXCJibHVlXCJcbn0pO1xuZXhwb3J0IGRlZmF1bHQgKCgpID0+ICh7XG4gIC8qKlxuICAgKiBBZGp1c3RzIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIHRoZSBhbW91bnQgdG8gYWRqdXN0IHRoZSBicmlnaHRuZXNzLCBhIG51bWJlciBiZXR3ZWVuIC0xIGFuZCArMVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAqL1xuICBicmlnaHRuZXNzKHZhbCwgY2IpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInZhbCBtdXN0IGJlIG51bWJlcnNcIiwgY2IpO1xuICAgIH1cbiAgICBpZiAodmFsIDwgLTEgfHwgdmFsID4gKzEpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ2YWwgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIC0xIGFuZCArMVwiLCBjYik7XG4gICAgfVxuICAgIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgIGlmICh2YWwgPCAwLjApIHtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdICo9IDEgKyB2YWw7XG4gICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gKj0gMSArIHZhbDtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSAqPSAxICsgdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdICs9ICgyNTUgLSB0aGlzLmJpdG1hcC5kYXRhW2lkeF0pICogdmFsO1xuICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdICs9ICgyNTUgLSB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdKSAqIHZhbDtcbiAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSArPSAoMjU1IC0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSkgKiB2YWw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIEFkanVzdHMgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIHRoZSBhbW91bnQgdG8gYWRqdXN0IHRoZSBjb250cmFzdCwgYSBudW1iZXIgYmV0d2VlbiAtMSBhbmQgKzFcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgKi9cbiAgY29udHJhc3QodmFsLCBjYikge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwidmFsIG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gICAgfVxuICAgIGlmICh2YWwgPCAtMSB8fCB2YWwgPiArMSkge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInZhbCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kICsxXCIsIGNiKTtcbiAgICB9XG4gICAgY29uc3QgZmFjdG9yID0gKHZhbCArIDEpIC8gKDEgLSB2YWwpO1xuICAgIGZ1bmN0aW9uIGFkanVzdCh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKGZhY3RvciAqICh2YWx1ZSAtIDEyNykgKyAxMjcpO1xuICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IDAgOiB2YWx1ZSA+IDI1NSA/IDI1NSA6IHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSBhZGp1c3QodGhpcy5iaXRtYXAuZGF0YVtpZHhdKTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSBhZGp1c3QodGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSk7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gYWRqdXN0KHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0pO1xuICAgIH0pO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBBcHBseSBhIHBvc3Rlcml6ZSBlZmZlY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gdGhlIGFtb3VudCB0byBhZGp1c3QgdGhlIGNvbnRyYXN0LCBtaW5pbXVtIHRocmVzaG9sZCBpcyB0d29cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgKi9cbiAgcG9zdGVyaXplKG4sIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBuICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwibiBtdXN0IGJlIG51bWJlcnNcIiwgY2IpO1xuICAgIH1cbiAgICBpZiAobiA8IDIpIHtcbiAgICAgIG4gPSAyO1xuICAgIH0gLy8gbWluaW11bSBvZiAyIGxldmVsc1xuXG4gICAgdGhpcy5zY2FuUXVpZXQoMCwgMCwgdGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHgsIHksIGlkeCkge1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gTWF0aC5mbG9vcih0aGlzLmJpdG1hcC5kYXRhW2lkeF0gLyAyNTUgKiAobiAtIDEpKSAvIChuIC0gMSkgKiAyNTU7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gTWF0aC5mbG9vcih0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdIC8gMjU1ICogKG4gLSAxKSkgLyAobiAtIDEpICogMjU1O1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IE1hdGguZmxvb3IodGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSAvIDI1NSAqIChuIC0gMSkpIC8gKG4gLSAxKSAqIDI1NTtcbiAgICB9KTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogUmVtb3ZlcyBjb2xvdXIgZnJvbSB0aGUgaW1hZ2UgdXNpbmcgSVRVIFJlYyA3MDkgbHVtaW5hbmNlIHZhbHVlc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAqL1xuICBncmV5c2NhbGUsXG4gIC8vIEFsaWFzIG9mIGdyZXlzY2FsZSBmb3Igb3VyIEFtZXJpY2FuIGZyaWVuZHNcbiAgZ3JheXNjYWxlOiBncmV5c2NhbGUsXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoZSBvcGFjaXR5IG9mIGVhY2ggcGl4ZWwgYnkgYSBmYWN0b3IgYmV0d2VlbiAwIGFuZCAxXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmIEEgbnVtYmVyLCB0aGUgZmFjdG9yIGJ5IHdoaWNoIHRvIG11bHRpcGx5IHRoZSBvcGFjaXR5IG9mIGVhY2ggcGl4ZWxcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgKi9cbiAgb3BhY2l0eShmLCBjYikge1xuICAgIGlmICh0eXBlb2YgZiAhPT0gXCJudW1iZXJcIikgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImYgbXVzdCBiZSBhIG51bWJlclwiLCBjYik7XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAxKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiZiBtdXN0IGJlIGEgbnVtYmVyIGZyb20gMCB0byAxXCIsIGNiKTtcbiAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICBjb25zdCB2ID0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAzXSAqIGY7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdID0gdjtcbiAgICB9KTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogQXBwbGllcyBhIHNlcGlhIHRvbmUgdG8gdGhlIGltYWdlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge0ppbXAgfXRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIHNlcGlhKGNiKSB7XG4gICAgdGhpcy5zY2FuUXVpZXQoMCwgMCwgdGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHgsIHksIGlkeCkge1xuICAgICAgbGV0IHJlZCA9IHRoaXMuYml0bWFwLmRhdGFbaWR4XTtcbiAgICAgIGxldCBncmVlbiA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV07XG4gICAgICBsZXQgYmx1ZSA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl07XG4gICAgICByZWQgPSByZWQgKiAwLjM5MyArIGdyZWVuICogMC43NjkgKyBibHVlICogMC4xODk7XG4gICAgICBncmVlbiA9IHJlZCAqIDAuMzQ5ICsgZ3JlZW4gKiAwLjY4NiArIGJsdWUgKiAwLjE2ODtcbiAgICAgIGJsdWUgPSByZWQgKiAwLjI3MiArIGdyZWVuICogMC41MzQgKyBibHVlICogMC4xMzE7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSByZWQgPCAyNTUgPyByZWQgOiAyNTU7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gZ3JlZW4gPCAyNTUgPyBncmVlbiA6IDI1NTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSBibHVlIDwgMjU1ID8gYmx1ZSA6IDI1NTtcbiAgICB9KTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogRmFkZXMgZWFjaCBwaXhlbCBieSBhIGZhY3RvciBiZXR3ZWVuIDAgYW5kIDFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGYgQSBudW1iZXIgZnJvbSAwIHRvIDEuIDAgd2lsbCBoYXZlbiBubyBlZmZlY3QuIDEgd2lsbCB0dXJuIHRoZSBpbWFnZSBjb21wbGV0ZWx5IHRyYW5zcGFyZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAqL1xuICBmYWRlKGYsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBmICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiZiBtdXN0IGJlIGEgbnVtYmVyXCIsIGNiKTtcbiAgICB9XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAxKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiZiBtdXN0IGJlIGEgbnVtYmVyIGZyb20gMCB0byAxXCIsIGNiKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIG1ldGhvZCBpcyBhbiBhbHRlcm5hdGl2ZSB0byBvcGFjaXR5ICh3aGljaCBtYXkgYmUgZGVwcmVjYXRlZClcbiAgICB0aGlzLm9wYWNpdHkoMSAtIGYpO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBBZGRzIGVhY2ggZWxlbWVudCBvZiB0aGUgaW1hZ2UgdG8gaXRzIGxvY2FsIG5laWdoYm9ycywgd2VpZ2h0ZWQgYnkgdGhlIGtlcm5lbFxuICAgKiBAcGFyYW0ge2FycmF5fSBrZXJuZWwgYSBtYXRyaXggdG8gd2VpZ2h0IHRoZSBuZWlnaGJvcnMgc3VtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlSGFuZGxpbmcgKG9wdGlvbmFsKSBkZWZpbmUgaG93IHRvIHN1bSBwaXhlbHMgZnJvbSBvdXRzaWRlIHRoZSBib3JkZXJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgKi9cbiAgY29udm9sdXRpb24oa2VybmVsLCBlZGdlSGFuZGxpbmcsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBlZGdlSGFuZGxpbmcgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNiID0gZWRnZUhhbmRsaW5nO1xuICAgICAgZWRnZUhhbmRsaW5nID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFlZGdlSGFuZGxpbmcpIHtcbiAgICAgIGVkZ2VIYW5kbGluZyA9IHRoaXMuY29uc3RydWN0b3IuRURHRV9FWFRFTkQ7XG4gICAgfVxuICAgIGNvbnN0IG5ld0RhdGEgPSBCdWZmZXIuZnJvbSh0aGlzLmJpdG1hcC5kYXRhKTtcbiAgICBjb25zdCBrUm93cyA9IGtlcm5lbC5sZW5ndGg7XG4gICAgY29uc3Qga0NvbHMgPSBrZXJuZWxbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IHJvd0VuZCA9IE1hdGguZmxvb3Ioa1Jvd3MgLyAyKTtcbiAgICBjb25zdCBjb2xFbmQgPSBNYXRoLmZsb29yKGtDb2xzIC8gMik7XG4gICAgY29uc3Qgcm93SW5pID0gLXJvd0VuZDtcbiAgICBjb25zdCBjb2xJbmkgPSAtY29sRW5kO1xuICAgIGxldCB3ZWlnaHQ7XG4gICAgbGV0IHJTdW07XG4gICAgbGV0IGdTdW07XG4gICAgbGV0IGJTdW07XG4gICAgbGV0IHJpO1xuICAgIGxldCBnaTtcbiAgICBsZXQgYmk7XG4gICAgbGV0IHhpO1xuICAgIGxldCB5aTtcbiAgICBsZXQgaWR4aTtcbiAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICBiU3VtID0gMDtcbiAgICAgIGdTdW0gPSAwO1xuICAgICAgclN1bSA9IDA7XG4gICAgICBmb3IgKGxldCByb3cgPSByb3dJbmk7IHJvdyA8PSByb3dFbmQ7IHJvdysrKSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IGNvbEluaTsgY29sIDw9IGNvbEVuZDsgY29sKyspIHtcbiAgICAgICAgICB4aSA9IHggKyBjb2w7XG4gICAgICAgICAgeWkgPSB5ICsgcm93O1xuICAgICAgICAgIHdlaWdodCA9IGtlcm5lbFtyb3cgKyByb3dFbmRdW2NvbCArIGNvbEVuZF07XG4gICAgICAgICAgaWR4aSA9IHRoaXMuZ2V0UGl4ZWxJbmRleCh4aSwgeWksIGVkZ2VIYW5kbGluZyk7XG4gICAgICAgICAgaWYgKGlkeGkgPT09IC0xKSB7XG4gICAgICAgICAgICBiaSA9IDA7XG4gICAgICAgICAgICBnaSA9IDA7XG4gICAgICAgICAgICByaSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJpID0gdGhpcy5iaXRtYXAuZGF0YVtpZHhpICsgMF07XG4gICAgICAgICAgICBnaSA9IHRoaXMuYml0bWFwLmRhdGFbaWR4aSArIDFdO1xuICAgICAgICAgICAgYmkgPSB0aGlzLmJpdG1hcC5kYXRhW2lkeGkgKyAyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgclN1bSArPSB3ZWlnaHQgKiByaTtcbiAgICAgICAgICBnU3VtICs9IHdlaWdodCAqIGdpO1xuICAgICAgICAgIGJTdW0gKz0gd2VpZ2h0ICogYmk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyU3VtIDwgMCkge1xuICAgICAgICByU3VtID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChnU3VtIDwgMCkge1xuICAgICAgICBnU3VtID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChiU3VtIDwgMCkge1xuICAgICAgICBiU3VtID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChyU3VtID4gMjU1KSB7XG4gICAgICAgIHJTdW0gPSAyNTU7XG4gICAgICB9XG4gICAgICBpZiAoZ1N1bSA+IDI1NSkge1xuICAgICAgICBnU3VtID0gMjU1O1xuICAgICAgfVxuICAgICAgaWYgKGJTdW0gPiAyNTUpIHtcbiAgICAgICAgYlN1bSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbaWR4ICsgMF0gPSByU3VtO1xuICAgICAgbmV3RGF0YVtpZHggKyAxXSA9IGdTdW07XG4gICAgICBuZXdEYXRhW2lkeCArIDJdID0gYlN1bTtcbiAgICB9KTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhID0gbmV3RGF0YTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogU2V0IHRoZSBhbHBoYSBjaGFubmVsIG9uIGV2ZXJ5IHBpeGVsIHRvIGZ1bGx5IG9wYXF1ZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAqIEByZXR1cm5zIHtKaW1wIH10aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAqL1xuICBvcGFxdWUoY2IpIHtcbiAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdID0gMjU1O1xuICAgIH0pO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBQaXhlbGF0ZXMgdGhlIGltYWdlIG9yIGEgcmVnaW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBzaXplIG9mIHRoZSBwaXhlbHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggKG9wdGlvbmFsKSB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVnaW9uIHRvIHBpeGVsYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IChvcHRpb25hbCkgdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlZ2lvbiB0byBwaXhlbGF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdyAob3B0aW9uYWwpIHRoZSB3aWR0aCBvZiB0aGUgcmVnaW9uIHRvIHBpeGVsYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIChvcHRpb25hbCkgdGhlIGhlaWdodCBvZiB0aGUgcmVnaW9uIHRvIHBpeGVsYXRlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge0ppbXAgfXRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIHBpeGVsYXRlKHNpemUsIHgsIHksIHcsIGgsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNiID0geDtcbiAgICAgIGggPSBudWxsO1xuICAgICAgdyA9IG51bGw7XG4gICAgICB5ID0gbnVsbDtcbiAgICAgIHggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHNpemUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInNpemUgbXVzdCBiZSBhIG51bWJlclwiLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoeCkgJiYgdHlwZW9mIHggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInggbXVzdCBiZSBhIG51bWJlclwiLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoeSkgJiYgdHlwZW9mIHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInkgbXVzdCBiZSBhIG51bWJlclwiLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYodykgJiYgdHlwZW9mIHcgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIncgbXVzdCBiZSBhIG51bWJlclwiLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaCkgJiYgdHlwZW9mIGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImggbXVzdCBiZSBhIG51bWJlclwiLCBjYik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IFtbMSAvIDE2LCAyIC8gMTYsIDEgLyAxNl0sIFsyIC8gMTYsIDQgLyAxNiwgMiAvIDE2XSwgWzEgLyAxNiwgMiAvIDE2LCAxIC8gMTZdXTtcbiAgICB4ID0geCB8fCAwO1xuICAgIHkgPSB5IHx8IDA7XG4gICAgdyA9IGlzRGVmKHcpID8gdyA6IHRoaXMuYml0bWFwLndpZHRoIC0geDtcbiAgICBoID0gaXNEZWYoaCkgPyBoIDogdGhpcy5iaXRtYXAuaGVpZ2h0IC0geTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmNsb25lUXVpZXQoKTtcbiAgICB0aGlzLnNjYW5RdWlldCh4LCB5LCB3LCBoLCBmdW5jdGlvbiAoeHgsIHl4LCBpZHgpIHtcbiAgICAgIHh4ID0gc2l6ZSAqIE1hdGguZmxvb3IoeHggLyBzaXplKTtcbiAgICAgIHl4ID0gc2l6ZSAqIE1hdGguZmxvb3IoeXggLyBzaXplKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXBwbHlLZXJuZWwoc291cmNlLCBrZXJuZWwsIHh4LCB5eCk7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSB2YWx1ZVswXTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSB2YWx1ZVsxXTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSB2YWx1ZVsyXTtcbiAgICB9KTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogQXBwbGllcyBhIGNvbnZvbHV0aW9uIGtlcm5lbCB0byB0aGUgaW1hZ2Ugb3IgYSByZWdpb25cbiAgICogQHBhcmFtIHthcnJheX0ga2VybmVsIHRoZSBjb252b2x1dGlvbiBrZXJuZWxcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggKG9wdGlvbmFsKSB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVnaW9uIHRvIGFwcGx5IGNvbnZvbHV0aW9uIHRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IChvcHRpb25hbCkgdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlZ2lvbiB0byBhcHBseSBjb252b2x1dGlvbiB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gdyAob3B0aW9uYWwpIHRoZSB3aWR0aCBvZiB0aGUgcmVnaW9uIHRvIGFwcGx5IGNvbnZvbHV0aW9uIHRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIChvcHRpb25hbCkgdGhlIGhlaWdodCBvZiB0aGUgcmVnaW9uIHRvIGFwcGx5IGNvbnZvbHV0aW9uIHRvXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIGNvbnZvbHV0ZShrZXJuZWwsIHgsIHksIHcsIGgsIGNiKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGtlcm5lbCkpIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ0aGUga2VybmVsIG11c3QgYmUgYW4gYXJyYXlcIiwgY2IpO1xuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYiA9IHg7XG4gICAgICB4ID0gbnVsbDtcbiAgICAgIHkgPSBudWxsO1xuICAgICAgdyA9IG51bGw7XG4gICAgICBoID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmKHgpICYmIHR5cGVvZiB4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ4IG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKHkpICYmIHR5cGVvZiB5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ5IG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKHcpICYmIHR5cGVvZiB3ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ3IG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGgpICYmIHR5cGVvZiBoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJoIG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgICAgfVxuICAgIH1cbiAgICB4ID0gaXNEZWYoeCkgPyB4IDogMDtcbiAgICB5ID0gaXNEZWYoeSkgPyB5IDogMDtcbiAgICB3ID0gaXNEZWYodykgPyB3IDogdGhpcy5iaXRtYXAud2lkdGggLSB4O1xuICAgIGggPSBpc0RlZihoKSA/IGggOiB0aGlzLmJpdG1hcC5oZWlnaHQgLSB5O1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuY2xvbmVRdWlldCgpO1xuICAgIHRoaXMuc2NhblF1aWV0KHgsIHksIHcsIGgsIGZ1bmN0aW9uICh4eCwgeXgsIGlkeCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhcHBseUtlcm5lbChzb3VyY2UsIGtlcm5lbCwgeHgsIHl4KTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4XSA9IHRoaXMuY29uc3RydWN0b3IubGltaXQyNTUodmFsdWVbMF0pO1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IHRoaXMuY29uc3RydWN0b3IubGltaXQyNTUodmFsdWVbMV0pO1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IHRoaXMuY29uc3RydWN0b3IubGltaXQyNTUodmFsdWVbMl0pO1xuICAgIH0pO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBBcHBseSBtdWx0aXBsZSBjb2xvciBtb2RpZmljYXRpb24gcnVsZXNcbiAgICogQHBhcmFtIHthcnJheX0gYWN0aW9ucyBsaXN0IG9mIGNvbG9yIG1vZGlmaWNhdGlvbiBydWxlcywgaW4gZm9sbG93aW5nIGZvcm1hdDogeyBhcHBseTogJzxydWxlLW5hbWU+JywgcGFyYW1zOiBbIDxydWxlLXBhcmFtZXRlcnM+IF0gIH1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgKiBAcmV0dXJucyB7SmltcCB9dGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgKi9cbiAgY29sb3I6IGNvbG9yRm4sXG4gIGNvbG91cjogY29sb3JGblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-color/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-contain/es/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jimp/plugin-contain/es/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  contain(w, h, alignBits, mode, cb) {\n    if (typeof w !== \"number\" || typeof h !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"w and h must be numbers\", cb);\n    }\n\n    // permit any sort of optional parameters combination\n    if (typeof alignBits === \"string\") {\n      if (typeof mode === \"function\" && typeof cb === \"undefined\") cb = mode;\n      mode = alignBits;\n      alignBits = null;\n    }\n    if (typeof alignBits === \"function\") {\n      if (typeof cb === \"undefined\") cb = alignBits;\n      mode = null;\n      alignBits = null;\n    }\n    if (typeof mode === \"function\" && typeof cb === \"undefined\") {\n      cb = mode;\n      mode = null;\n    }\n    alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;\n    const hbits = alignBits & (1 << 3) - 1;\n    const vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"only use one flag per alignment direction\", cb);\n    }\n    const alignH = hbits >> 1; // 0, 1, 2\n    const alignV = vbits >> 1; // 0, 1, 2\n\n    const f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;\n    const c = this.cloneQuiet().scale(f, mode);\n    this.resize(w, h, mode);\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY29udGFpbi9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDs7QUFFeEQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLE1BQU07QUFDbkI7QUFDQSxpRUFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsRUFBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWNvbnRhaW4vZXMvaW5kZXguanM/YjhiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5cbi8qKlxuICogU2NhbGUgdGhlIGltYWdlIHRvIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0IGtlZXBpbmcgdGhlIGFzcGVjdCByYXRpby4gU29tZSBwYXJ0cyBvZiB0aGUgaW1hZ2UgbWF5IGJlIGxldHRlciBib3hlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3IHRoZSB3aWR0aCB0byByZXNpemUgdGhlIGltYWdlIHRvXG4gKiBAcGFyYW0ge251bWJlcn0gaCB0aGUgaGVpZ2h0IHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbGlnbkJpdHMgKG9wdGlvbmFsKSBBIGJpdG1hc2sgZm9yIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGFsaWdubWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgKG9wdGlvbmFsKSBhIHNjYWxpbmcgbWV0aG9kIChlLmcuIEppbXAuUkVTSVpFX0JFWklFUilcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiAoe1xuICBjb250YWluKHcsIGgsIGFsaWduQml0cywgbW9kZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIHcgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ3IGFuZCBoIG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gICAgfVxuXG4gICAgLy8gcGVybWl0IGFueSBzb3J0IG9mIG9wdGlvbmFsIHBhcmFtZXRlcnMgY29tYmluYXRpb25cbiAgICBpZiAodHlwZW9mIGFsaWduQml0cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHR5cGVvZiBtb2RlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNiID09PSBcInVuZGVmaW5lZFwiKSBjYiA9IG1vZGU7XG4gICAgICBtb2RlID0gYWxpZ25CaXRzO1xuICAgICAgYWxpZ25CaXRzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbGlnbkJpdHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJ1bmRlZmluZWRcIikgY2IgPSBhbGlnbkJpdHM7XG4gICAgICBtb2RlID0gbnVsbDtcbiAgICAgIGFsaWduQml0cyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2IgPSBtb2RlO1xuICAgICAgbW9kZSA9IG51bGw7XG4gICAgfVxuICAgIGFsaWduQml0cyA9IGFsaWduQml0cyB8fCB0aGlzLmNvbnN0cnVjdG9yLkhPUklaT05UQUxfQUxJR05fQ0VOVEVSIHwgdGhpcy5jb25zdHJ1Y3Rvci5WRVJUSUNBTF9BTElHTl9NSURETEU7XG4gICAgY29uc3QgaGJpdHMgPSBhbGlnbkJpdHMgJiAoMSA8PCAzKSAtIDE7XG4gICAgY29uc3QgdmJpdHMgPSBhbGlnbkJpdHMgPj4gMztcblxuICAgIC8vIGNoZWNrIGlmIG1vcmUgZmxhZ3MgdGhhbiBvbmUgaXMgaW4gdGhlIGJpdCBzZXRzXG4gICAgaWYgKCEoaGJpdHMgIT09IDAgJiYgIShoYml0cyAmIGhiaXRzIC0gMSkgfHwgdmJpdHMgIT09IDAgJiYgISh2Yml0cyAmIHZiaXRzIC0gMSkpKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwib25seSB1c2Ugb25lIGZsYWcgcGVyIGFsaWdubWVudCBkaXJlY3Rpb25cIiwgY2IpO1xuICAgIH1cbiAgICBjb25zdCBhbGlnbkggPSBoYml0cyA+PiAxOyAvLyAwLCAxLCAyXG4gICAgY29uc3QgYWxpZ25WID0gdmJpdHMgPj4gMTsgLy8gMCwgMSwgMlxuXG4gICAgY29uc3QgZiA9IHcgLyBoID4gdGhpcy5iaXRtYXAud2lkdGggLyB0aGlzLmJpdG1hcC5oZWlnaHQgPyBoIC8gdGhpcy5iaXRtYXAuaGVpZ2h0IDogdyAvIHRoaXMuYml0bWFwLndpZHRoO1xuICAgIGNvbnN0IGMgPSB0aGlzLmNsb25lUXVpZXQoKS5zY2FsZShmLCBtb2RlKTtcbiAgICB0aGlzLnJlc2l6ZSh3LCBoLCBtb2RlKTtcbiAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhLndyaXRlVUludDMyQkUodGhpcy5fYmFja2dyb3VuZCwgaWR4KTtcbiAgICB9KTtcbiAgICB0aGlzLmJsaXQoYywgKHRoaXMuYml0bWFwLndpZHRoIC0gYy5iaXRtYXAud2lkdGgpIC8gMiAqIGFsaWduSCwgKHRoaXMuYml0bWFwLmhlaWdodCAtIGMuYml0bWFwLmhlaWdodCkgLyAyICogYWxpZ25WKTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-contain/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-cover/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/plugin-cover/es/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.\n * @param {number} w the width to resize the image to\n * @param {number} h the height to resize the image to\n * @param {number} alignBits (optional) A bitmask for horizontal and vertical alignment\n * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  cover(w, h, alignBits, mode, cb) {\n    if (typeof w !== \"number\" || typeof h !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"w and h must be numbers\", cb);\n    }\n    if (alignBits && typeof alignBits === \"function\" && typeof cb === \"undefined\") {\n      cb = alignBits;\n      alignBits = null;\n      mode = null;\n    } else if (typeof mode === \"function\" && typeof cb === \"undefined\") {\n      cb = mode;\n      mode = null;\n    }\n    alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;\n    const hbits = alignBits & (1 << 3) - 1;\n    const vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"only use one flag per alignment direction\", cb);\n    const alignH = hbits >> 1; // 0, 1, 2\n    const alignV = vbits >> 1; // 0, 1, 2\n\n    const f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;\n    this.scale(f, mode);\n    this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY292ZXIvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0Q7O0FBRXhEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEZBQThGLG1EQUFVO0FBQ3hHLCtCQUErQjtBQUMvQiwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsRUFBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWNvdmVyL2VzL2luZGV4LmpzPzkzOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiwgdGhyb3dFcnJvciB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuXG4vKipcbiAqIFNjYWxlIHRoZSBpbWFnZSBzbyB0aGUgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodCBrZWVwaW5nIHRoZSBhc3BlY3QgcmF0aW8uIFNvbWUgcGFydHMgb2YgdGhlIGltYWdlIG1heSBiZSBjbGlwcGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHcgdGhlIHdpZHRoIHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBoIHRoZSBoZWlnaHQgdG8gcmVzaXplIHRoZSBpbWFnZSB0b1xuICogQHBhcmFtIHtudW1iZXJ9IGFsaWduQml0cyAob3B0aW9uYWwpIEEgYml0bWFzayBmb3IgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYWxpZ25tZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAob3B0aW9uYWwpIGEgc2NhbGluZyBtZXRob2QgKGUuZy4gSmltcC5SRVNJWkVfQkVaSUVSKVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgKCgpID0+ICh7XG4gIGNvdmVyKHcsIGgsIGFsaWduQml0cywgbW9kZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIHcgIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ3IGFuZCBoIG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gICAgfVxuICAgIGlmIChhbGlnbkJpdHMgJiYgdHlwZW9mIGFsaWduQml0cyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2IgPSBhbGlnbkJpdHM7XG4gICAgICBhbGlnbkJpdHMgPSBudWxsO1xuICAgICAgbW9kZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2IgPSBtb2RlO1xuICAgICAgbW9kZSA9IG51bGw7XG4gICAgfVxuICAgIGFsaWduQml0cyA9IGFsaWduQml0cyB8fCB0aGlzLmNvbnN0cnVjdG9yLkhPUklaT05UQUxfQUxJR05fQ0VOVEVSIHwgdGhpcy5jb25zdHJ1Y3Rvci5WRVJUSUNBTF9BTElHTl9NSURETEU7XG4gICAgY29uc3QgaGJpdHMgPSBhbGlnbkJpdHMgJiAoMSA8PCAzKSAtIDE7XG4gICAgY29uc3QgdmJpdHMgPSBhbGlnbkJpdHMgPj4gMztcblxuICAgIC8vIGNoZWNrIGlmIG1vcmUgZmxhZ3MgdGhhbiBvbmUgaXMgaW4gdGhlIGJpdCBzZXRzXG4gICAgaWYgKCEoaGJpdHMgIT09IDAgJiYgIShoYml0cyAmIGhiaXRzIC0gMSkgfHwgdmJpdHMgIT09IDAgJiYgISh2Yml0cyAmIHZiaXRzIC0gMSkpKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwib25seSB1c2Ugb25lIGZsYWcgcGVyIGFsaWdubWVudCBkaXJlY3Rpb25cIiwgY2IpO1xuICAgIGNvbnN0IGFsaWduSCA9IGhiaXRzID4+IDE7IC8vIDAsIDEsIDJcbiAgICBjb25zdCBhbGlnblYgPSB2Yml0cyA+PiAxOyAvLyAwLCAxLCAyXG5cbiAgICBjb25zdCBmID0gdyAvIGggPiB0aGlzLmJpdG1hcC53aWR0aCAvIHRoaXMuYml0bWFwLmhlaWdodCA/IHcgLyB0aGlzLmJpdG1hcC53aWR0aCA6IGggLyB0aGlzLmJpdG1hcC5oZWlnaHQ7XG4gICAgdGhpcy5zY2FsZShmLCBtb2RlKTtcbiAgICB0aGlzLmNyb3AoKHRoaXMuYml0bWFwLndpZHRoIC0gdykgLyAyICogYWxpZ25ILCAodGhpcy5iaXRtYXAuaGVpZ2h0IC0gaCkgLyAyICogYWxpZ25WLCB3LCBoKTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-cover/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-crop/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-crop/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ pluginCrop)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n/* eslint-disable no-labels */\n\n\nfunction pluginCrop(event) {\n  /**\n   * Crops the image at a given point to a give size\n   * @param {number} x the x coordinate to crop form\n   * @param {number} y the y coordinate to crop form\n   * @param w the width of the crop region\n   * @param h the height of the crop region\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  event(\"crop\", function (x, y, w, h, cb) {\n    if (typeof x !== \"number\" || typeof y !== \"number\") return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"x and y must be numbers\", cb);\n    if (typeof w !== \"number\" || typeof h !== \"number\") return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"w and h must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n    if (x === 0 && w === this.bitmap.width) {\n      // shortcut\n      const start = w * y + x << 2;\n      const end = start + (h * w << 2);\n      this.bitmap.data = this.bitmap.data.slice(start, end);\n    } else {\n      const bitmap = Buffer.allocUnsafe(w * h * 4);\n      let offset = 0;\n      this.scanQuiet(x, y, w, h, function (x, y, idx) {\n        const data = this.bitmap.data.readUInt32BE(idx, true);\n        bitmap.writeUInt32BE(data, offset, true);\n        offset += 4;\n      });\n      this.bitmap.data = bitmap;\n    }\n    this.bitmap.width = w;\n    this.bitmap.height = h;\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  });\n  return {\n    class: {\n      /**\n       * Autocrop same color borders from this image\n       * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)\n       * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)\n       * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)\n       * @returns {Jimp} this for chaining of methods\n       */\n      autocrop() {\n        const w = this.bitmap.width;\n        const h = this.bitmap.height;\n        const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n\n        let cb; // callback\n        let leaveBorder = 0; // Amount of pixels in border to leave\n        let tolerance = 0.0002; // percent of color difference tolerance (default value)\n        let cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n        // i.e. all 4 sides have some border (default value)\n        let cropSymmetric = false; // flag to force cropping top be symmetric.\n        // i.e. north and south / east and west are cropped by the same value\n        let ignoreSides = {\n          north: false,\n          south: false,\n          east: false,\n          west: false\n        };\n\n        // parse arguments\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        for (let a = 0, len = args.length; a < len; a++) {\n          if (typeof args[a] === \"number\") {\n            // tolerance value passed\n            tolerance = args[a];\n          }\n          if (typeof args[a] === \"boolean\") {\n            // cropOnlyFrames value passed\n            cropOnlyFrames = args[a];\n          }\n          if (typeof args[a] === \"function\") {\n            // callback value passed\n            cb = args[a];\n          }\n          if (typeof args[a] === \"object\") {\n            // config object passed\n            const config = args[a];\n            if (typeof config.tolerance !== \"undefined\") {\n              ({\n                tolerance\n              } = config);\n            }\n            if (typeof config.cropOnlyFrames !== \"undefined\") {\n              ({\n                cropOnlyFrames\n              } = config);\n            }\n            if (typeof config.cropSymmetric !== \"undefined\") {\n              ({\n                cropSymmetric\n              } = config);\n            }\n            if (typeof config.leaveBorder !== \"undefined\") {\n              ({\n                leaveBorder\n              } = config);\n            }\n            if (typeof config.ignoreSides !== \"undefined\") {\n              ({\n                ignoreSides\n              } = config);\n            }\n          }\n        }\n\n        /**\n         * All borders must be of the same color as the top left pixel, to be cropped.\n         * It should be possible to crop borders each with a different color,\n         * but since there are many ways for corners to intersect, it would\n         * introduce unnecessary complexity to the algorithm.\n         */\n\n        // scan each side for same color borders\n        let colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n        const rgba1 = this.constructor.intToRGBA(colorTarget);\n\n        // for north and east sides\n        let northPixelsToCrop = 0;\n        let eastPixelsToCrop = 0;\n        let southPixelsToCrop = 0;\n        let westPixelsToCrop = 0;\n\n        // north side (scan rows from north to south)\n        colorTarget = this.getPixelColor(0, 0);\n        if (!ignoreSides.north) {\n          north: for (let y = 0; y < h - minPixelsPerSide; y++) {\n            for (let x = 0; x < w; x++) {\n              const colorXY = this.getPixelColor(x, y);\n              const rgba2 = this.constructor.intToRGBA(colorXY);\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break north;\n              }\n            }\n\n            // this row contains all pixels with the same color: increment this side pixels to crop\n            northPixelsToCrop++;\n          }\n        }\n\n        // west side (scan columns from west to east)\n        colorTarget = this.getPixelColor(w, 0);\n        if (!ignoreSides.west) {\n          west: for (let x = 0; x < w - minPixelsPerSide; x++) {\n            for (let y = 0 + northPixelsToCrop; y < h; y++) {\n              const colorXY = this.getPixelColor(x, y);\n              const rgba2 = this.constructor.intToRGBA(colorXY);\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break west;\n              }\n            }\n\n            // this column contains all pixels with the same color: increment this side pixels to crop\n            westPixelsToCrop++;\n          }\n        }\n\n        // south side (scan rows from south to north)\n        colorTarget = this.getPixelColor(0, h);\n        if (!ignoreSides.south) {\n          south: for (let y = h - 1; y >= northPixelsToCrop + minPixelsPerSide; y--) {\n            for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {\n              const colorXY = this.getPixelColor(x, y);\n              const rgba2 = this.constructor.intToRGBA(colorXY);\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break south;\n              }\n            }\n\n            // this row contains all pixels with the same color: increment this side pixels to crop\n            southPixelsToCrop++;\n          }\n        }\n\n        // east side (scan columns from east to west)\n        colorTarget = this.getPixelColor(w, h);\n        if (!ignoreSides.east) {\n          east: for (let x = w - 1; x >= 0 + westPixelsToCrop + minPixelsPerSide; x--) {\n            for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {\n              const colorXY = this.getPixelColor(x, y);\n              const rgba2 = this.constructor.intToRGBA(colorXY);\n              if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break east;\n              }\n            }\n\n            // this column contains all pixels with the same color: increment this side pixels to crop\n            eastPixelsToCrop++;\n          }\n        }\n\n        // decide if a crop is needed\n        let doCrop = false;\n\n        // apply leaveBorder\n        westPixelsToCrop -= leaveBorder;\n        eastPixelsToCrop -= leaveBorder;\n        northPixelsToCrop -= leaveBorder;\n        southPixelsToCrop -= leaveBorder;\n        if (cropSymmetric) {\n          const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);\n          const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);\n          westPixelsToCrop = horizontal;\n          eastPixelsToCrop = horizontal;\n          northPixelsToCrop = vertical;\n          southPixelsToCrop = vertical;\n        }\n\n        // make sure that crops are >= 0\n        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;\n        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;\n        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;\n        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;\n\n        // safety checks\n        const widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);\n        const heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);\n        if (cropOnlyFrames) {\n          // crop image if all sides should be cropped\n          doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;\n        } else {\n          // crop image if at least one side should be cropped\n          doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;\n        }\n        if (doCrop) {\n          // do the real crop\n          this.crop(westPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);\n        }\n        if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n          cb.call(this, null, this);\n        }\n        return this;\n      }\n    }\n  };\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY3JvcC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUV3RDtBQUN6QztBQUNmO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLCtEQUErRCxtREFBVTtBQUN6RSwrREFBK0QsbURBQVU7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCLHVCQUF1QjtBQUN4QyxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEMsZ0JBQWdCO0FBQ2hCLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRCw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFELGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyQ0FBMkM7QUFDaEYsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRixnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY3JvcC9lcy9pbmRleC5qcz8yZjE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWxhYmVscyAqL1xuXG5pbXBvcnQgeyB0aHJvd0Vycm9yLCBpc05vZGVQYXR0ZXJuIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwbHVnaW5Dcm9wKGV2ZW50KSB7XG4gIC8qKlxuICAgKiBDcm9wcyB0aGUgaW1hZ2UgYXQgYSBnaXZlbiBwb2ludCB0byBhIGdpdmUgc2l6ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geCB0aGUgeCBjb29yZGluYXRlIHRvIGNyb3AgZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIHRvIGNyb3AgZm9ybVxuICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIGNyb3AgcmVnaW9uXG4gICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIGNyb3AgcmVnaW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIGV2ZW50KFwiY3JvcFwiLCBmdW5jdGlvbiAoeCwgeSwgdywgaCwgY2IpIHtcbiAgICBpZiAodHlwZW9mIHggIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHkgIT09IFwibnVtYmVyXCIpIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ4IGFuZCB5IG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gICAgaWYgKHR5cGVvZiB3ICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBoICE9PSBcIm51bWJlclwiKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwidyBhbmQgaCBtdXN0IGJlIG51bWJlcnNcIiwgY2IpO1xuXG4gICAgLy8gcm91bmQgaW5wdXRcbiAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB3ID0gTWF0aC5yb3VuZCh3KTtcbiAgICBoID0gTWF0aC5yb3VuZChoKTtcbiAgICBpZiAoeCA9PT0gMCAmJiB3ID09PSB0aGlzLmJpdG1hcC53aWR0aCkge1xuICAgICAgLy8gc2hvcnRjdXRcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdyAqIHkgKyB4IDw8IDI7XG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIChoICogdyA8PCAyKTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGEgPSB0aGlzLmJpdG1hcC5kYXRhLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBiaXRtYXAgPSBCdWZmZXIuYWxsb2NVbnNhZmUodyAqIGggKiA0KTtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgdGhpcy5zY2FuUXVpZXQoeCwgeSwgdywgaCwgZnVuY3Rpb24gKHgsIHksIGlkeCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5iaXRtYXAuZGF0YS5yZWFkVUludDMyQkUoaWR4LCB0cnVlKTtcbiAgICAgICAgYml0bWFwLndyaXRlVUludDMyQkUoZGF0YSwgb2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGEgPSBiaXRtYXA7XG4gICAgfVxuICAgIHRoaXMuYml0bWFwLndpZHRoID0gdztcbiAgICB0aGlzLmJpdG1hcC5oZWlnaHQgPSBoO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsYXNzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEF1dG9jcm9wIHNhbWUgY29sb3IgYm9yZGVycyBmcm9tIHRoaXMgaW1hZ2VcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgKG9wdGlvbmFsKTogYSBwZXJjZW50IHZhbHVlIG9mIHRvbGVyYW5jZSBmb3IgcGl4ZWxzIGNvbG9yIGRpZmZlcmVuY2UgKGRlZmF1bHQ6IDAuMDAwMiUpXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyb3BPbmx5RnJhbWVzIChvcHRpb25hbCk6IGZsYWcgdG8gY3JvcCBvbmx5IHJlYWwgZnJhbWVzOiBhbGwgNCBzaWRlcyBvZiB0aGUgaW1hZ2UgbXVzdCBoYXZlIHNvbWUgYm9yZGVyIChkZWZhdWx0OiB0cnVlKVxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCk6IGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGUgKGRlZmF1bHQ6IG5vIGNhbGxiYWNrKVxuICAgICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgICAqL1xuICAgICAgYXV0b2Nyb3AoKSB7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLmJpdG1hcC53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuYml0bWFwLmhlaWdodDtcbiAgICAgICAgY29uc3QgbWluUGl4ZWxzUGVyU2lkZSA9IDE7IC8vIHRvIGF2b2lkIGNyb3BwaW5nIGNvbXBsZXRlbHkgdGhlIGltYWdlLCByZXN1bHRpbmcgaW4gYW4gaW52YWxpZCAwIHNpemVkIGltYWdlXG5cbiAgICAgICAgbGV0IGNiOyAvLyBjYWxsYmFja1xuICAgICAgICBsZXQgbGVhdmVCb3JkZXIgPSAwOyAvLyBBbW91bnQgb2YgcGl4ZWxzIGluIGJvcmRlciB0byBsZWF2ZVxuICAgICAgICBsZXQgdG9sZXJhbmNlID0gMC4wMDAyOyAvLyBwZXJjZW50IG9mIGNvbG9yIGRpZmZlcmVuY2UgdG9sZXJhbmNlIChkZWZhdWx0IHZhbHVlKVxuICAgICAgICBsZXQgY3JvcE9ubHlGcmFtZXMgPSB0cnVlOyAvLyBmbGFnIHRvIGZvcmNlIGNyb3BwaW5nIG9ubHkgaWYgdGhlIGltYWdlIGhhcyBhIHJlYWwgXCJmcmFtZVwiXG4gICAgICAgIC8vIGkuZS4gYWxsIDQgc2lkZXMgaGF2ZSBzb21lIGJvcmRlciAoZGVmYXVsdCB2YWx1ZSlcbiAgICAgICAgbGV0IGNyb3BTeW1tZXRyaWMgPSBmYWxzZTsgLy8gZmxhZyB0byBmb3JjZSBjcm9wcGluZyB0b3AgYmUgc3ltbWV0cmljLlxuICAgICAgICAvLyBpLmUuIG5vcnRoIGFuZCBzb3V0aCAvIGVhc3QgYW5kIHdlc3QgYXJlIGNyb3BwZWQgYnkgdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgbGV0IGlnbm9yZVNpZGVzID0ge1xuICAgICAgICAgIG5vcnRoOiBmYWxzZSxcbiAgICAgICAgICBzb3V0aDogZmFsc2UsXG4gICAgICAgICAgZWFzdDogZmFsc2UsXG4gICAgICAgICAgd2VzdDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYXJzZSBhcmd1bWVudHNcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBhID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGEgPCBsZW47IGErKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgLy8gdG9sZXJhbmNlIHZhbHVlIHBhc3NlZFxuICAgICAgICAgICAgdG9sZXJhbmNlID0gYXJnc1thXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FdID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgLy8gY3JvcE9ubHlGcmFtZXMgdmFsdWUgcGFzc2VkXG4gICAgICAgICAgICBjcm9wT25seUZyYW1lcyA9IGFyZ3NbYV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBjYWxsYmFjayB2YWx1ZSBwYXNzZWRcbiAgICAgICAgICAgIGNiID0gYXJnc1thXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBjb25maWcgb2JqZWN0IHBhc3NlZFxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gYXJnc1thXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRvbGVyYW5jZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAoe1xuICAgICAgICAgICAgICAgIHRvbGVyYW5jZVxuICAgICAgICAgICAgICB9ID0gY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNyb3BPbmx5RnJhbWVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICh7XG4gICAgICAgICAgICAgICAgY3JvcE9ubHlGcmFtZXNcbiAgICAgICAgICAgICAgfSA9IGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5jcm9wU3ltbWV0cmljICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICh7XG4gICAgICAgICAgICAgICAgY3JvcFN5bW1ldHJpY1xuICAgICAgICAgICAgICB9ID0gY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmxlYXZlQm9yZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICh7XG4gICAgICAgICAgICAgICAgbGVhdmVCb3JkZXJcbiAgICAgICAgICAgICAgfSA9IGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5pZ25vcmVTaWRlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAoe1xuICAgICAgICAgICAgICAgIGlnbm9yZVNpZGVzXG4gICAgICAgICAgICAgIH0gPSBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgYm9yZGVycyBtdXN0IGJlIG9mIHRoZSBzYW1lIGNvbG9yIGFzIHRoZSB0b3AgbGVmdCBwaXhlbCwgdG8gYmUgY3JvcHBlZC5cbiAgICAgICAgICogSXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIGNyb3AgYm9yZGVycyBlYWNoIHdpdGggYSBkaWZmZXJlbnQgY29sb3IsXG4gICAgICAgICAqIGJ1dCBzaW5jZSB0aGVyZSBhcmUgbWFueSB3YXlzIGZvciBjb3JuZXJzIHRvIGludGVyc2VjdCwgaXQgd291bGRcbiAgICAgICAgICogaW50cm9kdWNlIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkgdG8gdGhlIGFsZ29yaXRobS5cbiAgICAgICAgICovXG5cbiAgICAgICAgLy8gc2NhbiBlYWNoIHNpZGUgZm9yIHNhbWUgY29sb3IgYm9yZGVyc1xuICAgICAgICBsZXQgY29sb3JUYXJnZXQgPSB0aGlzLmdldFBpeGVsQ29sb3IoMCwgMCk7IC8vIHRvcCBsZWZ0IHBpeGVsIGNvbG9yIGlzIHRoZSB0YXJnZXQgY29sb3JcbiAgICAgICAgY29uc3QgcmdiYTEgPSB0aGlzLmNvbnN0cnVjdG9yLmludFRvUkdCQShjb2xvclRhcmdldCk7XG5cbiAgICAgICAgLy8gZm9yIG5vcnRoIGFuZCBlYXN0IHNpZGVzXG4gICAgICAgIGxldCBub3J0aFBpeGVsc1RvQ3JvcCA9IDA7XG4gICAgICAgIGxldCBlYXN0UGl4ZWxzVG9Dcm9wID0gMDtcbiAgICAgICAgbGV0IHNvdXRoUGl4ZWxzVG9Dcm9wID0gMDtcbiAgICAgICAgbGV0IHdlc3RQaXhlbHNUb0Nyb3AgPSAwO1xuXG4gICAgICAgIC8vIG5vcnRoIHNpZGUgKHNjYW4gcm93cyBmcm9tIG5vcnRoIHRvIHNvdXRoKVxuICAgICAgICBjb2xvclRhcmdldCA9IHRoaXMuZ2V0UGl4ZWxDb2xvcigwLCAwKTtcbiAgICAgICAgaWYgKCFpZ25vcmVTaWRlcy5ub3J0aCkge1xuICAgICAgICAgIG5vcnRoOiBmb3IgKGxldCB5ID0gMDsgeSA8IGggLSBtaW5QaXhlbHNQZXJTaWRlOyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbG9yWFkgPSB0aGlzLmdldFBpeGVsQ29sb3IoeCwgeSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJnYmEyID0gdGhpcy5jb25zdHJ1Y3Rvci5pbnRUb1JHQkEoY29sb3JYWSk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmNvbG9yRGlmZihyZ2JhMSwgcmdiYTIpID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBwaXhlbCBpcyB0b28gZGlzdGFudCBmcm9tIHRoZSBmaXJzdCBvbmU6IGFib3J0IHRoaXMgc2lkZSBzY2FuXG4gICAgICAgICAgICAgICAgYnJlYWsgbm9ydGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcyByb3cgY29udGFpbnMgYWxsIHBpeGVscyB3aXRoIHRoZSBzYW1lIGNvbG9yOiBpbmNyZW1lbnQgdGhpcyBzaWRlIHBpeGVscyB0byBjcm9wXG4gICAgICAgICAgICBub3J0aFBpeGVsc1RvQ3JvcCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlc3Qgc2lkZSAoc2NhbiBjb2x1bW5zIGZyb20gd2VzdCB0byBlYXN0KVxuICAgICAgICBjb2xvclRhcmdldCA9IHRoaXMuZ2V0UGl4ZWxDb2xvcih3LCAwKTtcbiAgICAgICAgaWYgKCFpZ25vcmVTaWRlcy53ZXN0KSB7XG4gICAgICAgICAgd2VzdDogZm9yIChsZXQgeCA9IDA7IHggPCB3IC0gbWluUGl4ZWxzUGVyU2lkZTsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMCArIG5vcnRoUGl4ZWxzVG9Dcm9wOyB5IDwgaDsgeSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbG9yWFkgPSB0aGlzLmdldFBpeGVsQ29sb3IoeCwgeSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJnYmEyID0gdGhpcy5jb25zdHJ1Y3Rvci5pbnRUb1JHQkEoY29sb3JYWSk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmNvbG9yRGlmZihyZ2JhMSwgcmdiYTIpID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBwaXhlbCBpcyB0b28gZGlzdGFudCBmcm9tIHRoZSBmaXJzdCBvbmU6IGFib3J0IHRoaXMgc2lkZSBzY2FuXG4gICAgICAgICAgICAgICAgYnJlYWsgd2VzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIGNvbHVtbiBjb250YWlucyBhbGwgcGl4ZWxzIHdpdGggdGhlIHNhbWUgY29sb3I6IGluY3JlbWVudCB0aGlzIHNpZGUgcGl4ZWxzIHRvIGNyb3BcbiAgICAgICAgICAgIHdlc3RQaXhlbHNUb0Nyb3ArKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb3V0aCBzaWRlIChzY2FuIHJvd3MgZnJvbSBzb3V0aCB0byBub3J0aClcbiAgICAgICAgY29sb3JUYXJnZXQgPSB0aGlzLmdldFBpeGVsQ29sb3IoMCwgaCk7XG4gICAgICAgIGlmICghaWdub3JlU2lkZXMuc291dGgpIHtcbiAgICAgICAgICBzb3V0aDogZm9yIChsZXQgeSA9IGggLSAxOyB5ID49IG5vcnRoUGl4ZWxzVG9Dcm9wICsgbWluUGl4ZWxzUGVyU2lkZTsgeS0tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gdyAtIGVhc3RQaXhlbHNUb0Nyb3AgLSAxOyB4ID49IDA7IHgtLSkge1xuICAgICAgICAgICAgICBjb25zdCBjb2xvclhZID0gdGhpcy5nZXRQaXhlbENvbG9yKHgsIHkpO1xuICAgICAgICAgICAgICBjb25zdCByZ2JhMiA9IHRoaXMuY29uc3RydWN0b3IuaW50VG9SR0JBKGNvbG9yWFkpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5jb2xvckRpZmYocmdiYTEsIHJnYmEyKSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgcGl4ZWwgaXMgdG9vIGRpc3RhbnQgZnJvbSB0aGUgZmlyc3Qgb25lOiBhYm9ydCB0aGlzIHNpZGUgc2NhblxuICAgICAgICAgICAgICAgIGJyZWFrIHNvdXRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMgcm93IGNvbnRhaW5zIGFsbCBwaXhlbHMgd2l0aCB0aGUgc2FtZSBjb2xvcjogaW5jcmVtZW50IHRoaXMgc2lkZSBwaXhlbHMgdG8gY3JvcFxuICAgICAgICAgICAgc291dGhQaXhlbHNUb0Nyb3ArKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlYXN0IHNpZGUgKHNjYW4gY29sdW1ucyBmcm9tIGVhc3QgdG8gd2VzdClcbiAgICAgICAgY29sb3JUYXJnZXQgPSB0aGlzLmdldFBpeGVsQ29sb3IodywgaCk7XG4gICAgICAgIGlmICghaWdub3JlU2lkZXMuZWFzdCkge1xuICAgICAgICAgIGVhc3Q6IGZvciAobGV0IHggPSB3IC0gMTsgeCA+PSAwICsgd2VzdFBpeGVsc1RvQ3JvcCArIG1pblBpeGVsc1BlclNpZGU7IHgtLSkge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IGggLSAxOyB5ID49IDAgKyBub3J0aFBpeGVsc1RvQ3JvcDsgeS0tKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbG9yWFkgPSB0aGlzLmdldFBpeGVsQ29sb3IoeCwgeSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJnYmEyID0gdGhpcy5jb25zdHJ1Y3Rvci5pbnRUb1JHQkEoY29sb3JYWSk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmNvbG9yRGlmZihyZ2JhMSwgcmdiYTIpID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBwaXhlbCBpcyB0b28gZGlzdGFudCBmcm9tIHRoZSBmaXJzdCBvbmU6IGFib3J0IHRoaXMgc2lkZSBzY2FuXG4gICAgICAgICAgICAgICAgYnJlYWsgZWFzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIGNvbHVtbiBjb250YWlucyBhbGwgcGl4ZWxzIHdpdGggdGhlIHNhbWUgY29sb3I6IGluY3JlbWVudCB0aGlzIHNpZGUgcGl4ZWxzIHRvIGNyb3BcbiAgICAgICAgICAgIGVhc3RQaXhlbHNUb0Nyb3ArKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWNpZGUgaWYgYSBjcm9wIGlzIG5lZWRlZFxuICAgICAgICBsZXQgZG9Dcm9wID0gZmFsc2U7XG5cbiAgICAgICAgLy8gYXBwbHkgbGVhdmVCb3JkZXJcbiAgICAgICAgd2VzdFBpeGVsc1RvQ3JvcCAtPSBsZWF2ZUJvcmRlcjtcbiAgICAgICAgZWFzdFBpeGVsc1RvQ3JvcCAtPSBsZWF2ZUJvcmRlcjtcbiAgICAgICAgbm9ydGhQaXhlbHNUb0Nyb3AgLT0gbGVhdmVCb3JkZXI7XG4gICAgICAgIHNvdXRoUGl4ZWxzVG9Dcm9wIC09IGxlYXZlQm9yZGVyO1xuICAgICAgICBpZiAoY3JvcFN5bW1ldHJpYykge1xuICAgICAgICAgIGNvbnN0IGhvcml6b250YWwgPSBNYXRoLm1pbihlYXN0UGl4ZWxzVG9Dcm9wLCB3ZXN0UGl4ZWxzVG9Dcm9wKTtcbiAgICAgICAgICBjb25zdCB2ZXJ0aWNhbCA9IE1hdGgubWluKG5vcnRoUGl4ZWxzVG9Dcm9wLCBzb3V0aFBpeGVsc1RvQ3JvcCk7XG4gICAgICAgICAgd2VzdFBpeGVsc1RvQ3JvcCA9IGhvcml6b250YWw7XG4gICAgICAgICAgZWFzdFBpeGVsc1RvQ3JvcCA9IGhvcml6b250YWw7XG4gICAgICAgICAgbm9ydGhQaXhlbHNUb0Nyb3AgPSB2ZXJ0aWNhbDtcbiAgICAgICAgICBzb3V0aFBpeGVsc1RvQ3JvcCA9IHZlcnRpY2FsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgY3JvcHMgYXJlID49IDBcbiAgICAgICAgd2VzdFBpeGVsc1RvQ3JvcCA9IHdlc3RQaXhlbHNUb0Nyb3AgPj0gMCA/IHdlc3RQaXhlbHNUb0Nyb3AgOiAwO1xuICAgICAgICBlYXN0UGl4ZWxzVG9Dcm9wID0gZWFzdFBpeGVsc1RvQ3JvcCA+PSAwID8gZWFzdFBpeGVsc1RvQ3JvcCA6IDA7XG4gICAgICAgIG5vcnRoUGl4ZWxzVG9Dcm9wID0gbm9ydGhQaXhlbHNUb0Nyb3AgPj0gMCA/IG5vcnRoUGl4ZWxzVG9Dcm9wIDogMDtcbiAgICAgICAgc291dGhQaXhlbHNUb0Nyb3AgPSBzb3V0aFBpeGVsc1RvQ3JvcCA+PSAwID8gc291dGhQaXhlbHNUb0Nyb3AgOiAwO1xuXG4gICAgICAgIC8vIHNhZmV0eSBjaGVja3NcbiAgICAgICAgY29uc3Qgd2lkdGhPZlJlbWFpbmluZ1BpeGVscyA9IHcgLSAod2VzdFBpeGVsc1RvQ3JvcCArIGVhc3RQaXhlbHNUb0Nyb3ApO1xuICAgICAgICBjb25zdCBoZWlnaHRPZlJlbWFpbmluZ1BpeGVscyA9IGggLSAoc291dGhQaXhlbHNUb0Nyb3AgKyBub3J0aFBpeGVsc1RvQ3JvcCk7XG4gICAgICAgIGlmIChjcm9wT25seUZyYW1lcykge1xuICAgICAgICAgIC8vIGNyb3AgaW1hZ2UgaWYgYWxsIHNpZGVzIHNob3VsZCBiZSBjcm9wcGVkXG4gICAgICAgICAgZG9Dcm9wID0gZWFzdFBpeGVsc1RvQ3JvcCAhPT0gMCAmJiBub3J0aFBpeGVsc1RvQ3JvcCAhPT0gMCAmJiB3ZXN0UGl4ZWxzVG9Dcm9wICE9PSAwICYmIHNvdXRoUGl4ZWxzVG9Dcm9wICE9PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyb3AgaW1hZ2UgaWYgYXQgbGVhc3Qgb25lIHNpZGUgc2hvdWxkIGJlIGNyb3BwZWRcbiAgICAgICAgICBkb0Nyb3AgPSBlYXN0UGl4ZWxzVG9Dcm9wICE9PSAwIHx8IG5vcnRoUGl4ZWxzVG9Dcm9wICE9PSAwIHx8IHdlc3RQaXhlbHNUb0Nyb3AgIT09IDAgfHwgc291dGhQaXhlbHNUb0Nyb3AgIT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvQ3JvcCkge1xuICAgICAgICAgIC8vIGRvIHRoZSByZWFsIGNyb3BcbiAgICAgICAgICB0aGlzLmNyb3Aod2VzdFBpeGVsc1RvQ3JvcCwgbm9ydGhQaXhlbHNUb0Nyb3AsIHdpZHRoT2ZSZW1haW5pbmdQaXhlbHMsIGhlaWdodE9mUmVtYWluaW5nUGl4ZWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-crop/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-displace/es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@jimp/plugin-displace/es/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Displaces the image based on the provided displacement map\n * @param {object} map the source Jimp instance\n * @param {number} offset the maximum displacement value\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  displace(map, offset, cb) {\n    if (typeof map !== \"object\" || map.constructor !== this.constructor) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"The source must be a Jimp image\", cb);\n    }\n    if (typeof offset !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"factor must be a number\", cb);\n    }\n    const source = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      let displacement = map.bitmap.data[idx] / 256 * offset;\n      displacement = Math.round(displacement);\n      const ids = this.getPixelIndex(x + displacement, y);\n      this.bitmap.data[ids] = source.bitmap.data[idx];\n      this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];\n      this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tZGlzcGxhY2UvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0Q7O0FBRXhEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGlFQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tZGlzcGxhY2UvZXMvaW5kZXguanM/Y2U5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5cbi8qKlxuICogRGlzcGxhY2VzIHRoZSBpbWFnZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGlzcGxhY2VtZW50IG1hcFxuICogQHBhcmFtIHtvYmplY3R9IG1hcCB0aGUgc291cmNlIEppbXAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIG1heGltdW0gZGlzcGxhY2VtZW50IHZhbHVlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgZGlzcGxhY2UobWFwLCBvZmZzZXQsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBtYXAgIT09IFwib2JqZWN0XCIgfHwgbWFwLmNvbnN0cnVjdG9yICE9PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiVGhlIHNvdXJjZSBtdXN0IGJlIGEgSmltcCBpbWFnZVwiLCBjYik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiZmFjdG9yIG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmNsb25lUXVpZXQoKTtcbiAgICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICBsZXQgZGlzcGxhY2VtZW50ID0gbWFwLmJpdG1hcC5kYXRhW2lkeF0gLyAyNTYgKiBvZmZzZXQ7XG4gICAgICBkaXNwbGFjZW1lbnQgPSBNYXRoLnJvdW5kKGRpc3BsYWNlbWVudCk7XG4gICAgICBjb25zdCBpZHMgPSB0aGlzLmdldFBpeGVsSW5kZXgoeCArIGRpc3BsYWNlbWVudCwgeSk7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkc10gPSBzb3VyY2UuYml0bWFwLmRhdGFbaWR4XTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWRzICsgMV0gPSBzb3VyY2UuYml0bWFwLmRhdGFbaWR4ICsgMV07XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkcyArIDJdID0gc291cmNlLmJpdG1hcC5kYXRhW2lkeCArIDJdO1xuICAgIH0pO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-displace/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-dither/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-dither/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Apply a ordered dithering effect\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nfunction dither(cb) {\n  const rgb565Matrix = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n    const thresholdId = ((y & 3) << 2) + x % 4;\n    const dither = rgb565Matrix[thresholdId];\n    this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither, 0xff);\n    this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither, 0xff);\n    this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither, 0xff);\n  });\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  dither565: dither,\n  dither16: dither\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tZGl0aGVyL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDOztBQUU1QztBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxNQUFNLDBEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxDQUFDLENBQUMsRUFBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWRpdGhlci9lcy9pbmRleC5qcz9kMDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTm9kZVBhdHRlcm4gfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcblxuLyoqXG4gKiBBcHBseSBhIG9yZGVyZWQgZGl0aGVyaW5nIGVmZmVjdFxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAqL1xuZnVuY3Rpb24gZGl0aGVyKGNiKSB7XG4gIGNvbnN0IHJnYjU2NU1hdHJpeCA9IFsxLCA5LCAzLCAxMSwgMTMsIDUsIDE1LCA3LCA0LCAxMiwgMiwgMTAsIDE2LCA4LCAxNCwgNl07XG4gIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICBjb25zdCB0aHJlc2hvbGRJZCA9ICgoeSAmIDMpIDw8IDIpICsgeCAlIDQ7XG4gICAgY29uc3QgZGl0aGVyID0gcmdiNTY1TWF0cml4W3RocmVzaG9sZElkXTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSBNYXRoLm1pbih0aGlzLmJpdG1hcC5kYXRhW2lkeF0gKyBkaXRoZXIsIDB4ZmYpO1xuICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSBNYXRoLm1pbih0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdICsgZGl0aGVyLCAweGZmKTtcbiAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gTWF0aC5taW4odGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSArIGRpdGhlciwgMHhmZik7XG4gIH0pO1xuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZXhwb3J0IGRlZmF1bHQgKCgpID0+ICh7XG4gIGRpdGhlcjU2NTogZGl0aGVyLFxuICBkaXRoZXIxNjogZGl0aGVyXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-dither/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-fisheye/es/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jimp/plugin-fisheye/es/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Creates a circle out of an image.\n * @param {object} options (optional) r: radius of effect\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  fisheye() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      r: 2.5\n    };\n    let cb = arguments.length > 1 ? arguments[1] : undefined;\n    if (typeof options === \"function\") {\n      cb = options;\n      options = {\n        r: 2.5\n      };\n    }\n    const source = this.cloneQuiet();\n    const {\n      width,\n      height\n    } = source.bitmap;\n    source.scanQuiet(0, 0, width, height, (x, y) => {\n      const hx = x / width;\n      const hy = y / height;\n      const r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));\n      const rn = 2 * Math.pow(r, options.r);\n      const cosA = (hx - 0.5) / r;\n      const sinA = (hy - 0.5) / r;\n      const newX = Math.round((rn * cosA + 0.5) * width);\n      const newY = Math.round((rn * sinA + 0.5) * height);\n      const color = source.getPixelColor(newX, newY);\n      this.setPixelColor(color, x, y);\n    });\n\n    /* Set center pixel color, otherwise it will be transparent */\n    this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tZmlzaGV5ZS9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0Qzs7QUFFNUM7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLE1BQU07QUFDbkI7QUFDQSxpRUFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLEVBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1maXNoZXllL2VzL2luZGV4LmpzPzhkY2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXJjbGUgb3V0IG9mIGFuIGltYWdlLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgKG9wdGlvbmFsKSByOiByYWRpdXMgb2YgZWZmZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgZmlzaGV5ZSgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge1xuICAgICAgcjogMi41XG4gICAgfTtcbiAgICBsZXQgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcjogMi41XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmNsb25lUXVpZXQoKTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBzb3VyY2UuYml0bWFwO1xuICAgIHNvdXJjZS5zY2FuUXVpZXQoMCwgMCwgd2lkdGgsIGhlaWdodCwgKHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGh4ID0geCAvIHdpZHRoO1xuICAgICAgY29uc3QgaHkgPSB5IC8gaGVpZ2h0O1xuICAgICAgY29uc3QgciA9IE1hdGguc3FydChNYXRoLnBvdyhoeCAtIDAuNSwgMikgKyBNYXRoLnBvdyhoeSAtIDAuNSwgMikpO1xuICAgICAgY29uc3Qgcm4gPSAyICogTWF0aC5wb3cociwgb3B0aW9ucy5yKTtcbiAgICAgIGNvbnN0IGNvc0EgPSAoaHggLSAwLjUpIC8gcjtcbiAgICAgIGNvbnN0IHNpbkEgPSAoaHkgLSAwLjUpIC8gcjtcbiAgICAgIGNvbnN0IG5ld1ggPSBNYXRoLnJvdW5kKChybiAqIGNvc0EgKyAwLjUpICogd2lkdGgpO1xuICAgICAgY29uc3QgbmV3WSA9IE1hdGgucm91bmQoKHJuICogc2luQSArIDAuNSkgKiBoZWlnaHQpO1xuICAgICAgY29uc3QgY29sb3IgPSBzb3VyY2UuZ2V0UGl4ZWxDb2xvcihuZXdYLCBuZXdZKTtcbiAgICAgIHRoaXMuc2V0UGl4ZWxDb2xvcihjb2xvciwgeCwgeSk7XG4gICAgfSk7XG5cbiAgICAvKiBTZXQgY2VudGVyIHBpeGVsIGNvbG9yLCBvdGhlcndpc2UgaXQgd2lsbCBiZSB0cmFuc3BhcmVudCAqL1xuICAgIHRoaXMuc2V0UGl4ZWxDb2xvcihzb3VyY2UuZ2V0UGl4ZWxDb2xvcih3aWR0aCAvIDIsIGhlaWdodCAvIDIpLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-fisheye/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-flip/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-flip/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Flip the image horizontally\n * @param {boolean} horizontal a Boolean, if true the image will be flipped horizontally\n * @param {boolean} vertical a Boolean, if true the image will be flipped vertically\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nfunction flipFn(horizontal, vertical, cb) {\n  if (typeof horizontal !== \"boolean\" || typeof vertical !== \"boolean\") return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"horizontal and vertical must be Booleans\", cb);\n  const bitmap = Buffer.alloc(this.bitmap.data.length);\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n    const _x = horizontal ? this.bitmap.width - 1 - x : x;\n    const _y = vertical ? this.bitmap.height - 1 - y : y;\n    const _idx = this.bitmap.width * _y + _x << 2;\n    const data = this.bitmap.data.readUInt32BE(idx);\n    bitmap.writeUInt32BE(data, _idx);\n  });\n  this.bitmap.data = Buffer.from(bitmap);\n  if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  flip: flipFn,\n  mirror: flipFn\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tZmxpcC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDs7QUFFeEQ7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSwrRUFBK0UsbURBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxNQUFNLDBEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxDQUFDLENBQUMsRUFBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWZsaXAvZXMvaW5kZXguanM/M2QyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5cbi8qKlxuICogRmxpcCB0aGUgaW1hZ2UgaG9yaXpvbnRhbGx5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhvcml6b250YWwgYSBCb29sZWFuLCBpZiB0cnVlIHRoZSBpbWFnZSB3aWxsIGJlIGZsaXBwZWQgaG9yaXpvbnRhbGx5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZlcnRpY2FsIGEgQm9vbGVhbiwgaWYgdHJ1ZSB0aGUgaW1hZ2Ugd2lsbCBiZSBmbGlwcGVkIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIGZsaXBGbihob3Jpem9udGFsLCB2ZXJ0aWNhbCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBob3Jpem9udGFsICE9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgdmVydGljYWwgIT09IFwiYm9vbGVhblwiKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgbXVzdCBiZSBCb29sZWFuc1wiLCBjYik7XG4gIGNvbnN0IGJpdG1hcCA9IEJ1ZmZlci5hbGxvYyh0aGlzLmJpdG1hcC5kYXRhLmxlbmd0aCk7XG4gIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICBjb25zdCBfeCA9IGhvcml6b250YWwgPyB0aGlzLmJpdG1hcC53aWR0aCAtIDEgLSB4IDogeDtcbiAgICBjb25zdCBfeSA9IHZlcnRpY2FsID8gdGhpcy5iaXRtYXAuaGVpZ2h0IC0gMSAtIHkgOiB5O1xuICAgIGNvbnN0IF9pZHggPSB0aGlzLmJpdG1hcC53aWR0aCAqIF95ICsgX3ggPDwgMjtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5iaXRtYXAuZGF0YS5yZWFkVUludDMyQkUoaWR4KTtcbiAgICBiaXRtYXAud3JpdGVVSW50MzJCRShkYXRhLCBfaWR4KTtcbiAgfSk7XG4gIHRoaXMuYml0bWFwLmRhdGEgPSBCdWZmZXIuZnJvbShiaXRtYXApO1xuICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZXhwb3J0IGRlZmF1bHQgKCgpID0+ICh7XG4gIGZsaXA6IGZsaXBGbixcbiAgbWlycm9yOiBmbGlwRm5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-flip/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-gaussian/es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@jimp/plugin-gaussian/es/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Applies a true Gaussian blur to the image (warning: this is VERY slow)\n * @param {number} r the pixel radius of the blur\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  gaussian(r, cb) {\n    // http://blog.ivank.net/fastest-gaussian-blur.html\n    if (typeof r !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"r must be a number\", cb);\n    }\n    if (r < 1) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"r must be greater than 0\", cb);\n    }\n    const rs = Math.ceil(r * 2.57); // significant radius\n    const range = rs * 2 + 1;\n    const rr2 = r * r * 2;\n    const rr2pi = rr2 * Math.PI;\n    const weights = [];\n    for (let y = 0; y < range; y++) {\n      weights[y] = [];\n      for (let x = 0; x < range; x++) {\n        const dsq = (x - rs) ** 2 + (y - rs) ** 2;\n        weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;\n      }\n    }\n    for (let y = 0; y < this.bitmap.height; y++) {\n      for (let x = 0; x < this.bitmap.width; x++) {\n        let red = 0;\n        let green = 0;\n        let blue = 0;\n        let alpha = 0;\n        let wsum = 0;\n        for (let iy = 0; iy < range; iy++) {\n          for (let ix = 0; ix < range; ix++) {\n            const x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + x - rs));\n            const y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + y - rs));\n            const weight = weights[iy][ix];\n            const idx = y1 * this.bitmap.width + x1 << 2;\n            red += this.bitmap.data[idx] * weight;\n            green += this.bitmap.data[idx + 1] * weight;\n            blue += this.bitmap.data[idx + 2] * weight;\n            alpha += this.bitmap.data[idx + 3] * weight;\n            wsum += weight;\n          }\n          const idx = y * this.bitmap.width + x << 2;\n          this.bitmap.data[idx] = Math.round(red / wsum);\n          this.bitmap.data[idx + 1] = Math.round(green / wsum);\n          this.bitmap.data[idx + 2] = Math.round(blue / wsum);\n          this.bitmap.data[idx + 3] = Math.round(alpha / wsum);\n        }\n      }\n    }\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tZ2F1c3NpYW4vZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0Q7O0FBRXhEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QyxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQywyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLEVBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1nYXVzc2lhbi9lcy9pbmRleC5qcz8zMTMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTm9kZVBhdHRlcm4sIHRocm93RXJyb3IgfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcblxuLyoqXG4gKiBBcHBsaWVzIGEgdHJ1ZSBHYXVzc2lhbiBibHVyIHRvIHRoZSBpbWFnZSAod2FybmluZzogdGhpcyBpcyBWRVJZIHNsb3cpXG4gKiBAcGFyYW0ge251bWJlcn0gciB0aGUgcGl4ZWwgcmFkaXVzIG9mIHRoZSBibHVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgZ2F1c3NpYW4ociwgY2IpIHtcbiAgICAvLyBodHRwOi8vYmxvZy5pdmFuay5uZXQvZmFzdGVzdC1nYXVzc2lhbi1ibHVyLmh0bWxcbiAgICBpZiAodHlwZW9mIHIgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJyIG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgIH1cbiAgICBpZiAociA8IDEpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJyIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIiwgY2IpO1xuICAgIH1cbiAgICBjb25zdCBycyA9IE1hdGguY2VpbChyICogMi41Nyk7IC8vIHNpZ25pZmljYW50IHJhZGl1c1xuICAgIGNvbnN0IHJhbmdlID0gcnMgKiAyICsgMTtcbiAgICBjb25zdCBycjIgPSByICogciAqIDI7XG4gICAgY29uc3QgcnIycGkgPSBycjIgKiBNYXRoLlBJO1xuICAgIGNvbnN0IHdlaWdodHMgPSBbXTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHJhbmdlOyB5KyspIHtcbiAgICAgIHdlaWdodHNbeV0gPSBbXTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcmFuZ2U7IHgrKykge1xuICAgICAgICBjb25zdCBkc3EgPSAoeCAtIHJzKSAqKiAyICsgKHkgLSBycykgKiogMjtcbiAgICAgICAgd2VpZ2h0c1t5XVt4XSA9IE1hdGguZXhwKC1kc3EgLyBycjIpIC8gcnIycGk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5iaXRtYXAuaGVpZ2h0OyB5KyspIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5iaXRtYXAud2lkdGg7IHgrKykge1xuICAgICAgICBsZXQgcmVkID0gMDtcbiAgICAgICAgbGV0IGdyZWVuID0gMDtcbiAgICAgICAgbGV0IGJsdWUgPSAwO1xuICAgICAgICBsZXQgYWxwaGEgPSAwO1xuICAgICAgICBsZXQgd3N1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGl5ID0gMDsgaXkgPCByYW5nZTsgaXkrKykge1xuICAgICAgICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCByYW5nZTsgaXgrKykge1xuICAgICAgICAgICAgY29uc3QgeDEgPSBNYXRoLm1pbih0aGlzLmJpdG1hcC53aWR0aCAtIDEsIE1hdGgubWF4KDAsIGl4ICsgeCAtIHJzKSk7XG4gICAgICAgICAgICBjb25zdCB5MSA9IE1hdGgubWluKHRoaXMuYml0bWFwLmhlaWdodCAtIDEsIE1hdGgubWF4KDAsIGl5ICsgeSAtIHJzKSk7XG4gICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSB3ZWlnaHRzW2l5XVtpeF07XG4gICAgICAgICAgICBjb25zdCBpZHggPSB5MSAqIHRoaXMuYml0bWFwLndpZHRoICsgeDEgPDwgMjtcbiAgICAgICAgICAgIHJlZCArPSB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gKiB3ZWlnaHQ7XG4gICAgICAgICAgICBncmVlbiArPSB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdICogd2VpZ2h0O1xuICAgICAgICAgICAgYmx1ZSArPSB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdICogd2VpZ2h0O1xuICAgICAgICAgICAgYWxwaGEgKz0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAzXSAqIHdlaWdodDtcbiAgICAgICAgICAgIHdzdW0gKz0gd2VpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpZHggPSB5ICogdGhpcy5iaXRtYXAud2lkdGggKyB4IDw8IDI7XG4gICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gTWF0aC5yb3VuZChyZWQgLyB3c3VtKTtcbiAgICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gTWF0aC5yb3VuZChncmVlbiAvIHdzdW0pO1xuICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSBNYXRoLnJvdW5kKGJsdWUgLyB3c3VtKTtcbiAgICAgICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdID0gTWF0aC5yb3VuZChhbHBoYSAvIHdzdW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-gaussian/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-invert/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-invert/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Inverts the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  invert(cb) {\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data[idx] = 255 - this.bitmap.data[idx];\n      this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1];\n      this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4taW52ZXJ0L2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDOztBQUU1QztBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4taW52ZXJ0L2VzL2luZGV4LmpzP2Y2YmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuXG4vKipcbiAqIEludmVydHMgdGhlIGltYWdlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgaW52ZXJ0KGNiKSB7XG4gICAgdGhpcy5zY2FuUXVpZXQoMCwgMCwgdGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHgsIHksIGlkeCkge1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gMjU1IC0gdGhpcy5iaXRtYXAuZGF0YVtpZHhdO1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IDI1NSAtIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV07XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gMjU1IC0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXTtcbiAgICB9KTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-invert/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-mask/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@jimp/plugin-mask/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the horizontal position to blit the image\n * @param {number} y the vertical position to blit the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  mask(src) {\n    let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let cb = arguments.length > 3 ? arguments[3] : undefined;\n    if (!(src instanceof this.constructor)) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"The source must be a Jimp image\", cb);\n    }\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"x and y must be numbers\", cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    const w = this.bitmap.width;\n    const h = this.bitmap.height;\n    const baseImage = this;\n    src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {\n      const destX = x + sx;\n      const destY = y + sy;\n      if (destX >= 0 && destY >= 0 && destX < w && destY < h) {\n        const dstIdx = baseImage.getPixelIndex(destX, destY);\n        const {\n          data\n        } = this.bitmap;\n        const avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;\n        baseImage.bitmap.data[dstIdx + 3] *= avg / 255;\n      }\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tbWFzay9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDs7QUFFeEQ7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGlFQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSxtREFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tbWFzay9lcy9pbmRleC5qcz9jOTNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTm9kZVBhdHRlcm4sIHRocm93RXJyb3IgfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcblxuLyoqXG4gKiBNYXNrcyBhIHNvdXJjZSBpbWFnZSBvbiB0byB0aGlzIGltYWdlIHVzaW5nIGF2ZXJhZ2UgcGl4ZWwgY29sb3VyLiBBIGNvbXBsZXRlbHkgYmxhY2sgcGl4ZWwgb24gdGhlIG1hc2sgd2lsbCB0dXJuIGEgcGl4ZWwgaW4gdGhlIGltYWdlIGNvbXBsZXRlbHkgdHJhbnNwYXJlbnQuXG4gKiBAcGFyYW0ge0ppbXB9IHNyYyB0aGUgc291cmNlIEppbXAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIHRvIGJsaXQgdGhlIGltYWdlXG4gKiBAcGFyYW0ge251bWJlcn0geSB0aGUgdmVydGljYWwgcG9zaXRpb24gdG8gYmxpdCB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gKi9cbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiAoe1xuICBtYXNrKHNyYykge1xuICAgIGxldCB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIGxldCB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIGxldCBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIGlmICghKHNyYyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiVGhlIHNvdXJjZSBtdXN0IGJlIGEgSmltcCBpbWFnZVwiLCBjYik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInggYW5kIHkgbXVzdCBiZSBudW1iZXJzXCIsIGNiKTtcbiAgICB9XG5cbiAgICAvLyByb3VuZCBpbnB1dFxuICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgIGNvbnN0IHcgPSB0aGlzLmJpdG1hcC53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuICAgIGNvbnN0IGJhc2VJbWFnZSA9IHRoaXM7XG4gICAgc3JjLnNjYW5RdWlldCgwLCAwLCBzcmMuYml0bWFwLndpZHRoLCBzcmMuYml0bWFwLmhlaWdodCwgZnVuY3Rpb24gKHN4LCBzeSwgaWR4KSB7XG4gICAgICBjb25zdCBkZXN0WCA9IHggKyBzeDtcbiAgICAgIGNvbnN0IGRlc3RZID0geSArIHN5O1xuICAgICAgaWYgKGRlc3RYID49IDAgJiYgZGVzdFkgPj0gMCAmJiBkZXN0WCA8IHcgJiYgZGVzdFkgPCBoKSB7XG4gICAgICAgIGNvbnN0IGRzdElkeCA9IGJhc2VJbWFnZS5nZXRQaXhlbEluZGV4KGRlc3RYLCBkZXN0WSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0gPSB0aGlzLmJpdG1hcDtcbiAgICAgICAgY29uc3QgYXZnID0gKGRhdGFbaWR4ICsgMF0gKyBkYXRhW2lkeCArIDFdICsgZGF0YVtpZHggKyAyXSkgLyAzO1xuICAgICAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgM10gKj0gYXZnIC8gMjU1O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-mask/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-normalize/es/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@jimp/plugin-normalize/es/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Get an image's histogram\n * @return {object} An object with an array of color occurrence counts for each channel (r,g,b)\n */\nfunction histogram() {\n  const histogram = {\n    r: new Array(256).fill(0),\n    g: new Array(256).fill(0),\n    b: new Array(256).fill(0)\n  };\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, index) {\n    histogram.r[this.bitmap.data[index + 0]]++;\n    histogram.g[this.bitmap.data[index + 1]]++;\n    histogram.b[this.bitmap.data[index + 2]]++;\n  });\n  return histogram;\n}\n\n/**\n * Normalize values\n * @param  {integer} value Pixel channel value.\n * @param  {integer} min   Minimum value for channel\n * @param  {integer} max   Maximum value for channel\n * @return {integer} normalized values\n */\nconst normalize = function (value, min, max) {\n  return (value - min) * 255 / (max - min);\n};\nconst getBounds = function (histogramChannel) {\n  return [histogramChannel.findIndex(value => value > 0), 255 - histogramChannel.slice().reverse().findIndex(value => value > 0)];\n};\n\n/**\n * Normalizes the image\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  normalize(cb) {\n    const h = histogram.call(this);\n\n    // store bounds (minimum and maximum values)\n    const bounds = {\n      r: getBounds(h.r),\n      g: getBounds(h.g),\n      b: getBounds(h.b)\n    };\n\n    // apply value transformations\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      const r = this.bitmap.data[idx + 0];\n      const g = this.bitmap.data[idx + 1];\n      const b = this.bitmap.data[idx + 2];\n      this.bitmap.data[idx + 0] = normalize(r, bounds.r[0], bounds.r[1]);\n      this.bitmap.data[idx + 1] = normalize(g, bounds.g[0], bounds.g[1]);\n      this.bitmap.data[idx + 2] = normalize(b, bounds.b[0], bounds.b[1]);\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tbm9ybWFsaXplL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDOztBQUU1QztBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLE1BQU07QUFDbkI7QUFDQSxpRUFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLEVBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1ub3JtYWxpemUvZXMvaW5kZXguanM/MGU3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05vZGVQYXR0ZXJuIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5cbi8qKlxuICogR2V0IGFuIGltYWdlJ3MgaGlzdG9ncmFtXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIGNvbG9yIG9jY3VycmVuY2UgY291bnRzIGZvciBlYWNoIGNoYW5uZWwgKHIsZyxiKVxuICovXG5mdW5jdGlvbiBoaXN0b2dyYW0oKSB7XG4gIGNvbnN0IGhpc3RvZ3JhbSA9IHtcbiAgICByOiBuZXcgQXJyYXkoMjU2KS5maWxsKDApLFxuICAgIGc6IG5ldyBBcnJheSgyNTYpLmZpbGwoMCksXG4gICAgYjogbmV3IEFycmF5KDI1NikuZmlsbCgwKVxuICB9O1xuICB0aGlzLnNjYW5RdWlldCgwLCAwLCB0aGlzLmJpdG1hcC53aWR0aCwgdGhpcy5iaXRtYXAuaGVpZ2h0LCBmdW5jdGlvbiAoeCwgeSwgaW5kZXgpIHtcbiAgICBoaXN0b2dyYW0uclt0aGlzLmJpdG1hcC5kYXRhW2luZGV4ICsgMF1dKys7XG4gICAgaGlzdG9ncmFtLmdbdGhpcy5iaXRtYXAuZGF0YVtpbmRleCArIDFdXSsrO1xuICAgIGhpc3RvZ3JhbS5iW3RoaXMuYml0bWFwLmRhdGFbaW5kZXggKyAyXV0rKztcbiAgfSk7XG4gIHJldHVybiBoaXN0b2dyYW07XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHZhbHVlc1xuICogQHBhcmFtICB7aW50ZWdlcn0gdmFsdWUgUGl4ZWwgY2hhbm5lbCB2YWx1ZS5cbiAqIEBwYXJhbSAge2ludGVnZXJ9IG1pbiAgIE1pbmltdW0gdmFsdWUgZm9yIGNoYW5uZWxcbiAqIEBwYXJhbSAge2ludGVnZXJ9IG1heCAgIE1heGltdW0gdmFsdWUgZm9yIGNoYW5uZWxcbiAqIEByZXR1cm4ge2ludGVnZXJ9IG5vcm1hbGl6ZWQgdmFsdWVzXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuICh2YWx1ZSAtIG1pbikgKiAyNTUgLyAobWF4IC0gbWluKTtcbn07XG5jb25zdCBnZXRCb3VuZHMgPSBmdW5jdGlvbiAoaGlzdG9ncmFtQ2hhbm5lbCkge1xuICByZXR1cm4gW2hpc3RvZ3JhbUNoYW5uZWwuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID4gMCksIDI1NSAtIGhpc3RvZ3JhbUNoYW5uZWwuc2xpY2UoKS5yZXZlcnNlKCkuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID4gMCldO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBpbWFnZVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgKCgpID0+ICh7XG4gIG5vcm1hbGl6ZShjYikge1xuICAgIGNvbnN0IGggPSBoaXN0b2dyYW0uY2FsbCh0aGlzKTtcblxuICAgIC8vIHN0b3JlIGJvdW5kcyAobWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMpXG4gICAgY29uc3QgYm91bmRzID0ge1xuICAgICAgcjogZ2V0Qm91bmRzKGguciksXG4gICAgICBnOiBnZXRCb3VuZHMoaC5nKSxcbiAgICAgIGI6IGdldEJvdW5kcyhoLmIpXG4gICAgfTtcblxuICAgIC8vIGFwcGx5IHZhbHVlIHRyYW5zZm9ybWF0aW9uc1xuICAgIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDBdO1xuICAgICAgY29uc3QgZyA9IHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV07XG4gICAgICBjb25zdCBiID0gdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMF0gPSBub3JtYWxpemUociwgYm91bmRzLnJbMF0sIGJvdW5kcy5yWzFdKTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSBub3JtYWxpemUoZywgYm91bmRzLmdbMF0sIGJvdW5kcy5nWzFdKTtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSBub3JtYWxpemUoYiwgYm91bmRzLmJbMF0sIGJvdW5kcy5iWzFdKTtcbiAgICB9KTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-normalize/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-print/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/plugin-print/es/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var load_bmfont__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! load-bmfont */ \"(action-browser)/./node_modules/load-bmfont/index.js\");\n/* harmony import */ var load_bmfont__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(load_bmfont__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n/* harmony import */ var _measure_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./measure-text */ \"(action-browser)/./node_modules/@jimp/plugin-print/es/measure-text.js\");\n\n\n\n\nfunction xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {\n  if (alignment === constants.HORIZONTAL_ALIGN_LEFT) {\n    return 0;\n  }\n  if (alignment === constants.HORIZONTAL_ALIGN_CENTER) {\n    return (maxWidth - (0,_measure_text__WEBPACK_IMPORTED_MODULE_3__.measureText)(font, line)) / 2;\n  }\n  return maxWidth - (0,_measure_text__WEBPACK_IMPORTED_MODULE_3__.measureText)(font, line);\n}\nfunction drawCharacter(image, font, x, y, char) {\n  if (char.width > 0 && char.height > 0) {\n    const characterPage = font.pages[char.page];\n    image.blit(characterPage, x + char.xoffset, y + char.yoffset, char.x, char.y, char.width, char.height);\n  }\n  return image;\n}\nfunction printText(font, x, y, text, defaultCharWidth) {\n  for (let i = 0; i < text.length; i++) {\n    let char;\n    if (font.chars[text[i]]) {\n      char = text[i];\n    } else if (/\\s/.test(text[i])) {\n      char = \"\";\n    } else {\n      char = \"?\";\n    }\n    const fontChar = font.chars[char] || {};\n    const fontKerning = font.kernings[char];\n    drawCharacter(this, font, x, y, fontChar || {});\n    const kerning = fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0;\n    x += kerning + (fontChar.xadvance || defaultCharWidth);\n  }\n}\nfunction loadPages(Jimp, dir, pages) {\n  const newPages = pages.map(page => {\n    return Jimp.read(dir + \"/\" + page);\n  });\n  return Promise.all(newPages);\n}\nconst dir = process.env.DIRNAME || `${__dirname}/../`;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  constants: {\n    measureText: _measure_text__WEBPACK_IMPORTED_MODULE_3__.measureText,\n    measureTextHeight: _measure_text__WEBPACK_IMPORTED_MODULE_3__.measureTextHeight,\n    FONT_SANS_8_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt\"),\n    FONT_SANS_10_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt\"),\n    FONT_SANS_12_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt\"),\n    FONT_SANS_14_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt\"),\n    FONT_SANS_16_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt\"),\n    FONT_SANS_32_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt\"),\n    FONT_SANS_64_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt\"),\n    FONT_SANS_128_BLACK: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt\"),\n    FONT_SANS_8_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt\"),\n    FONT_SANS_16_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt\"),\n    FONT_SANS_32_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt\"),\n    FONT_SANS_64_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt\"),\n    FONT_SANS_128_WHITE: path__WEBPACK_IMPORTED_MODULE_0___default().join(dir, \"fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt\"),\n    /**\n     * Loads a bitmap font from a file\n     * @param {string} file the file path of a .fnt file\n     * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded\n     * @returns {Promise} a promise\n     */\n    loadFont(file, cb) {\n      if (typeof file !== \"string\") return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"file must be a string\", cb);\n      return new Promise((resolve, reject) => {\n        cb = cb || function (err, font) {\n          if (err) reject(err);else resolve(font);\n        };\n        load_bmfont__WEBPACK_IMPORTED_MODULE_1___default()(file, (err, font) => {\n          const chars = {};\n          const kernings = {};\n          if (err) {\n            return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, err, cb);\n          }\n          for (let i = 0; i < font.chars.length; i++) {\n            chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];\n          }\n          for (let i = 0; i < font.kernings.length; i++) {\n            const firstString = String.fromCharCode(font.kernings[i].first);\n            kernings[firstString] = kernings[firstString] || {};\n            kernings[firstString][String.fromCharCode(font.kernings[i].second)] = font.kernings[i].amount;\n          }\n          loadPages(this, path__WEBPACK_IMPORTED_MODULE_0___default().dirname(file), font.pages).then(pages => {\n            cb(null, {\n              chars,\n              kernings,\n              pages,\n              common: font.common,\n              info: font.info\n            });\n          });\n        });\n      });\n    }\n  },\n  class: {\n    /**\n     * Draws a text on a image on a given boundary\n     * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command\n     * @param {number} x the x position to start drawing the text\n     * @param {number} y the y position to start drawing the text\n     * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)\n     * @param {number} maxWidth (optional) the boundary width to draw in\n     * @param {number} maxHeight (optional) the boundary height to draw in\n     * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written\n     * @returns {Jimp} this for chaining of methods\n     */\n    print(font, x, y, text, maxWidth, maxHeight, cb) {\n      if (typeof maxWidth === \"function\" && typeof cb === \"undefined\") {\n        cb = maxWidth;\n        maxWidth = Infinity;\n      }\n      if (typeof maxWidth === \"undefined\") {\n        maxWidth = Infinity;\n      }\n      if (typeof maxHeight === \"function\" && typeof cb === \"undefined\") {\n        cb = maxHeight;\n        maxHeight = Infinity;\n      }\n      if (typeof maxHeight === \"undefined\") {\n        maxHeight = Infinity;\n      }\n      if (typeof font !== \"object\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"font must be a Jimp loadFont\", cb);\n      }\n      if (typeof x !== \"number\" || typeof y !== \"number\" || typeof maxWidth !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"x, y and maxWidth must be numbers\", cb);\n      }\n      if (typeof maxWidth !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"maxWidth must be a number\", cb);\n      }\n      if (typeof maxHeight !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_2__.throwError.call(this, \"maxHeight must be a number\", cb);\n      }\n      let alignmentX;\n      let alignmentY;\n      if (typeof text === \"object\" && text.text !== null && text.text !== undefined) {\n        alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;\n        alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;\n        ({\n          text\n        } = text);\n      } else {\n        alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;\n        alignmentY = this.constructor.VERTICAL_ALIGN_TOP;\n        text = text.toString();\n      }\n      if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {\n        y += maxHeight - (0,_measure_text__WEBPACK_IMPORTED_MODULE_3__.measureTextHeight)(font, text, maxWidth);\n      } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {\n        y += maxHeight / 2 - (0,_measure_text__WEBPACK_IMPORTED_MODULE_3__.measureTextHeight)(font, text, maxWidth) / 2;\n      }\n      const defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;\n      const {\n        lines,\n        longestLine\n      } = (0,_measure_text__WEBPACK_IMPORTED_MODULE_3__.splitLines)(font, text, maxWidth);\n      lines.forEach(line => {\n        const lineString = line.join(\" \");\n        const alignmentWidth = xOffsetBasedOnAlignment(this.constructor, font, lineString, maxWidth, alignmentX);\n        printText.call(this, font, x + alignmentWidth, y, lineString, defaultCharWidth);\n        y += font.common.lineHeight;\n      });\n      if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_2__.isNodePattern)(cb)) {\n        cb.call(this, null, this, {\n          x: x + longestLine,\n          y\n        });\n      }\n      return this;\n    }\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcHJpbnQvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3QjtBQUNTO0FBQ3VCO0FBQ29CO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQVc7QUFDbEM7QUFDQSxvQkFBb0IsMERBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hELGlFQUFnQjtBQUNoQjtBQUNBLGVBQWU7QUFDZixxQkFBcUI7QUFDckIsdUJBQXVCLGdEQUFTO0FBQ2hDLHdCQUF3QixnREFBUztBQUNqQyx3QkFBd0IsZ0RBQVM7QUFDakMsd0JBQXdCLGdEQUFTO0FBQ2pDLHdCQUF3QixnREFBUztBQUNqQyx3QkFBd0IsZ0RBQVM7QUFDakMsd0JBQXdCLGdEQUFTO0FBQ2pDLHlCQUF5QixnREFBUztBQUNsQyx1QkFBdUIsZ0RBQVM7QUFDaEMsd0JBQXdCLGdEQUFTO0FBQ2pDLHdCQUF3QixnREFBUztBQUNqQyx3QkFBd0IsZ0RBQVM7QUFDakMseUJBQXlCLGdEQUFTO0FBQ2xDO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLDJDQUEyQyxtREFBVTtBQUNyRDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBVTtBQUM3QjtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbURBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsS0FBSztBQUNwQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0VBQWlCO0FBQzFDLFFBQVE7QUFDUiw2QkFBNkIsZ0VBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEVBQUUseURBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxVQUFVLDBEQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcHJpbnQvZXMvaW5kZXguanM/NTUwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IGJNRm9udCBmcm9tIFwibG9hZC1ibWZvbnRcIjtcbmltcG9ydCB7IGlzTm9kZVBhdHRlcm4sIHRocm93RXJyb3IgfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbmltcG9ydCB7IG1lYXN1cmVUZXh0LCBtZWFzdXJlVGV4dEhlaWdodCwgc3BsaXRMaW5lcyB9IGZyb20gXCIuL21lYXN1cmUtdGV4dFwiO1xuZnVuY3Rpb24geE9mZnNldEJhc2VkT25BbGlnbm1lbnQoY29uc3RhbnRzLCBmb250LCBsaW5lLCBtYXhXaWR0aCwgYWxpZ25tZW50KSB7XG4gIGlmIChhbGlnbm1lbnQgPT09IGNvbnN0YW50cy5IT1JJWk9OVEFMX0FMSUdOX0xFRlQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoYWxpZ25tZW50ID09PSBjb25zdGFudHMuSE9SSVpPTlRBTF9BTElHTl9DRU5URVIpIHtcbiAgICByZXR1cm4gKG1heFdpZHRoIC0gbWVhc3VyZVRleHQoZm9udCwgbGluZSkpIC8gMjtcbiAgfVxuICByZXR1cm4gbWF4V2lkdGggLSBtZWFzdXJlVGV4dChmb250LCBsaW5lKTtcbn1cbmZ1bmN0aW9uIGRyYXdDaGFyYWN0ZXIoaW1hZ2UsIGZvbnQsIHgsIHksIGNoYXIpIHtcbiAgaWYgKGNoYXIud2lkdGggPiAwICYmIGNoYXIuaGVpZ2h0ID4gMCkge1xuICAgIGNvbnN0IGNoYXJhY3RlclBhZ2UgPSBmb250LnBhZ2VzW2NoYXIucGFnZV07XG4gICAgaW1hZ2UuYmxpdChjaGFyYWN0ZXJQYWdlLCB4ICsgY2hhci54b2Zmc2V0LCB5ICsgY2hhci55b2Zmc2V0LCBjaGFyLngsIGNoYXIueSwgY2hhci53aWR0aCwgY2hhci5oZWlnaHQpO1xuICB9XG4gIHJldHVybiBpbWFnZTtcbn1cbmZ1bmN0aW9uIHByaW50VGV4dChmb250LCB4LCB5LCB0ZXh0LCBkZWZhdWx0Q2hhcldpZHRoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGFyO1xuICAgIGlmIChmb250LmNoYXJzW3RleHRbaV1dKSB7XG4gICAgICBjaGFyID0gdGV4dFtpXTtcbiAgICB9IGVsc2UgaWYgKC9cXHMvLnRlc3QodGV4dFtpXSkpIHtcbiAgICAgIGNoYXIgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFyID0gXCI/XCI7XG4gICAgfVxuICAgIGNvbnN0IGZvbnRDaGFyID0gZm9udC5jaGFyc1tjaGFyXSB8fCB7fTtcbiAgICBjb25zdCBmb250S2VybmluZyA9IGZvbnQua2VybmluZ3NbY2hhcl07XG4gICAgZHJhd0NoYXJhY3Rlcih0aGlzLCBmb250LCB4LCB5LCBmb250Q2hhciB8fCB7fSk7XG4gICAgY29uc3Qga2VybmluZyA9IGZvbnRLZXJuaW5nICYmIGZvbnRLZXJuaW5nW3RleHRbaSArIDFdXSA/IGZvbnRLZXJuaW5nW3RleHRbaSArIDFdXSA6IDA7XG4gICAgeCArPSBrZXJuaW5nICsgKGZvbnRDaGFyLnhhZHZhbmNlIHx8IGRlZmF1bHRDaGFyV2lkdGgpO1xuICB9XG59XG5mdW5jdGlvbiBsb2FkUGFnZXMoSmltcCwgZGlyLCBwYWdlcykge1xuICBjb25zdCBuZXdQYWdlcyA9IHBhZ2VzLm1hcChwYWdlID0+IHtcbiAgICByZXR1cm4gSmltcC5yZWFkKGRpciArIFwiL1wiICsgcGFnZSk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwobmV3UGFnZXMpO1xufVxuY29uc3QgZGlyID0gcHJvY2Vzcy5lbnYuRElSTkFNRSB8fCBgJHtfX2Rpcm5hbWV9Ly4uL2A7XG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgY29uc3RhbnRzOiB7XG4gICAgbWVhc3VyZVRleHQsXG4gICAgbWVhc3VyZVRleHRIZWlnaHQsXG4gICAgRk9OVF9TQU5TXzhfQkxBQ0s6IFBhdGguam9pbihkaXIsIFwiZm9udHMvb3Blbi1zYW5zL29wZW4tc2Fucy04LWJsYWNrL29wZW4tc2Fucy04LWJsYWNrLmZudFwiKSxcbiAgICBGT05UX1NBTlNfMTBfQkxBQ0s6IFBhdGguam9pbihkaXIsIFwiZm9udHMvb3Blbi1zYW5zL29wZW4tc2Fucy0xMC1ibGFjay9vcGVuLXNhbnMtMTAtYmxhY2suZm50XCIpLFxuICAgIEZPTlRfU0FOU18xMl9CTEFDSzogUGF0aC5qb2luKGRpciwgXCJmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTEyLWJsYWNrL29wZW4tc2Fucy0xMi1ibGFjay5mbnRcIiksXG4gICAgRk9OVF9TQU5TXzE0X0JMQUNLOiBQYXRoLmpvaW4oZGlyLCBcImZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtMTQtYmxhY2svb3Blbi1zYW5zLTE0LWJsYWNrLmZudFwiKSxcbiAgICBGT05UX1NBTlNfMTZfQkxBQ0s6IFBhdGguam9pbihkaXIsIFwiZm9udHMvb3Blbi1zYW5zL29wZW4tc2Fucy0xNi1ibGFjay9vcGVuLXNhbnMtMTYtYmxhY2suZm50XCIpLFxuICAgIEZPTlRfU0FOU18zMl9CTEFDSzogUGF0aC5qb2luKGRpciwgXCJmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTMyLWJsYWNrL29wZW4tc2Fucy0zMi1ibGFjay5mbnRcIiksXG4gICAgRk9OVF9TQU5TXzY0X0JMQUNLOiBQYXRoLmpvaW4oZGlyLCBcImZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtNjQtYmxhY2svb3Blbi1zYW5zLTY0LWJsYWNrLmZudFwiKSxcbiAgICBGT05UX1NBTlNfMTI4X0JMQUNLOiBQYXRoLmpvaW4oZGlyLCBcImZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtMTI4LWJsYWNrL29wZW4tc2Fucy0xMjgtYmxhY2suZm50XCIpLFxuICAgIEZPTlRfU0FOU184X1dISVRFOiBQYXRoLmpvaW4oZGlyLCBcImZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtOC13aGl0ZS9vcGVuLXNhbnMtOC13aGl0ZS5mbnRcIiksXG4gICAgRk9OVF9TQU5TXzE2X1dISVRFOiBQYXRoLmpvaW4oZGlyLCBcImZvbnRzL29wZW4tc2Fucy9vcGVuLXNhbnMtMTYtd2hpdGUvb3Blbi1zYW5zLTE2LXdoaXRlLmZudFwiKSxcbiAgICBGT05UX1NBTlNfMzJfV0hJVEU6IFBhdGguam9pbihkaXIsIFwiZm9udHMvb3Blbi1zYW5zL29wZW4tc2Fucy0zMi13aGl0ZS9vcGVuLXNhbnMtMzItd2hpdGUuZm50XCIpLFxuICAgIEZPTlRfU0FOU182NF9XSElURTogUGF0aC5qb2luKGRpciwgXCJmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTY0LXdoaXRlL29wZW4tc2Fucy02NC13aGl0ZS5mbnRcIiksXG4gICAgRk9OVF9TQU5TXzEyOF9XSElURTogUGF0aC5qb2luKGRpciwgXCJmb250cy9vcGVuLXNhbnMvb3Blbi1zYW5zLTEyOC13aGl0ZS9vcGVuLXNhbnMtMTI4LXdoaXRlLmZudFwiKSxcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGJpdG1hcCBmb250IGZyb20gYSBmaWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgdGhlIGZpbGUgcGF0aCBvZiBhIC5mbnQgZmlsZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb250IGlzIGxvYWRlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2VcbiAgICAgKi9cbiAgICBsb2FkRm9udChmaWxlLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBmaWxlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiZmlsZSBtdXN0IGJlIGEgc3RyaW5nXCIsIGNiKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNiID0gY2IgfHwgZnVuY3Rpb24gKGVyciwgZm9udCkge1xuICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO2Vsc2UgcmVzb2x2ZShmb250KTtcbiAgICAgICAgfTtcbiAgICAgICAgYk1Gb250KGZpbGUsIChlcnIsIGZvbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFycyA9IHt9O1xuICAgICAgICAgIGNvbnN0IGtlcm5pbmdzID0ge307XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb250LmNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGFyc1tTdHJpbmcuZnJvbUNoYXJDb2RlKGZvbnQuY2hhcnNbaV0uaWQpXSA9IGZvbnQuY2hhcnNbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9udC5rZXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGZvbnQua2VybmluZ3NbaV0uZmlyc3QpO1xuICAgICAgICAgICAga2VybmluZ3NbZmlyc3RTdHJpbmddID0ga2VybmluZ3NbZmlyc3RTdHJpbmddIHx8IHt9O1xuICAgICAgICAgICAga2VybmluZ3NbZmlyc3RTdHJpbmddW1N0cmluZy5mcm9tQ2hhckNvZGUoZm9udC5rZXJuaW5nc1tpXS5zZWNvbmQpXSA9IGZvbnQua2VybmluZ3NbaV0uYW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2FkUGFnZXModGhpcywgUGF0aC5kaXJuYW1lKGZpbGUpLCBmb250LnBhZ2VzKS50aGVuKHBhZ2VzID0+IHtcbiAgICAgICAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgICAgICAgY2hhcnMsXG4gICAgICAgICAgICAgIGtlcm5pbmdzLFxuICAgICAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICAgICAgY29tbW9uOiBmb250LmNvbW1vbixcbiAgICAgICAgICAgICAgaW5mbzogZm9udC5pbmZvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNsYXNzOiB7XG4gICAgLyoqXG4gICAgICogRHJhd3MgYSB0ZXh0IG9uIGEgaW1hZ2Ugb24gYSBnaXZlbiBib3VuZGFyeVxuICAgICAqIEBwYXJhbSB7SmltcH0gZm9udCBhIGJpdG1hcCBmb250IGxvYWRlZCBmcm9tIGBKaW1wLmxvYWRGb250YCBjb21tYW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggcG9zaXRpb24gdG8gc3RhcnQgZHJhd2luZyB0aGUgdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSB5IHBvc2l0aW9uIHRvIHN0YXJ0IGRyYXdpbmcgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge2FueX0gdGV4dCB0aGUgdGV4dCB0byBkcmF3IChzdHJpbmcgb3Igb2JqZWN0IHdpdGggYHRleHRgLCBgYWxpZ25tZW50WGAsIGFuZC9vciBgYWxpZ25tZW50WWApXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIChvcHRpb25hbCkgdGhlIGJvdW5kYXJ5IHdpZHRoIHRvIGRyYXcgaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IChvcHRpb25hbCkgdGhlIGJvdW5kYXJ5IGhlaWdodCB0byBkcmF3IGluXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHRleHQgaXMgd3JpdHRlblxuICAgICAqIEByZXR1cm5zIHtKaW1wfSB0aGlzIGZvciBjaGFpbmluZyBvZiBtZXRob2RzXG4gICAgICovXG4gICAgcHJpbnQoZm9udCwgeCwgeSwgdGV4dCwgbWF4V2lkdGgsIG1heEhlaWdodCwgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgbWF4V2lkdGggPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY2IgPSBtYXhXaWR0aDtcbiAgICAgICAgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbWF4V2lkdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbWF4SGVpZ2h0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNiID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNiID0gbWF4SGVpZ2h0O1xuICAgICAgICBtYXhIZWlnaHQgPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbWF4SGVpZ2h0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG1heEhlaWdodCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmb250ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJmb250IG11c3QgYmUgYSBKaW1wIGxvYWRGb250XCIsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgeCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgbWF4V2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIngsIHkgYW5kIG1heFdpZHRoIG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG1heFdpZHRoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJtYXhXaWR0aCBtdXN0IGJlIGEgbnVtYmVyXCIsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbWF4SGVpZ2h0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJtYXhIZWlnaHQgbXVzdCBiZSBhIG51bWJlclwiLCBjYik7XG4gICAgICB9XG4gICAgICBsZXQgYWxpZ25tZW50WDtcbiAgICAgIGxldCBhbGlnbm1lbnRZO1xuICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSBcIm9iamVjdFwiICYmIHRleHQudGV4dCAhPT0gbnVsbCAmJiB0ZXh0LnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbGlnbm1lbnRYID0gdGV4dC5hbGlnbm1lbnRYIHx8IHRoaXMuY29uc3RydWN0b3IuSE9SSVpPTlRBTF9BTElHTl9MRUZUO1xuICAgICAgICBhbGlnbm1lbnRZID0gdGV4dC5hbGlnbm1lbnRZIHx8IHRoaXMuY29uc3RydWN0b3IuVkVSVElDQUxfQUxJR05fVE9QO1xuICAgICAgICAoe1xuICAgICAgICAgIHRleHRcbiAgICAgICAgfSA9IHRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ25tZW50WCA9IHRoaXMuY29uc3RydWN0b3IuSE9SSVpPTlRBTF9BTElHTl9MRUZUO1xuICAgICAgICBhbGlnbm1lbnRZID0gdGhpcy5jb25zdHJ1Y3Rvci5WRVJUSUNBTF9BTElHTl9UT1A7XG4gICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAobWF4SGVpZ2h0ICE9PSBJbmZpbml0eSAmJiBhbGlnbm1lbnRZID09PSB0aGlzLmNvbnN0cnVjdG9yLlZFUlRJQ0FMX0FMSUdOX0JPVFRPTSkge1xuICAgICAgICB5ICs9IG1heEhlaWdodCAtIG1lYXN1cmVUZXh0SGVpZ2h0KGZvbnQsIHRleHQsIG1heFdpZHRoKTtcbiAgICAgIH0gZWxzZSBpZiAobWF4SGVpZ2h0ICE9PSBJbmZpbml0eSAmJiBhbGlnbm1lbnRZID09PSB0aGlzLmNvbnN0cnVjdG9yLlZFUlRJQ0FMX0FMSUdOX01JRERMRSkge1xuICAgICAgICB5ICs9IG1heEhlaWdodCAvIDIgLSBtZWFzdXJlVGV4dEhlaWdodChmb250LCB0ZXh0LCBtYXhXaWR0aCkgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVmYXVsdENoYXJXaWR0aCA9IE9iamVjdC5lbnRyaWVzKGZvbnQuY2hhcnMpWzBdWzFdLnhhZHZhbmNlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgbG9uZ2VzdExpbmVcbiAgICAgIH0gPSBzcGxpdExpbmVzKGZvbnQsIHRleHQsIG1heFdpZHRoKTtcbiAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVTdHJpbmcgPSBsaW5lLmpvaW4oXCIgXCIpO1xuICAgICAgICBjb25zdCBhbGlnbm1lbnRXaWR0aCA9IHhPZmZzZXRCYXNlZE9uQWxpZ25tZW50KHRoaXMuY29uc3RydWN0b3IsIGZvbnQsIGxpbmVTdHJpbmcsIG1heFdpZHRoLCBhbGlnbm1lbnRYKTtcbiAgICAgICAgcHJpbnRUZXh0LmNhbGwodGhpcywgZm9udCwgeCArIGFsaWdubWVudFdpZHRoLCB5LCBsaW5lU3RyaW5nLCBkZWZhdWx0Q2hhcldpZHRoKTtcbiAgICAgICAgeSArPSBmb250LmNvbW1vbi5saW5lSGVpZ2h0O1xuICAgICAgfSk7XG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzLCB7XG4gICAgICAgICAgeDogeCArIGxvbmdlc3RMaW5lLFxuICAgICAgICAgIHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-print/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-print/es/measure-text.js":
/*!************************************************************!*\
  !*** ./node_modules/@jimp/plugin-print/es/measure-text.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   measureText: () => (/* binding */ measureText),\n/* harmony export */   measureTextHeight: () => (/* binding */ measureTextHeight),\n/* harmony export */   splitLines: () => (/* binding */ splitLines)\n/* harmony export */ });\nfunction measureText(font, text) {\n  let x = 0;\n  for (let i = 0; i < text.length; i++) {\n    if (font.chars[text[i]]) {\n      const kerning = font.kernings[text[i]] && font.kernings[text[i]][text[i + 1]] ? font.kernings[text[i]][text[i + 1]] : 0;\n      x += (font.chars[text[i]].xadvance || 0) + kerning;\n    }\n  }\n  return x;\n}\nfunction splitLines(font, text, maxWidth) {\n  const words = text.replace(/[\\r\\n]+/g, \" \\n\").split(\" \");\n  const lines = [];\n  let currentLine = [];\n  let longestLine = 0;\n  words.forEach(word => {\n    const line = [...currentLine, word].join(\" \");\n    const length = measureText(font, line);\n    if (length <= maxWidth && !word.includes(\"\\n\")) {\n      if (length > longestLine) {\n        longestLine = length;\n      }\n      currentLine.push(word);\n    } else {\n      lines.push(currentLine);\n      currentLine = [word.replace(\"\\n\", \"\")];\n    }\n  });\n  lines.push(currentLine);\n  return {\n    lines,\n    longestLine\n  };\n}\nfunction measureTextHeight(font, text, maxWidth) {\n  const {\n    lines\n  } = splitLines(font, text, maxWidth);\n  return lines.length * font.common.lineHeight;\n}\n//# sourceMappingURL=measure-text.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcHJpbnQvZXMvbWVhc3VyZS10ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPO0FBQ1A7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcHJpbnQvZXMvbWVhc3VyZS10ZXh0LmpzP2JlMTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0KGZvbnQsIHRleHQpIHtcbiAgbGV0IHggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZm9udC5jaGFyc1t0ZXh0W2ldXSkge1xuICAgICAgY29uc3Qga2VybmluZyA9IGZvbnQua2VybmluZ3NbdGV4dFtpXV0gJiYgZm9udC5rZXJuaW5nc1t0ZXh0W2ldXVt0ZXh0W2kgKyAxXV0gPyBmb250Lmtlcm5pbmdzW3RleHRbaV1dW3RleHRbaSArIDFdXSA6IDA7XG4gICAgICB4ICs9IChmb250LmNoYXJzW3RleHRbaV1dLnhhZHZhbmNlIHx8IDApICsga2VybmluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRMaW5lcyhmb250LCB0ZXh0LCBtYXhXaWR0aCkge1xuICBjb25zdCB3b3JkcyA9IHRleHQucmVwbGFjZSgvW1xcclxcbl0rL2csIFwiIFxcblwiKS5zcGxpdChcIiBcIik7XG4gIGNvbnN0IGxpbmVzID0gW107XG4gIGxldCBjdXJyZW50TGluZSA9IFtdO1xuICBsZXQgbG9uZ2VzdExpbmUgPSAwO1xuICB3b3Jkcy5mb3JFYWNoKHdvcmQgPT4ge1xuICAgIGNvbnN0IGxpbmUgPSBbLi4uY3VycmVudExpbmUsIHdvcmRdLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IGxlbmd0aCA9IG1lYXN1cmVUZXh0KGZvbnQsIGxpbmUpO1xuICAgIGlmIChsZW5ndGggPD0gbWF4V2lkdGggJiYgIXdvcmQuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIGlmIChsZW5ndGggPiBsb25nZXN0TGluZSkge1xuICAgICAgICBsb25nZXN0TGluZSA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRMaW5lLnB1c2god29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgY3VycmVudExpbmUgPSBbd29yZC5yZXBsYWNlKFwiXFxuXCIsIFwiXCIpXTtcbiAgICB9XG4gIH0pO1xuICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgcmV0dXJuIHtcbiAgICBsaW5lcyxcbiAgICBsb25nZXN0TGluZVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0SGVpZ2h0KGZvbnQsIHRleHQsIG1heFdpZHRoKSB7XG4gIGNvbnN0IHtcbiAgICBsaW5lc1xuICB9ID0gc3BsaXRMaW5lcyhmb250LCB0ZXh0LCBtYXhXaWR0aCk7XG4gIHJldHVybiBsaW5lcy5sZW5ndGggKiBmb250LmNvbW1vbi5saW5lSGVpZ2h0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVhc3VyZS10ZXh0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-print/es/measure-text.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-resize/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-resize/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n/* harmony import */ var _modules_resize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/resize */ \"(action-browser)/./node_modules/@jimp/plugin-resize/es/modules/resize.js\");\n/* harmony import */ var _modules_resize2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/resize2 */ \"(action-browser)/./node_modules/@jimp/plugin-resize/es/modules/resize2.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  constants: {\n    RESIZE_NEAREST_NEIGHBOR: \"nearestNeighbor\",\n    RESIZE_BILINEAR: \"bilinearInterpolation\",\n    RESIZE_BICUBIC: \"bicubicInterpolation\",\n    RESIZE_HERMITE: \"hermiteInterpolation\",\n    RESIZE_BEZIER: \"bezierInterpolation\"\n  },\n  class: {\n    /**\n     * Resizes the image to a set width and height using a 2-pass bilinear algorithm\n     * @param {number} w the width to resize the image to (or Jimp.AUTO)\n     * @param {number} h the height to resize the image to (or Jimp.AUTO)\n     * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    resize(w, h, mode, cb) {\n      if (typeof w !== \"number\" || typeof h !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"w and h must be numbers\", cb);\n      }\n      if (typeof mode === \"function\" && typeof cb === \"undefined\") {\n        cb = mode;\n        mode = null;\n      }\n      if (w === this.constructor.AUTO && h === this.constructor.AUTO) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"w and h cannot both be set to auto\", cb);\n      }\n      if (w === this.constructor.AUTO) {\n        w = this.bitmap.width * (h / this.bitmap.height);\n      }\n      if (h === this.constructor.AUTO) {\n        h = this.bitmap.height * (w / this.bitmap.width);\n      }\n      if (w < 0 || h < 0) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"w and h must be positive numbers\", cb);\n      }\n\n      // round inputs\n      w = Math.round(w) || 1;\n      h = Math.round(h) || 1;\n      if (typeof _modules_resize2__WEBPACK_IMPORTED_MODULE_2__[\"default\"][mode] === \"function\") {\n        const dst = {\n          data: Buffer.alloc(w * h * 4),\n          width: w,\n          height: h\n        };\n        _modules_resize2__WEBPACK_IMPORTED_MODULE_2__[\"default\"][mode](this.bitmap, dst);\n        this.bitmap = dst;\n      } else {\n        const image = this;\n        const resize = new _modules_resize__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.bitmap.width, this.bitmap.height, w, h, true, true, buffer => {\n          image.bitmap.data = Buffer.from(buffer);\n          image.bitmap.width = w;\n          image.bitmap.height = h;\n        });\n        resize.resize(this.bitmap.data);\n      }\n      if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    }\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcmVzaXplL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0Q7QUFDbEI7QUFDRTtBQUN4QyxpRUFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQU87QUFDZjtBQUNBLFFBQVE7QUFDUjtBQUNBLDJCQUEyQix1REFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVUsMERBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcmVzaXplL2VzL2luZGV4LmpzPzU5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdGhyb3dFcnJvciwgaXNOb2RlUGF0dGVybiB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuaW1wb3J0IFJlc2l6ZSBmcm9tIFwiLi9tb2R1bGVzL3Jlc2l6ZVwiO1xuaW1wb3J0IFJlc2l6ZTIgZnJvbSBcIi4vbW9kdWxlcy9yZXNpemUyXCI7XG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgY29uc3RhbnRzOiB7XG4gICAgUkVTSVpFX05FQVJFU1RfTkVJR0hCT1I6IFwibmVhcmVzdE5laWdoYm9yXCIsXG4gICAgUkVTSVpFX0JJTElORUFSOiBcImJpbGluZWFySW50ZXJwb2xhdGlvblwiLFxuICAgIFJFU0laRV9CSUNVQklDOiBcImJpY3ViaWNJbnRlcnBvbGF0aW9uXCIsXG4gICAgUkVTSVpFX0hFUk1JVEU6IFwiaGVybWl0ZUludGVycG9sYXRpb25cIixcbiAgICBSRVNJWkVfQkVaSUVSOiBcImJlemllckludGVycG9sYXRpb25cIlxuICB9LFxuICBjbGFzczoge1xuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGltYWdlIHRvIGEgc2V0IHdpZHRoIGFuZCBoZWlnaHQgdXNpbmcgYSAyLXBhc3MgYmlsaW5lYXIgYWxnb3JpdGhtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgdGhlIHdpZHRoIHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gKG9yIEppbXAuQVVUTylcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaCB0aGUgaGVpZ2h0IHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gKG9yIEppbXAuQVVUTylcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAob3B0aW9uYWwpIGEgc2NhbGluZyBtZXRob2QgKGUuZy4gSmltcC5SRVNJWkVfQkVaSUVSKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIHJlc2l6ZSh3LCBoLCBtb2RlLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiB3ICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ3IGFuZCBoIG11c3QgYmUgbnVtYmVyc1wiLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG1vZGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY2IgPSBtb2RlO1xuICAgICAgICBtb2RlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh3ID09PSB0aGlzLmNvbnN0cnVjdG9yLkFVVE8gJiYgaCA9PT0gdGhpcy5jb25zdHJ1Y3Rvci5BVVRPKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJ3IGFuZCBoIGNhbm5vdCBib3RoIGJlIHNldCB0byBhdXRvXCIsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmICh3ID09PSB0aGlzLmNvbnN0cnVjdG9yLkFVVE8pIHtcbiAgICAgICAgdyA9IHRoaXMuYml0bWFwLndpZHRoICogKGggLyB0aGlzLmJpdG1hcC5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGggPT09IHRoaXMuY29uc3RydWN0b3IuQVVUTykge1xuICAgICAgICBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0ICogKHcgLyB0aGlzLmJpdG1hcC53aWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodyA8IDAgfHwgaCA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIncgYW5kIGggbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzXCIsIGNiKTtcbiAgICAgIH1cblxuICAgICAgLy8gcm91bmQgaW5wdXRzXG4gICAgICB3ID0gTWF0aC5yb3VuZCh3KSB8fCAxO1xuICAgICAgaCA9IE1hdGgucm91bmQoaCkgfHwgMTtcbiAgICAgIGlmICh0eXBlb2YgUmVzaXplMlttb2RlXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGRzdCA9IHtcbiAgICAgICAgICBkYXRhOiBCdWZmZXIuYWxsb2ModyAqIGggKiA0KSxcbiAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgfTtcbiAgICAgICAgUmVzaXplMlttb2RlXSh0aGlzLmJpdG1hcCwgZHN0KTtcbiAgICAgICAgdGhpcy5iaXRtYXAgPSBkc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9IG5ldyBSZXNpemUodGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgdywgaCwgdHJ1ZSwgdHJ1ZSwgYnVmZmVyID0+IHtcbiAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YSA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG4gICAgICAgICAgaW1hZ2UuYml0bWFwLndpZHRoID0gdztcbiAgICAgICAgICBpbWFnZS5iaXRtYXAuaGVpZ2h0ID0gaDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2l6ZS5yZXNpemUodGhpcy5iaXRtYXAuZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-resize/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-resize/es/modules/resize.js":
/*!***************************************************************!*\
  !*** ./node_modules/@jimp/plugin-resize/es/modules/resize.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// JavaScript Image Resizer (c) 2012 - Grant Galitz\n// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4\n\nfunction Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {\n  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);\n  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);\n  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);\n  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);\n  this.colorChannels = blendAlpha ? 4 : 3;\n  this.interpolationPass = Boolean(interpolationPass);\n  this.resizeCallback = typeof resizeCallback === \"function\" ? resizeCallback : function () {};\n  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;\n  this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;\n  this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;\n  this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;\n  this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;\n  this.initialize();\n}\nResize.prototype.initialize = function () {\n  // Perform some checks:\n  if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {\n    this.configurePasses();\n  } else {\n    throw new Error(\"Invalid settings specified for the resizer.\");\n  }\n};\nResize.prototype.configurePasses = function () {\n  if (this.widthOriginal === this.targetWidth) {\n    // Bypass the width resizer pass:\n    this.resizeWidth = this.bypassResizer;\n  } else {\n    // Setup the width resizer pass:\n    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;\n    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {\n      this.initializeFirstPassBuffers(true);\n      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;\n    } else {\n      this.initializeFirstPassBuffers(false);\n      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;\n    }\n  }\n  if (this.heightOriginal === this.targetHeight) {\n    // Bypass the height resizer pass:\n    this.resizeHeight = this.bypassResizer;\n  } else {\n    // Setup the height resizer pass:\n    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;\n    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {\n      this.initializeSecondPassBuffers(true);\n      this.resizeHeight = this.resizeHeightInterpolated;\n    } else {\n      this.initializeSecondPassBuffers(false);\n      this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;\n    }\n  }\n};\nResize.prototype._resizeWidthInterpolatedRGBChannels = function (buffer, fourthChannel) {\n  const channelsNum = fourthChannel ? 4 : 3;\n  const ratioWeight = this.ratioWeightWidthPass;\n  const outputBuffer = this.widthBuffer;\n  let weight = 0;\n  let finalOffset = 0;\n  let pixelOffset = 0;\n  let firstWeight = 0;\n  let secondWeight = 0;\n  let targetPosition;\n\n  // Handle for only one interpolation input being valid for start calculation:\n  for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {\n    for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  }\n\n  // Adjust for overshoot of the last pass's counter:\n  weight -= 1 / 3;\n  let interpolationWidthSourceReadStop;\n  for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight;\n    // Interpolate:\n    for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;\n    }\n  }\n\n  // Handle for only one interpolation input being valid for end calculation:\n  for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {\n    for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  }\n  return outputBuffer;\n};\nResize.prototype._resizeWidthRGBChannels = function (buffer, fourthChannel) {\n  const channelsNum = fourthChannel ? 4 : 3;\n  const ratioWeight = this.ratioWeightWidthPass;\n  const ratioWeightDivisor = 1 / ratioWeight;\n  const nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;\n  const nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;\n  const output = this.outputWidthWorkBench;\n  const outputBuffer = this.widthBuffer;\n  const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;\n  let weight = 0;\n  let amountToNext = 0;\n  let actualPosition = 0;\n  let currentPosition = 0;\n  let line = 0;\n  let pixelOffset = 0;\n  let outputOffset = 0;\n  let multiplier = 1;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let a = 0;\n  do {\n    for (line = 0; line < this.originalHeightMultipliedByChannels;) {\n      output[line++] = 0;\n      output[line++] = 0;\n      output[line++] = 0;\n      if (fourthChannel) {\n        output[line++] = 0;\n        trustworthyColorsCount[line / channelsNum - 1] = 0;\n      }\n    }\n    weight = ratioWeight;\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n      for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {\n        r = buffer[pixelOffset];\n        g = buffer[++pixelOffset];\n        b = buffer[++pixelOffset];\n        a = fourthChannel ? buffer[++pixelOffset] : 255;\n        // Ignore RGB values if pixel is completely transparent\n        output[line++] += (a ? r : 0) * multiplier;\n        output[line++] += (a ? g : 0) * multiplier;\n        output[line++] += (a ? b : 0) * multiplier;\n        if (fourthChannel) {\n          output[line++] += a * multiplier;\n          trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;\n        }\n      }\n      if (weight >= amountToNext) {\n        actualPosition += channelsNum;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);\n    for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {\n      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;\n      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;\n      outputBuffer[pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      if (fourthChannel) outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;\n    }\n    outputOffset += channelsNum;\n  } while (outputOffset < this.targetWidthMultipliedByChannels);\n  return outputBuffer;\n};\nResize.prototype._resizeHeightRGBChannels = function (buffer, fourthChannel) {\n  const ratioWeight = this.ratioWeightHeightPass;\n  const ratioWeightDivisor = 1 / ratioWeight;\n  const output = this.outputHeightWorkBench;\n  const outputBuffer = this.heightBuffer;\n  const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;\n  let weight = 0;\n  let amountToNext = 0;\n  let actualPosition = 0;\n  let currentPosition = 0;\n  let pixelOffset = 0;\n  let outputOffset = 0;\n  let caret = 0;\n  let multiplier = 1;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let a = 0;\n  do {\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n      if (fourthChannel) {\n        output[pixelOffset++] = 0;\n        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;\n      }\n    }\n    weight = ratioWeight;\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n      caret = actualPosition;\n      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n        r = buffer[caret++];\n        g = buffer[caret++];\n        b = buffer[caret++];\n        a = fourthChannel ? buffer[caret++] : 255;\n        // Ignore RGB values if pixel is completely transparent\n        output[pixelOffset++] += (a ? r : 0) * multiplier;\n        output[pixelOffset++] += (a ? g : 0) * multiplier;\n        output[pixelOffset++] += (a ? b : 0) * multiplier;\n        if (fourthChannel) {\n          output[pixelOffset++] += a * multiplier;\n          trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;\n        }\n      }\n      if (weight >= amountToNext) {\n        actualPosition = caret;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (weight > 0 && actualPosition < this.widthPassResultSize);\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;\n      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n      if (fourthChannel) {\n        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n      }\n    }\n  } while (outputOffset < this.finalResultSize);\n  return outputBuffer;\n};\nResize.prototype.resizeWidthInterpolatedRGB = function (buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, false);\n};\nResize.prototype.resizeWidthInterpolatedRGBA = function (buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, true);\n};\nResize.prototype.resizeWidthRGB = function (buffer) {\n  return this._resizeWidthRGBChannels(buffer, false);\n};\nResize.prototype.resizeWidthRGBA = function (buffer) {\n  return this._resizeWidthRGBChannels(buffer, true);\n};\nResize.prototype.resizeHeightInterpolated = function (buffer) {\n  const ratioWeight = this.ratioWeightHeightPass;\n  const outputBuffer = this.heightBuffer;\n  let weight = 0;\n  let finalOffset = 0;\n  let pixelOffset = 0;\n  let pixelOffsetAccumulated = 0;\n  let pixelOffsetAccumulated2 = 0;\n  let firstWeight = 0;\n  let secondWeight = 0;\n  let interpolationHeightSourceReadStop;\n\n  // Handle for only one interpolation input being valid for start calculation:\n  for (; weight < 1 / 3; weight += ratioWeight) {\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);\n    }\n  }\n\n  // Adjust for overshoot of the last pass's counter:\n  weight -= 1 / 3;\n  for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight;\n    // Interpolate:\n    pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;\n    pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);\n    }\n  }\n\n  // Handle for only one interpolation input being valid for end calculation:\n  while (finalOffset < this.finalResultSize) {\n    for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);\n    }\n  }\n  return outputBuffer;\n};\nResize.prototype.resizeHeightRGB = function (buffer) {\n  return this._resizeHeightRGBChannels(buffer, false);\n};\nResize.prototype.resizeHeightRGBA = function (buffer) {\n  return this._resizeHeightRGBChannels(buffer, true);\n};\nResize.prototype.resize = function (buffer) {\n  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));\n};\nResize.prototype.bypassResizer = function (buffer) {\n  // Just return the buffer passed:\n  return buffer;\n};\nResize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {\n  // Initialize the internal width pass buffers:\n  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);\n  if (!BILINEARAlgo) {\n    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);\n    if (this.colorChannels > 3) {\n      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);\n    }\n  }\n};\nResize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {\n  // Initialize the internal height pass buffers:\n  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);\n  if (!BILINEARAlgo) {\n    this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);\n    if (this.colorChannels > 3) {\n      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);\n    }\n  }\n};\nResize.prototype.generateFloatBuffer = function (bufferLength) {\n  // Generate a float32 typed array buffer:\n  try {\n    return new Float32Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\nResize.prototype.generateFloat64Buffer = function (bufferLength) {\n  // Generate a float64 typed array buffer:\n  try {\n    return new Float64Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\nResize.prototype.generateUint8Buffer = function (bufferLength) {\n  // Generate a uint8 typed array buffer:\n  try {\n    return new Uint8Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Resize);\n//# sourceMappingURL=resize.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcmVzaXplL2VzL21vZHVsZXMvcmVzaXplLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDLHdEQUF3RCx3Q0FBd0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwyQ0FBMkM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsd0NBQXdDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdHQUFnRyx1REFBdUQ7QUFDdkosdUZBQXVGLHdDQUF3QztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQStDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnREFBZ0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0NBQStDLGdEQUFnRDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBbUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQW1EO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQixtREFBbUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekIsMEJBQTBCLG1EQUFtRDtBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRSw0Q0FBNEM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFvRDtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZIQUE2SCxvREFBb0Q7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yZXNpemUvZXMvbW9kdWxlcy9yZXNpemUuanM/MGY4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBKYXZhU2NyaXB0IEltYWdlIFJlc2l6ZXIgKGMpIDIwMTIgLSBHcmFudCBHYWxpdHpcbi8vIFJlbGVhc2VkIHRvIHB1YmxpYyBkb21haW4gMjkgSnVseSAyMDEzOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhbnRnYWxpdHovSlMtSW1hZ2UtUmVzaXplci9pc3N1ZXMvNFxuXG5mdW5jdGlvbiBSZXNpemUod2lkdGhPcmlnaW5hbCwgaGVpZ2h0T3JpZ2luYWwsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIGJsZW5kQWxwaGEsIGludGVycG9sYXRpb25QYXNzLCByZXNpemVDYWxsYmFjaykge1xuICB0aGlzLndpZHRoT3JpZ2luYWwgPSBNYXRoLmFicyhNYXRoLmZsb29yKHdpZHRoT3JpZ2luYWwpIHx8IDApO1xuICB0aGlzLmhlaWdodE9yaWdpbmFsID0gTWF0aC5hYnMoTWF0aC5mbG9vcihoZWlnaHRPcmlnaW5hbCkgfHwgMCk7XG4gIHRoaXMudGFyZ2V0V2lkdGggPSBNYXRoLmFicyhNYXRoLmZsb29yKHRhcmdldFdpZHRoKSB8fCAwKTtcbiAgdGhpcy50YXJnZXRIZWlnaHQgPSBNYXRoLmFicyhNYXRoLmZsb29yKHRhcmdldEhlaWdodCkgfHwgMCk7XG4gIHRoaXMuY29sb3JDaGFubmVscyA9IGJsZW5kQWxwaGEgPyA0IDogMztcbiAgdGhpcy5pbnRlcnBvbGF0aW9uUGFzcyA9IEJvb2xlYW4oaW50ZXJwb2xhdGlvblBhc3MpO1xuICB0aGlzLnJlc2l6ZUNhbGxiYWNrID0gdHlwZW9mIHJlc2l6ZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyByZXNpemVDYWxsYmFjayA6IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMgPSB0aGlzLnRhcmdldFdpZHRoICogdGhpcy5jb2xvckNoYW5uZWxzO1xuICB0aGlzLm9yaWdpbmFsV2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyA9IHRoaXMud2lkdGhPcmlnaW5hbCAqIHRoaXMuY29sb3JDaGFubmVscztcbiAgdGhpcy5vcmlnaW5hbEhlaWdodE11bHRpcGxpZWRCeUNoYW5uZWxzID0gdGhpcy5oZWlnaHRPcmlnaW5hbCAqIHRoaXMuY29sb3JDaGFubmVscztcbiAgdGhpcy53aWR0aFBhc3NSZXN1bHRTaXplID0gdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzICogdGhpcy5oZWlnaHRPcmlnaW5hbDtcbiAgdGhpcy5maW5hbFJlc3VsdFNpemUgPSB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMgKiB0aGlzLnRhcmdldEhlaWdodDtcbiAgdGhpcy5pbml0aWFsaXplKCk7XG59XG5SZXNpemUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFBlcmZvcm0gc29tZSBjaGVja3M6XG4gIGlmICh0aGlzLndpZHRoT3JpZ2luYWwgPiAwICYmIHRoaXMuaGVpZ2h0T3JpZ2luYWwgPiAwICYmIHRoaXMudGFyZ2V0V2lkdGggPiAwICYmIHRoaXMudGFyZ2V0SGVpZ2h0ID4gMCkge1xuICAgIHRoaXMuY29uZmlndXJlUGFzc2VzKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZXR0aW5ncyBzcGVjaWZpZWQgZm9yIHRoZSByZXNpemVyLlwiKTtcbiAgfVxufTtcblJlc2l6ZS5wcm90b3R5cGUuY29uZmlndXJlUGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy53aWR0aE9yaWdpbmFsID09PSB0aGlzLnRhcmdldFdpZHRoKSB7XG4gICAgLy8gQnlwYXNzIHRoZSB3aWR0aCByZXNpemVyIHBhc3M6XG4gICAgdGhpcy5yZXNpemVXaWR0aCA9IHRoaXMuYnlwYXNzUmVzaXplcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBTZXR1cCB0aGUgd2lkdGggcmVzaXplciBwYXNzOlxuICAgIHRoaXMucmF0aW9XZWlnaHRXaWR0aFBhc3MgPSB0aGlzLndpZHRoT3JpZ2luYWwgLyB0aGlzLnRhcmdldFdpZHRoO1xuICAgIGlmICh0aGlzLnJhdGlvV2VpZ2h0V2lkdGhQYXNzIDwgMSAmJiB0aGlzLmludGVycG9sYXRpb25QYXNzKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVGaXJzdFBhc3NCdWZmZXJzKHRydWUpO1xuICAgICAgdGhpcy5yZXNpemVXaWR0aCA9IHRoaXMuY29sb3JDaGFubmVscyA9PT0gNCA/IHRoaXMucmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0JBIDogdGhpcy5yZXNpemVXaWR0aEludGVycG9sYXRlZFJHQjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0aWFsaXplRmlyc3RQYXNzQnVmZmVycyhmYWxzZSk7XG4gICAgICB0aGlzLnJlc2l6ZVdpZHRoID0gdGhpcy5jb2xvckNoYW5uZWxzID09PSA0ID8gdGhpcy5yZXNpemVXaWR0aFJHQkEgOiB0aGlzLnJlc2l6ZVdpZHRoUkdCO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5oZWlnaHRPcmlnaW5hbCA9PT0gdGhpcy50YXJnZXRIZWlnaHQpIHtcbiAgICAvLyBCeXBhc3MgdGhlIGhlaWdodCByZXNpemVyIHBhc3M6XG4gICAgdGhpcy5yZXNpemVIZWlnaHQgPSB0aGlzLmJ5cGFzc1Jlc2l6ZXI7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2V0dXAgdGhlIGhlaWdodCByZXNpemVyIHBhc3M6XG4gICAgdGhpcy5yYXRpb1dlaWdodEhlaWdodFBhc3MgPSB0aGlzLmhlaWdodE9yaWdpbmFsIC8gdGhpcy50YXJnZXRIZWlnaHQ7XG4gICAgaWYgKHRoaXMucmF0aW9XZWlnaHRIZWlnaHRQYXNzIDwgMSAmJiB0aGlzLmludGVycG9sYXRpb25QYXNzKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVTZWNvbmRQYXNzQnVmZmVycyh0cnVlKTtcbiAgICAgIHRoaXMucmVzaXplSGVpZ2h0ID0gdGhpcy5yZXNpemVIZWlnaHRJbnRlcnBvbGF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVNlY29uZFBhc3NCdWZmZXJzKGZhbHNlKTtcbiAgICAgIHRoaXMucmVzaXplSGVpZ2h0ID0gdGhpcy5jb2xvckNoYW5uZWxzID09PSA0ID8gdGhpcy5yZXNpemVIZWlnaHRSR0JBIDogdGhpcy5yZXNpemVIZWlnaHRSR0I7XG4gICAgfVxuICB9XG59O1xuUmVzaXplLnByb3RvdHlwZS5fcmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0JDaGFubmVscyA9IGZ1bmN0aW9uIChidWZmZXIsIGZvdXJ0aENoYW5uZWwpIHtcbiAgY29uc3QgY2hhbm5lbHNOdW0gPSBmb3VydGhDaGFubmVsID8gNCA6IDM7XG4gIGNvbnN0IHJhdGlvV2VpZ2h0ID0gdGhpcy5yYXRpb1dlaWdodFdpZHRoUGFzcztcbiAgY29uc3Qgb3V0cHV0QnVmZmVyID0gdGhpcy53aWR0aEJ1ZmZlcjtcbiAgbGV0IHdlaWdodCA9IDA7XG4gIGxldCBmaW5hbE9mZnNldCA9IDA7XG4gIGxldCBwaXhlbE9mZnNldCA9IDA7XG4gIGxldCBmaXJzdFdlaWdodCA9IDA7XG4gIGxldCBzZWNvbmRXZWlnaHQgPSAwO1xuICBsZXQgdGFyZ2V0UG9zaXRpb247XG5cbiAgLy8gSGFuZGxlIGZvciBvbmx5IG9uZSBpbnRlcnBvbGF0aW9uIGlucHV0IGJlaW5nIHZhbGlkIGZvciBzdGFydCBjYWxjdWxhdGlvbjpcbiAgZm9yICh0YXJnZXRQb3NpdGlvbiA9IDA7IHdlaWdodCA8IDEgLyAzOyB0YXJnZXRQb3NpdGlvbiArPSBjaGFubmVsc051bSwgd2VpZ2h0ICs9IHJhdGlvV2VpZ2h0KSB7XG4gICAgZm9yIChmaW5hbE9mZnNldCA9IHRhcmdldFBvc2l0aW9uLCBwaXhlbE9mZnNldCA9IDA7IGZpbmFsT2Zmc2V0IDwgdGhpcy53aWR0aFBhc3NSZXN1bHRTaXplOyBwaXhlbE9mZnNldCArPSB0aGlzLm9yaWdpbmFsV2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscywgZmluYWxPZmZzZXQgKz0gdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzKSB7XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXRdID0gYnVmZmVyW3BpeGVsT2Zmc2V0XTtcbiAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDFdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMV07XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAyXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDJdO1xuICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDNdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgM107XG4gICAgfVxuICB9XG5cbiAgLy8gQWRqdXN0IGZvciBvdmVyc2hvb3Qgb2YgdGhlIGxhc3QgcGFzcydzIGNvdW50ZXI6XG4gIHdlaWdodCAtPSAxIC8gMztcbiAgbGV0IGludGVycG9sYXRpb25XaWR0aFNvdXJjZVJlYWRTdG9wO1xuICBmb3IgKGludGVycG9sYXRpb25XaWR0aFNvdXJjZVJlYWRTdG9wID0gdGhpcy53aWR0aE9yaWdpbmFsIC0gMTsgd2VpZ2h0IDwgaW50ZXJwb2xhdGlvbldpZHRoU291cmNlUmVhZFN0b3A7IHRhcmdldFBvc2l0aW9uICs9IGNoYW5uZWxzTnVtLCB3ZWlnaHQgKz0gcmF0aW9XZWlnaHQpIHtcbiAgICAvLyBDYWxjdWxhdGUgd2VpZ2h0aW5nczpcbiAgICBzZWNvbmRXZWlnaHQgPSB3ZWlnaHQgJSAxO1xuICAgIGZpcnN0V2VpZ2h0ID0gMSAtIHNlY29uZFdlaWdodDtcbiAgICAvLyBJbnRlcnBvbGF0ZTpcbiAgICBmb3IgKGZpbmFsT2Zmc2V0ID0gdGFyZ2V0UG9zaXRpb24sIHBpeGVsT2Zmc2V0ID0gTWF0aC5mbG9vcih3ZWlnaHQpICogY2hhbm5lbHNOdW07IGZpbmFsT2Zmc2V0IDwgdGhpcy53aWR0aFBhc3NSZXN1bHRTaXplOyBwaXhlbE9mZnNldCArPSB0aGlzLm9yaWdpbmFsV2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscywgZmluYWxPZmZzZXQgKz0gdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzKSB7XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAwXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDBdICogZmlyc3RXZWlnaHQgKyBidWZmZXJbcGl4ZWxPZmZzZXQgKyBjaGFubmVsc051bSArIDBdICogc2Vjb25kV2VpZ2h0O1xuICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0ICsgMV0gPSBidWZmZXJbcGl4ZWxPZmZzZXQgKyAxXSAqIGZpcnN0V2VpZ2h0ICsgYnVmZmVyW3BpeGVsT2Zmc2V0ICsgY2hhbm5lbHNOdW0gKyAxXSAqIHNlY29uZFdlaWdodDtcbiAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDJdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMl0gKiBmaXJzdFdlaWdodCArIGJ1ZmZlcltwaXhlbE9mZnNldCArIGNoYW5uZWxzTnVtICsgMl0gKiBzZWNvbmRXZWlnaHQ7XG4gICAgICBpZiAoZm91cnRoQ2hhbm5lbCkgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0ICsgM10gPSBidWZmZXJbcGl4ZWxPZmZzZXQgKyAzXSAqIGZpcnN0V2VpZ2h0ICsgYnVmZmVyW3BpeGVsT2Zmc2V0ICsgY2hhbm5lbHNOdW0gKyAzXSAqIHNlY29uZFdlaWdodDtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgZm9yIG9ubHkgb25lIGludGVycG9sYXRpb24gaW5wdXQgYmVpbmcgdmFsaWQgZm9yIGVuZCBjYWxjdWxhdGlvbjpcbiAgZm9yIChpbnRlcnBvbGF0aW9uV2lkdGhTb3VyY2VSZWFkU3RvcCA9IHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzIC0gY2hhbm5lbHNOdW07IHRhcmdldFBvc2l0aW9uIDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOyB0YXJnZXRQb3NpdGlvbiArPSBjaGFubmVsc051bSkge1xuICAgIGZvciAoZmluYWxPZmZzZXQgPSB0YXJnZXRQb3NpdGlvbiwgcGl4ZWxPZmZzZXQgPSBpbnRlcnBvbGF0aW9uV2lkdGhTb3VyY2VSZWFkU3RvcDsgZmluYWxPZmZzZXQgPCB0aGlzLndpZHRoUGFzc1Jlc3VsdFNpemU7IHBpeGVsT2Zmc2V0ICs9IHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzLCBmaW5hbE9mZnNldCArPSB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMpIHtcbiAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldF0gPSBidWZmZXJbcGl4ZWxPZmZzZXRdO1xuICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0ICsgMV0gPSBidWZmZXJbcGl4ZWxPZmZzZXQgKyAxXTtcbiAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDJdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMl07XG4gICAgICBpZiAoZm91cnRoQ2hhbm5lbCkgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0ICsgM10gPSBidWZmZXJbcGl4ZWxPZmZzZXQgKyAzXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbn07XG5SZXNpemUucHJvdG90eXBlLl9yZXNpemVXaWR0aFJHQkNoYW5uZWxzID0gZnVuY3Rpb24gKGJ1ZmZlciwgZm91cnRoQ2hhbm5lbCkge1xuICBjb25zdCBjaGFubmVsc051bSA9IGZvdXJ0aENoYW5uZWwgPyA0IDogMztcbiAgY29uc3QgcmF0aW9XZWlnaHQgPSB0aGlzLnJhdGlvV2VpZ2h0V2lkdGhQYXNzO1xuICBjb25zdCByYXRpb1dlaWdodERpdmlzb3IgPSAxIC8gcmF0aW9XZWlnaHQ7XG4gIGNvbnN0IG5leHRMaW5lT2Zmc2V0T3JpZ2luYWxXaWR0aCA9IHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzIC0gY2hhbm5lbHNOdW0gKyAxO1xuICBjb25zdCBuZXh0TGluZU9mZnNldFRhcmdldFdpZHRoID0gdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzIC0gY2hhbm5lbHNOdW0gKyAxO1xuICBjb25zdCBvdXRwdXQgPSB0aGlzLm91dHB1dFdpZHRoV29ya0JlbmNoO1xuICBjb25zdCBvdXRwdXRCdWZmZXIgPSB0aGlzLndpZHRoQnVmZmVyO1xuICBjb25zdCB0cnVzdHdvcnRoeUNvbG9yc0NvdW50ID0gdGhpcy5vdXRwdXRXaWR0aFdvcmtCZW5jaE9wYXF1ZVBpeGVsc0NvdW50O1xuICBsZXQgd2VpZ2h0ID0gMDtcbiAgbGV0IGFtb3VudFRvTmV4dCA9IDA7XG4gIGxldCBhY3R1YWxQb3NpdGlvbiA9IDA7XG4gIGxldCBjdXJyZW50UG9zaXRpb24gPSAwO1xuICBsZXQgbGluZSA9IDA7XG4gIGxldCBwaXhlbE9mZnNldCA9IDA7XG4gIGxldCBvdXRwdXRPZmZzZXQgPSAwO1xuICBsZXQgbXVsdGlwbGllciA9IDE7XG4gIGxldCByID0gMDtcbiAgbGV0IGcgPSAwO1xuICBsZXQgYiA9IDA7XG4gIGxldCBhID0gMDtcbiAgZG8ge1xuICAgIGZvciAobGluZSA9IDA7IGxpbmUgPCB0aGlzLm9yaWdpbmFsSGVpZ2h0TXVsdGlwbGllZEJ5Q2hhbm5lbHM7KSB7XG4gICAgICBvdXRwdXRbbGluZSsrXSA9IDA7XG4gICAgICBvdXRwdXRbbGluZSsrXSA9IDA7XG4gICAgICBvdXRwdXRbbGluZSsrXSA9IDA7XG4gICAgICBpZiAoZm91cnRoQ2hhbm5lbCkge1xuICAgICAgICBvdXRwdXRbbGluZSsrXSA9IDA7XG4gICAgICAgIHRydXN0d29ydGh5Q29sb3JzQ291bnRbbGluZSAvIGNoYW5uZWxzTnVtIC0gMV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB3ZWlnaHQgPSByYXRpb1dlaWdodDtcbiAgICBkbyB7XG4gICAgICBhbW91bnRUb05leHQgPSAxICsgYWN0dWFsUG9zaXRpb24gLSBjdXJyZW50UG9zaXRpb247XG4gICAgICBtdWx0aXBsaWVyID0gTWF0aC5taW4od2VpZ2h0LCBhbW91bnRUb05leHQpO1xuICAgICAgZm9yIChsaW5lID0gMCwgcGl4ZWxPZmZzZXQgPSBhY3R1YWxQb3NpdGlvbjsgbGluZSA8IHRoaXMub3JpZ2luYWxIZWlnaHRNdWx0aXBsaWVkQnlDaGFubmVsczsgcGl4ZWxPZmZzZXQgKz0gbmV4dExpbmVPZmZzZXRPcmlnaW5hbFdpZHRoKSB7XG4gICAgICAgIHIgPSBidWZmZXJbcGl4ZWxPZmZzZXRdO1xuICAgICAgICBnID0gYnVmZmVyWysrcGl4ZWxPZmZzZXRdO1xuICAgICAgICBiID0gYnVmZmVyWysrcGl4ZWxPZmZzZXRdO1xuICAgICAgICBhID0gZm91cnRoQ2hhbm5lbCA/IGJ1ZmZlclsrK3BpeGVsT2Zmc2V0XSA6IDI1NTtcbiAgICAgICAgLy8gSWdub3JlIFJHQiB2YWx1ZXMgaWYgcGl4ZWwgaXMgY29tcGxldGVseSB0cmFuc3BhcmVudFxuICAgICAgICBvdXRwdXRbbGluZSsrXSArPSAoYSA/IHIgOiAwKSAqIG11bHRpcGxpZXI7XG4gICAgICAgIG91dHB1dFtsaW5lKytdICs9IChhID8gZyA6IDApICogbXVsdGlwbGllcjtcbiAgICAgICAgb3V0cHV0W2xpbmUrK10gKz0gKGEgPyBiIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICBpZiAoZm91cnRoQ2hhbm5lbCkge1xuICAgICAgICAgIG91dHB1dFtsaW5lKytdICs9IGEgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgIHRydXN0d29ydGh5Q29sb3JzQ291bnRbbGluZSAvIGNoYW5uZWxzTnVtIC0gMV0gKz0gYSA/IG11bHRpcGxpZXIgOiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2VpZ2h0ID49IGFtb3VudFRvTmV4dCkge1xuICAgICAgICBhY3R1YWxQb3NpdGlvbiArPSBjaGFubmVsc051bTtcbiAgICAgICAgY3VycmVudFBvc2l0aW9uID0gYWN0dWFsUG9zaXRpb247XG4gICAgICAgIHdlaWdodCAtPSBhbW91bnRUb05leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UG9zaXRpb24gKz0gd2VpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICh3ZWlnaHQgPiAwICYmIGFjdHVhbFBvc2l0aW9uIDwgdGhpcy5vcmlnaW5hbFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMpO1xuICAgIGZvciAobGluZSA9IDAsIHBpeGVsT2Zmc2V0ID0gb3V0cHV0T2Zmc2V0OyBsaW5lIDwgdGhpcy5vcmlnaW5hbEhlaWdodE11bHRpcGxpZWRCeUNoYW5uZWxzOyBwaXhlbE9mZnNldCArPSBuZXh0TGluZU9mZnNldFRhcmdldFdpZHRoKSB7XG4gICAgICB3ZWlnaHQgPSBmb3VydGhDaGFubmVsID8gdHJ1c3R3b3J0aHlDb2xvcnNDb3VudFtsaW5lIC8gY2hhbm5lbHNOdW1dIDogMTtcbiAgICAgIG11bHRpcGxpZXIgPSBmb3VydGhDaGFubmVsID8gd2VpZ2h0ID8gMSAvIHdlaWdodCA6IDAgOiByYXRpb1dlaWdodERpdmlzb3I7XG4gICAgICBvdXRwdXRCdWZmZXJbcGl4ZWxPZmZzZXRdID0gb3V0cHV0W2xpbmUrK10gKiBtdWx0aXBsaWVyO1xuICAgICAgb3V0cHV0QnVmZmVyWysrcGl4ZWxPZmZzZXRdID0gb3V0cHV0W2xpbmUrK10gKiBtdWx0aXBsaWVyO1xuICAgICAgb3V0cHV0QnVmZmVyWysrcGl4ZWxPZmZzZXRdID0gb3V0cHV0W2xpbmUrK10gKiBtdWx0aXBsaWVyO1xuICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpIG91dHB1dEJ1ZmZlclsrK3BpeGVsT2Zmc2V0XSA9IG91dHB1dFtsaW5lKytdICogcmF0aW9XZWlnaHREaXZpc29yO1xuICAgIH1cbiAgICBvdXRwdXRPZmZzZXQgKz0gY2hhbm5lbHNOdW07XG4gIH0gd2hpbGUgKG91dHB1dE9mZnNldCA8IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyk7XG4gIHJldHVybiBvdXRwdXRCdWZmZXI7XG59O1xuUmVzaXplLnByb3RvdHlwZS5fcmVzaXplSGVpZ2h0UkdCQ2hhbm5lbHMgPSBmdW5jdGlvbiAoYnVmZmVyLCBmb3VydGhDaGFubmVsKSB7XG4gIGNvbnN0IHJhdGlvV2VpZ2h0ID0gdGhpcy5yYXRpb1dlaWdodEhlaWdodFBhc3M7XG4gIGNvbnN0IHJhdGlvV2VpZ2h0RGl2aXNvciA9IDEgLyByYXRpb1dlaWdodDtcbiAgY29uc3Qgb3V0cHV0ID0gdGhpcy5vdXRwdXRIZWlnaHRXb3JrQmVuY2g7XG4gIGNvbnN0IG91dHB1dEJ1ZmZlciA9IHRoaXMuaGVpZ2h0QnVmZmVyO1xuICBjb25zdCB0cnVzdHdvcnRoeUNvbG9yc0NvdW50ID0gdGhpcy5vdXRwdXRIZWlnaHRXb3JrQmVuY2hPcGFxdWVQaXhlbHNDb3VudDtcbiAgbGV0IHdlaWdodCA9IDA7XG4gIGxldCBhbW91bnRUb05leHQgPSAwO1xuICBsZXQgYWN0dWFsUG9zaXRpb24gPSAwO1xuICBsZXQgY3VycmVudFBvc2l0aW9uID0gMDtcbiAgbGV0IHBpeGVsT2Zmc2V0ID0gMDtcbiAgbGV0IG91dHB1dE9mZnNldCA9IDA7XG4gIGxldCBjYXJldCA9IDA7XG4gIGxldCBtdWx0aXBsaWVyID0gMTtcbiAgbGV0IHIgPSAwO1xuICBsZXQgZyA9IDA7XG4gIGxldCBiID0gMDtcbiAgbGV0IGEgPSAwO1xuICBkbyB7XG4gICAgZm9yIChwaXhlbE9mZnNldCA9IDA7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOykge1xuICAgICAgb3V0cHV0W3BpeGVsT2Zmc2V0KytdID0gMDtcbiAgICAgIG91dHB1dFtwaXhlbE9mZnNldCsrXSA9IDA7XG4gICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gPSAwO1xuICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpIHtcbiAgICAgICAgb3V0cHV0W3BpeGVsT2Zmc2V0KytdID0gMDtcbiAgICAgICAgdHJ1c3R3b3J0aHlDb2xvcnNDb3VudFtwaXhlbE9mZnNldCAvIDQgLSAxXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHdlaWdodCA9IHJhdGlvV2VpZ2h0O1xuICAgIGRvIHtcbiAgICAgIGFtb3VudFRvTmV4dCA9IDEgKyBhY3R1YWxQb3NpdGlvbiAtIGN1cnJlbnRQb3NpdGlvbjtcbiAgICAgIG11bHRpcGxpZXIgPSBNYXRoLm1pbih3ZWlnaHQsIGFtb3VudFRvTmV4dCk7XG4gICAgICBjYXJldCA9IGFjdHVhbFBvc2l0aW9uO1xuICAgICAgZm9yIChwaXhlbE9mZnNldCA9IDA7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOykge1xuICAgICAgICByID0gYnVmZmVyW2NhcmV0KytdO1xuICAgICAgICBnID0gYnVmZmVyW2NhcmV0KytdO1xuICAgICAgICBiID0gYnVmZmVyW2NhcmV0KytdO1xuICAgICAgICBhID0gZm91cnRoQ2hhbm5lbCA/IGJ1ZmZlcltjYXJldCsrXSA6IDI1NTtcbiAgICAgICAgLy8gSWdub3JlIFJHQiB2YWx1ZXMgaWYgcGl4ZWwgaXMgY29tcGxldGVseSB0cmFuc3BhcmVudFxuICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKz0gKGEgPyByIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKz0gKGEgPyBnIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKz0gKGEgPyBiIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICBpZiAoZm91cnRoQ2hhbm5lbCkge1xuICAgICAgICAgIG91dHB1dFtwaXhlbE9mZnNldCsrXSArPSBhICogbXVsdGlwbGllcjtcbiAgICAgICAgICB0cnVzdHdvcnRoeUNvbG9yc0NvdW50W3BpeGVsT2Zmc2V0IC8gNCAtIDFdICs9IGEgPyBtdWx0aXBsaWVyIDogMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHdlaWdodCA+PSBhbW91bnRUb05leHQpIHtcbiAgICAgICAgYWN0dWFsUG9zaXRpb24gPSBjYXJldDtcbiAgICAgICAgY3VycmVudFBvc2l0aW9uID0gYWN0dWFsUG9zaXRpb247XG4gICAgICAgIHdlaWdodCAtPSBhbW91bnRUb05leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UG9zaXRpb24gKz0gd2VpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICh3ZWlnaHQgPiAwICYmIGFjdHVhbFBvc2l0aW9uIDwgdGhpcy53aWR0aFBhc3NSZXN1bHRTaXplKTtcbiAgICBmb3IgKHBpeGVsT2Zmc2V0ID0gMDsgcGl4ZWxPZmZzZXQgPCB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7KSB7XG4gICAgICB3ZWlnaHQgPSBmb3VydGhDaGFubmVsID8gdHJ1c3R3b3J0aHlDb2xvcnNDb3VudFtwaXhlbE9mZnNldCAvIDRdIDogMTtcbiAgICAgIG11bHRpcGxpZXIgPSBmb3VydGhDaGFubmVsID8gd2VpZ2h0ID8gMSAvIHdlaWdodCA6IDAgOiByYXRpb1dlaWdodERpdmlzb3I7XG4gICAgICBvdXRwdXRCdWZmZXJbb3V0cHV0T2Zmc2V0KytdID0gTWF0aC5yb3VuZChvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKiBtdWx0aXBsaWVyKTtcbiAgICAgIG91dHB1dEJ1ZmZlcltvdXRwdXRPZmZzZXQrK10gPSBNYXRoLnJvdW5kKG91dHB1dFtwaXhlbE9mZnNldCsrXSAqIG11bHRpcGxpZXIpO1xuICAgICAgb3V0cHV0QnVmZmVyW291dHB1dE9mZnNldCsrXSA9IE1hdGgucm91bmQob3V0cHV0W3BpeGVsT2Zmc2V0KytdICogbXVsdGlwbGllcik7XG4gICAgICBpZiAoZm91cnRoQ2hhbm5lbCkge1xuICAgICAgICBvdXRwdXRCdWZmZXJbb3V0cHV0T2Zmc2V0KytdID0gTWF0aC5yb3VuZChvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKiByYXRpb1dlaWdodERpdmlzb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAob3V0cHV0T2Zmc2V0IDwgdGhpcy5maW5hbFJlc3VsdFNpemUpO1xuICByZXR1cm4gb3V0cHV0QnVmZmVyO1xufTtcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0IgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiB0aGlzLl9yZXNpemVXaWR0aEludGVycG9sYXRlZFJHQkNoYW5uZWxzKGJ1ZmZlciwgZmFsc2UpO1xufTtcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0JBID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5fcmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0JDaGFubmVscyhidWZmZXIsIHRydWUpO1xufTtcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplV2lkdGhSR0IgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiB0aGlzLl9yZXNpemVXaWR0aFJHQkNoYW5uZWxzKGJ1ZmZlciwgZmFsc2UpO1xufTtcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplV2lkdGhSR0JBID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5fcmVzaXplV2lkdGhSR0JDaGFubmVscyhidWZmZXIsIHRydWUpO1xufTtcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplSGVpZ2h0SW50ZXJwb2xhdGVkID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICBjb25zdCByYXRpb1dlaWdodCA9IHRoaXMucmF0aW9XZWlnaHRIZWlnaHRQYXNzO1xuICBjb25zdCBvdXRwdXRCdWZmZXIgPSB0aGlzLmhlaWdodEJ1ZmZlcjtcbiAgbGV0IHdlaWdodCA9IDA7XG4gIGxldCBmaW5hbE9mZnNldCA9IDA7XG4gIGxldCBwaXhlbE9mZnNldCA9IDA7XG4gIGxldCBwaXhlbE9mZnNldEFjY3VtdWxhdGVkID0gMDtcbiAgbGV0IHBpeGVsT2Zmc2V0QWNjdW11bGF0ZWQyID0gMDtcbiAgbGV0IGZpcnN0V2VpZ2h0ID0gMDtcbiAgbGV0IHNlY29uZFdlaWdodCA9IDA7XG4gIGxldCBpbnRlcnBvbGF0aW9uSGVpZ2h0U291cmNlUmVhZFN0b3A7XG5cbiAgLy8gSGFuZGxlIGZvciBvbmx5IG9uZSBpbnRlcnBvbGF0aW9uIGlucHV0IGJlaW5nIHZhbGlkIGZvciBzdGFydCBjYWxjdWxhdGlvbjpcbiAgZm9yICg7IHdlaWdodCA8IDEgLyAzOyB3ZWlnaHQgKz0gcmF0aW9XZWlnaHQpIHtcbiAgICBmb3IgKHBpeGVsT2Zmc2V0ID0gMDsgcGl4ZWxPZmZzZXQgPCB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7KSB7XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQrK10gPSBNYXRoLnJvdW5kKGJ1ZmZlcltwaXhlbE9mZnNldCsrXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRqdXN0IGZvciBvdmVyc2hvb3Qgb2YgdGhlIGxhc3QgcGFzcydzIGNvdW50ZXI6XG4gIHdlaWdodCAtPSAxIC8gMztcbiAgZm9yIChpbnRlcnBvbGF0aW9uSGVpZ2h0U291cmNlUmVhZFN0b3AgPSB0aGlzLmhlaWdodE9yaWdpbmFsIC0gMTsgd2VpZ2h0IDwgaW50ZXJwb2xhdGlvbkhlaWdodFNvdXJjZVJlYWRTdG9wOyB3ZWlnaHQgKz0gcmF0aW9XZWlnaHQpIHtcbiAgICAvLyBDYWxjdWxhdGUgd2VpZ2h0aW5nczpcbiAgICBzZWNvbmRXZWlnaHQgPSB3ZWlnaHQgJSAxO1xuICAgIGZpcnN0V2VpZ2h0ID0gMSAtIHNlY29uZFdlaWdodDtcbiAgICAvLyBJbnRlcnBvbGF0ZTpcbiAgICBwaXhlbE9mZnNldEFjY3VtdWxhdGVkID0gTWF0aC5mbG9vcih3ZWlnaHQpICogdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzO1xuICAgIHBpeGVsT2Zmc2V0QWNjdW11bGF0ZWQyID0gcGl4ZWxPZmZzZXRBY2N1bXVsYXRlZCArIHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscztcbiAgICBmb3IgKHBpeGVsT2Zmc2V0ID0gMDsgcGl4ZWxPZmZzZXQgPCB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7ICsrcGl4ZWxPZmZzZXQpIHtcbiAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCsrXSA9IE1hdGgucm91bmQoYnVmZmVyW3BpeGVsT2Zmc2V0QWNjdW11bGF0ZWQrK10gKiBmaXJzdFdlaWdodCArIGJ1ZmZlcltwaXhlbE9mZnNldEFjY3VtdWxhdGVkMisrXSAqIHNlY29uZFdlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGZvciBvbmx5IG9uZSBpbnRlcnBvbGF0aW9uIGlucHV0IGJlaW5nIHZhbGlkIGZvciBlbmQgY2FsY3VsYXRpb246XG4gIHdoaWxlIChmaW5hbE9mZnNldCA8IHRoaXMuZmluYWxSZXN1bHRTaXplKSB7XG4gICAgZm9yIChwaXhlbE9mZnNldCA9IDAsIHBpeGVsT2Zmc2V0QWNjdW11bGF0ZWQgPSBpbnRlcnBvbGF0aW9uSGVpZ2h0U291cmNlUmVhZFN0b3AgKiB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOyArK3BpeGVsT2Zmc2V0KSB7XG4gICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQrK10gPSBNYXRoLnJvdW5kKGJ1ZmZlcltwaXhlbE9mZnNldEFjY3VtdWxhdGVkKytdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbn07XG5SZXNpemUucHJvdG90eXBlLnJlc2l6ZUhlaWdodFJHQiA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc2l6ZUhlaWdodFJHQkNoYW5uZWxzKGJ1ZmZlciwgZmFsc2UpO1xufTtcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplSGVpZ2h0UkdCQSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc2l6ZUhlaWdodFJHQkNoYW5uZWxzKGJ1ZmZlciwgdHJ1ZSk7XG59O1xuUmVzaXplLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHRoaXMucmVzaXplQ2FsbGJhY2sodGhpcy5yZXNpemVIZWlnaHQodGhpcy5yZXNpemVXaWR0aChidWZmZXIpKSk7XG59O1xuUmVzaXplLnByb3RvdHlwZS5ieXBhc3NSZXNpemVyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAvLyBKdXN0IHJldHVybiB0aGUgYnVmZmVyIHBhc3NlZDpcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5SZXNpemUucHJvdG90eXBlLmluaXRpYWxpemVGaXJzdFBhc3NCdWZmZXJzID0gZnVuY3Rpb24gKEJJTElORUFSQWxnbykge1xuICAvLyBJbml0aWFsaXplIHRoZSBpbnRlcm5hbCB3aWR0aCBwYXNzIGJ1ZmZlcnM6XG4gIHRoaXMud2lkdGhCdWZmZXIgPSB0aGlzLmdlbmVyYXRlRmxvYXRCdWZmZXIodGhpcy53aWR0aFBhc3NSZXN1bHRTaXplKTtcbiAgaWYgKCFCSUxJTkVBUkFsZ28pIHtcbiAgICB0aGlzLm91dHB1dFdpZHRoV29ya0JlbmNoID0gdGhpcy5nZW5lcmF0ZUZsb2F0QnVmZmVyKHRoaXMub3JpZ2luYWxIZWlnaHRNdWx0aXBsaWVkQnlDaGFubmVscyk7XG4gICAgaWYgKHRoaXMuY29sb3JDaGFubmVscyA+IDMpIHtcbiAgICAgIHRoaXMub3V0cHV0V2lkdGhXb3JrQmVuY2hPcGFxdWVQaXhlbHNDb3VudCA9IHRoaXMuZ2VuZXJhdGVGbG9hdDY0QnVmZmVyKHRoaXMuaGVpZ2h0T3JpZ2luYWwpO1xuICAgIH1cbiAgfVxufTtcblJlc2l6ZS5wcm90b3R5cGUuaW5pdGlhbGl6ZVNlY29uZFBhc3NCdWZmZXJzID0gZnVuY3Rpb24gKEJJTElORUFSQWxnbykge1xuICAvLyBJbml0aWFsaXplIHRoZSBpbnRlcm5hbCBoZWlnaHQgcGFzcyBidWZmZXJzOlxuICB0aGlzLmhlaWdodEJ1ZmZlciA9IHRoaXMuZ2VuZXJhdGVVaW50OEJ1ZmZlcih0aGlzLmZpbmFsUmVzdWx0U2l6ZSk7XG4gIGlmICghQklMSU5FQVJBbGdvKSB7XG4gICAgdGhpcy5vdXRwdXRIZWlnaHRXb3JrQmVuY2ggPSB0aGlzLmdlbmVyYXRlRmxvYXRCdWZmZXIodGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzKTtcbiAgICBpZiAodGhpcy5jb2xvckNoYW5uZWxzID4gMykge1xuICAgICAgdGhpcy5vdXRwdXRIZWlnaHRXb3JrQmVuY2hPcGFxdWVQaXhlbHNDb3VudCA9IHRoaXMuZ2VuZXJhdGVGbG9hdDY0QnVmZmVyKHRoaXMudGFyZ2V0V2lkdGgpO1xuICAgIH1cbiAgfVxufTtcblJlc2l6ZS5wcm90b3R5cGUuZ2VuZXJhdGVGbG9hdEJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXJMZW5ndGgpIHtcbiAgLy8gR2VuZXJhdGUgYSBmbG9hdDMyIHR5cGVkIGFycmF5IGJ1ZmZlcjpcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXJMZW5ndGgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblJlc2l6ZS5wcm90b3R5cGUuZ2VuZXJhdGVGbG9hdDY0QnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlckxlbmd0aCkge1xuICAvLyBHZW5lcmF0ZSBhIGZsb2F0NjQgdHlwZWQgYXJyYXkgYnVmZmVyOlxuICB0cnkge1xuICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuUmVzaXplLnByb3RvdHlwZS5nZW5lcmF0ZVVpbnQ4QnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlckxlbmd0aCkge1xuICAvLyBHZW5lcmF0ZSBhIHVpbnQ4IHR5cGVkIGFycmF5IGJ1ZmZlcjpcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBSZXNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNpemUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-resize/es/modules/resize.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-resize/es/modules/resize2.js":
/*!****************************************************************!*\
  !*** ./node_modules/@jimp/plugin-resize/es/modules/resize2.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Copyright (c) 2015 Guyon Roche\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nconst operations = {\n  nearestNeighbor(src, dst) {\n    const wSrc = src.width;\n    const hSrc = src.height;\n    const wDst = dst.width;\n    const hDst = dst.height;\n    const bufSrc = src.data;\n    const bufDst = dst.data;\n    for (let i = 0; i < hDst; i++) {\n      for (let j = 0; j < wDst; j++) {\n        let posDst = (i * wDst + j) * 4;\n        const iSrc = Math.floor(i * hSrc / hDst);\n        const jSrc = Math.floor(j * wSrc / wDst);\n        let posSrc = (iSrc * wSrc + jSrc) * 4;\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n        bufDst[posDst++] = bufSrc[posSrc++];\n      }\n    }\n  },\n  bilinearInterpolation(src, dst) {\n    const wSrc = src.width;\n    const hSrc = src.height;\n    const wDst = dst.width;\n    const hDst = dst.height;\n    const bufSrc = src.data;\n    const bufDst = dst.data;\n    const interpolate = function (k, kMin, vMin, kMax, vMax) {\n      // special case - k is integer\n      if (kMin === kMax) {\n        return vMin;\n      }\n      return Math.round((k - kMin) * vMax + (kMax - k) * vMin);\n    };\n    const assign = function (pos, offset, x, xMin, xMax, y, yMin, yMax) {\n      let posMin = (yMin * wSrc + xMin) * 4 + offset;\n      let posMax = (yMin * wSrc + xMax) * 4 + offset;\n      const vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n\n      // special case, y is integer\n      if (yMax === yMin) {\n        bufDst[pos + offset] = vMin;\n      } else {\n        posMin = (yMax * wSrc + xMin) * 4 + offset;\n        posMax = (yMax * wSrc + xMax) * 4 + offset;\n        const vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n        bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);\n      }\n    };\n    for (let i = 0; i < hDst; i++) {\n      for (let j = 0; j < wDst; j++) {\n        const posDst = (i * wDst + j) * 4;\n        // x & y in src coordinates\n        const x = j * wSrc / wDst;\n        const xMin = Math.floor(x);\n        const xMax = Math.min(Math.ceil(x), wSrc - 1);\n        const y = i * hSrc / hDst;\n        const yMin = Math.floor(y);\n        const yMax = Math.min(Math.ceil(y), hSrc - 1);\n        assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);\n        assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);\n      }\n    }\n  },\n  _interpolate2D(src, dst, options, interpolate) {\n    const bufSrc = src.data;\n    const bufDst = dst.data;\n    const wSrc = src.width;\n    const hSrc = src.height;\n    const wDst = dst.width;\n    const hDst = dst.height;\n\n    // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares\n    const wM = Math.max(1, Math.floor(wSrc / wDst));\n    const wDst2 = wDst * wM;\n    const hM = Math.max(1, Math.floor(hSrc / hDst));\n    const hDst2 = hDst * hM;\n\n    // ===========================================================\n    // Pass 1 - interpolate rows\n    // buf1 has width of dst2 and height of src\n    const buf1 = Buffer.alloc(wDst2 * hSrc * 4);\n    for (let i = 0; i < hSrc; i++) {\n      for (let j = 0; j < wDst2; j++) {\n        // i in src coords, j in dst coords\n\n        // calculate x in src coords\n        // this interpolation requires 4 sample points and the two inner ones must be real\n        // the outer points can be fudged for the edges.\n        // therefore (wSrc-1)/wDst2\n        const x = j * (wSrc - 1) / wDst2;\n        const xPos = Math.floor(x);\n        const t = x - xPos;\n        const srcPos = (i * wSrc + xPos) * 4;\n        const buf1Pos = (i * wDst2 + j) * 4;\n        for (let k = 0; k < 4; k++) {\n          const kPos = srcPos + k;\n          const x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];\n          const x1 = bufSrc[kPos];\n          const x2 = bufSrc[kPos + 4];\n          const x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];\n          buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);\n        }\n      }\n    }\n    // this._writeFile(wDst2, hSrc, buf1, \"out/buf1.jpg\");\n\n    // ===========================================================\n    // Pass 2 - interpolate columns\n    // buf2 has width and height of dst2\n    const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);\n    for (let i = 0; i < hDst2; i++) {\n      for (let j = 0; j < wDst2; j++) {\n        // i&j in dst2 coords\n\n        // calculate y in buf1 coords\n        // this interpolation requires 4 sample points and the two inner ones must be real\n        // the outer points can be fudged for the edges.\n        // therefore (hSrc-1)/hDst2\n        const y = i * (hSrc - 1) / hDst2;\n        const yPos = Math.floor(y);\n        const t = y - yPos;\n        const buf1Pos = (yPos * wDst2 + j) * 4;\n        const buf2Pos = (i * wDst2 + j) * 4;\n        for (let k = 0; k < 4; k++) {\n          const kPos = buf1Pos + k;\n          const y0 = yPos > 0 ? buf1[kPos - wDst2 * 4] : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];\n          const y1 = buf1[kPos];\n          const y2 = buf1[kPos + wDst2 * 4];\n          const y3 = yPos < hSrc - 2 ? buf1[kPos + wDst2 * 8] : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];\n          buf2[buf2Pos + k] = interpolate(y0, y1, y2, y3, t);\n        }\n      }\n    }\n    // this._writeFile(wDst2, hDst2, buf2, \"out/buf2.jpg\");\n\n    // ===========================================================\n    // Pass 3 - scale to dst\n    const m = wM * hM;\n    if (m > 1) {\n      for (let i = 0; i < hDst; i++) {\n        for (let j = 0; j < wDst; j++) {\n          // i&j in dst bounded coords\n          let r = 0;\n          let g = 0;\n          let b = 0;\n          let a = 0;\n          let realColors = 0;\n          for (let y = 0; y < hM; y++) {\n            const yPos = i * hM + y;\n            for (let x = 0; x < wM; x++) {\n              const xPos = j * wM + x;\n              const xyPos = (yPos * wDst2 + xPos) * 4;\n              const pixelAlpha = buf2[xyPos + 3];\n              if (pixelAlpha) {\n                r += buf2[xyPos];\n                g += buf2[xyPos + 1];\n                b += buf2[xyPos + 2];\n                realColors++;\n              }\n              a += pixelAlpha;\n            }\n          }\n          const pos = (i * wDst + j) * 4;\n          bufDst[pos] = realColors ? Math.round(r / realColors) : 0;\n          bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;\n          bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;\n          bufDst[pos + 3] = Math.round(a / m);\n        }\n      }\n    } else {\n      // replace dst buffer with buf2\n      dst.data = buf2;\n    }\n  },\n  bicubicInterpolation(src, dst, options) {\n    const interpolateCubic = function (x0, x1, x2, x3, t) {\n      const a0 = x3 - x2 - x0 + x1;\n      const a1 = x0 - x1 - a0;\n      const a2 = x2 - x0;\n      const a3 = x1;\n      return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));\n    };\n    return this._interpolate2D(src, dst, options, interpolateCubic);\n  },\n  hermiteInterpolation(src, dst, options) {\n    const interpolateHermite = function (x0, x1, x2, x3, t) {\n      const c0 = x1;\n      const c1 = 0.5 * (x2 - x0);\n      const c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;\n      const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);\n      return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));\n    };\n    return this._interpolate2D(src, dst, options, interpolateHermite);\n  },\n  bezierInterpolation(src, dst, options) {\n    // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)\n    // to predict control points (a & b) to be placed at n+0.5\n    //  ya(n) = y(n) + (y(n+1)-y(n-1))/4\n    //  yb(n) = y(n+1) - (y(n+2)-y(n))/4\n    // then use std bezier to interpolate [n,n+1)\n    //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3\n    //  note the 3* factor for the two control points\n    // for edge cases, can choose:\n    //  y(-1) = y(0) - 2*(y(1)-y(0))\n    //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))\n    // but can go with y(-1) = y(0) and y(w) = y(w-1)\n    const interpolateBezier = function (x0, x1, x2, x3, t) {\n      // x1, x2 are the knots, use x0 and x3 to calculate control points\n      const cp1 = x1 + (x2 - x0) / 4;\n      const cp2 = x2 - (x3 - x1) / 4;\n      const nt = 1 - t;\n      const c0 = x1 * nt * nt * nt;\n      const c1 = 3 * cp1 * nt * nt * t;\n      const c2 = 3 * cp2 * nt * t * t;\n      const c3 = x2 * t * t * t;\n      return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));\n    };\n    return this._interpolate2D(src, dst, options, interpolateBezier);\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (operations);\n//# sourceMappingURL=resize2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcmVzaXplL2VzL21vZHVsZXMvcmVzaXplMi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCLHNCQUFzQixXQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0Isc0JBQXNCLFdBQVc7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQyx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxVQUFVLEVBQUM7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcmVzaXplL2VzL21vZHVsZXMvcmVzaXplMi5qcz80MmRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEd1eW9uIFJvY2hlXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOjwvcD5cbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IG9wZXJhdGlvbnMgPSB7XG4gIG5lYXJlc3ROZWlnaGJvcihzcmMsIGRzdCkge1xuICAgIGNvbnN0IHdTcmMgPSBzcmMud2lkdGg7XG4gICAgY29uc3QgaFNyYyA9IHNyYy5oZWlnaHQ7XG4gICAgY29uc3Qgd0RzdCA9IGRzdC53aWR0aDtcbiAgICBjb25zdCBoRHN0ID0gZHN0LmhlaWdodDtcbiAgICBjb25zdCBidWZTcmMgPSBzcmMuZGF0YTtcbiAgICBjb25zdCBidWZEc3QgPSBkc3QuZGF0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhEc3Q7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3RHN0OyBqKyspIHtcbiAgICAgICAgbGV0IHBvc0RzdCA9IChpICogd0RzdCArIGopICogNDtcbiAgICAgICAgY29uc3QgaVNyYyA9IE1hdGguZmxvb3IoaSAqIGhTcmMgLyBoRHN0KTtcbiAgICAgICAgY29uc3QgalNyYyA9IE1hdGguZmxvb3IoaiAqIHdTcmMgLyB3RHN0KTtcbiAgICAgICAgbGV0IHBvc1NyYyA9IChpU3JjICogd1NyYyArIGpTcmMpICogNDtcbiAgICAgICAgYnVmRHN0W3Bvc0RzdCsrXSA9IGJ1ZlNyY1twb3NTcmMrK107XG4gICAgICAgIGJ1ZkRzdFtwb3NEc3QrK10gPSBidWZTcmNbcG9zU3JjKytdO1xuICAgICAgICBidWZEc3RbcG9zRHN0KytdID0gYnVmU3JjW3Bvc1NyYysrXTtcbiAgICAgICAgYnVmRHN0W3Bvc0RzdCsrXSA9IGJ1ZlNyY1twb3NTcmMrK107XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiaWxpbmVhckludGVycG9sYXRpb24oc3JjLCBkc3QpIHtcbiAgICBjb25zdCB3U3JjID0gc3JjLndpZHRoO1xuICAgIGNvbnN0IGhTcmMgPSBzcmMuaGVpZ2h0O1xuICAgIGNvbnN0IHdEc3QgPSBkc3Qud2lkdGg7XG4gICAgY29uc3QgaERzdCA9IGRzdC5oZWlnaHQ7XG4gICAgY29uc3QgYnVmU3JjID0gc3JjLmRhdGE7XG4gICAgY29uc3QgYnVmRHN0ID0gZHN0LmRhdGE7XG4gICAgY29uc3QgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoaywga01pbiwgdk1pbiwga01heCwgdk1heCkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIC0gayBpcyBpbnRlZ2VyXG4gICAgICBpZiAoa01pbiA9PT0ga01heCkge1xuICAgICAgICByZXR1cm4gdk1pbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKChrIC0ga01pbikgKiB2TWF4ICsgKGtNYXggLSBrKSAqIHZNaW4pO1xuICAgIH07XG4gICAgY29uc3QgYXNzaWduID0gZnVuY3Rpb24gKHBvcywgb2Zmc2V0LCB4LCB4TWluLCB4TWF4LCB5LCB5TWluLCB5TWF4KSB7XG4gICAgICBsZXQgcG9zTWluID0gKHlNaW4gKiB3U3JjICsgeE1pbikgKiA0ICsgb2Zmc2V0O1xuICAgICAgbGV0IHBvc01heCA9ICh5TWluICogd1NyYyArIHhNYXgpICogNCArIG9mZnNldDtcbiAgICAgIGNvbnN0IHZNaW4gPSBpbnRlcnBvbGF0ZSh4LCB4TWluLCBidWZTcmNbcG9zTWluXSwgeE1heCwgYnVmU3JjW3Bvc01heF0pO1xuXG4gICAgICAvLyBzcGVjaWFsIGNhc2UsIHkgaXMgaW50ZWdlclxuICAgICAgaWYgKHlNYXggPT09IHlNaW4pIHtcbiAgICAgICAgYnVmRHN0W3BvcyArIG9mZnNldF0gPSB2TWluO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zTWluID0gKHlNYXggKiB3U3JjICsgeE1pbikgKiA0ICsgb2Zmc2V0O1xuICAgICAgICBwb3NNYXggPSAoeU1heCAqIHdTcmMgKyB4TWF4KSAqIDQgKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHZNYXggPSBpbnRlcnBvbGF0ZSh4LCB4TWluLCBidWZTcmNbcG9zTWluXSwgeE1heCwgYnVmU3JjW3Bvc01heF0pO1xuICAgICAgICBidWZEc3RbcG9zICsgb2Zmc2V0XSA9IGludGVycG9sYXRlKHksIHlNaW4sIHZNaW4sIHlNYXgsIHZNYXgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoRHN0OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd0RzdDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHBvc0RzdCA9IChpICogd0RzdCArIGopICogNDtcbiAgICAgICAgLy8geCAmIHkgaW4gc3JjIGNvb3JkaW5hdGVzXG4gICAgICAgIGNvbnN0IHggPSBqICogd1NyYyAvIHdEc3Q7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICBjb25zdCB4TWF4ID0gTWF0aC5taW4oTWF0aC5jZWlsKHgpLCB3U3JjIC0gMSk7XG4gICAgICAgIGNvbnN0IHkgPSBpICogaFNyYyAvIGhEc3Q7XG4gICAgICAgIGNvbnN0IHlNaW4gPSBNYXRoLmZsb29yKHkpO1xuICAgICAgICBjb25zdCB5TWF4ID0gTWF0aC5taW4oTWF0aC5jZWlsKHkpLCBoU3JjIC0gMSk7XG4gICAgICAgIGFzc2lnbihwb3NEc3QsIDAsIHgsIHhNaW4sIHhNYXgsIHksIHlNaW4sIHlNYXgpO1xuICAgICAgICBhc3NpZ24ocG9zRHN0LCAxLCB4LCB4TWluLCB4TWF4LCB5LCB5TWluLCB5TWF4KTtcbiAgICAgICAgYXNzaWduKHBvc0RzdCwgMiwgeCwgeE1pbiwgeE1heCwgeSwgeU1pbiwgeU1heCk7XG4gICAgICAgIGFzc2lnbihwb3NEc3QsIDMsIHgsIHhNaW4sIHhNYXgsIHksIHlNaW4sIHlNYXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2ludGVycG9sYXRlMkQoc3JjLCBkc3QsIG9wdGlvbnMsIGludGVycG9sYXRlKSB7XG4gICAgY29uc3QgYnVmU3JjID0gc3JjLmRhdGE7XG4gICAgY29uc3QgYnVmRHN0ID0gZHN0LmRhdGE7XG4gICAgY29uc3Qgd1NyYyA9IHNyYy53aWR0aDtcbiAgICBjb25zdCBoU3JjID0gc3JjLmhlaWdodDtcbiAgICBjb25zdCB3RHN0ID0gZHN0LndpZHRoO1xuICAgIGNvbnN0IGhEc3QgPSBkc3QuaGVpZ2h0O1xuXG4gICAgLy8gd2hlbiBkc3Qgc21hbGxlciB0aGFuIHNyYy8yLCBpbnRlcnBvbGF0ZSBmaXJzdCB0byBhIG11bHRpcGxlIGJldHdlZW4gMC41IGFuZCAxLjAgc3JjLCB0aGVuIHN1bSBzcXVhcmVzXG4gICAgY29uc3Qgd00gPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHdTcmMgLyB3RHN0KSk7XG4gICAgY29uc3Qgd0RzdDIgPSB3RHN0ICogd007XG4gICAgY29uc3QgaE0gPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhTcmMgLyBoRHN0KSk7XG4gICAgY29uc3QgaERzdDIgPSBoRHN0ICogaE07XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBhc3MgMSAtIGludGVycG9sYXRlIHJvd3NcbiAgICAvLyBidWYxIGhhcyB3aWR0aCBvZiBkc3QyIGFuZCBoZWlnaHQgb2Ygc3JjXG4gICAgY29uc3QgYnVmMSA9IEJ1ZmZlci5hbGxvYyh3RHN0MiAqIGhTcmMgKiA0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhTcmM7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3RHN0MjsgaisrKSB7XG4gICAgICAgIC8vIGkgaW4gc3JjIGNvb3JkcywgaiBpbiBkc3QgY29vcmRzXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHggaW4gc3JjIGNvb3Jkc1xuICAgICAgICAvLyB0aGlzIGludGVycG9sYXRpb24gcmVxdWlyZXMgNCBzYW1wbGUgcG9pbnRzIGFuZCB0aGUgdHdvIGlubmVyIG9uZXMgbXVzdCBiZSByZWFsXG4gICAgICAgIC8vIHRoZSBvdXRlciBwb2ludHMgY2FuIGJlIGZ1ZGdlZCBmb3IgdGhlIGVkZ2VzLlxuICAgICAgICAvLyB0aGVyZWZvcmUgKHdTcmMtMSkvd0RzdDJcbiAgICAgICAgY29uc3QgeCA9IGogKiAod1NyYyAtIDEpIC8gd0RzdDI7XG4gICAgICAgIGNvbnN0IHhQb3MgPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICBjb25zdCB0ID0geCAtIHhQb3M7XG4gICAgICAgIGNvbnN0IHNyY1BvcyA9IChpICogd1NyYyArIHhQb3MpICogNDtcbiAgICAgICAgY29uc3QgYnVmMVBvcyA9IChpICogd0RzdDIgKyBqKSAqIDQ7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgNDsgaysrKSB7XG4gICAgICAgICAgY29uc3Qga1BvcyA9IHNyY1BvcyArIGs7XG4gICAgICAgICAgY29uc3QgeDAgPSB4UG9zID4gMCA/IGJ1ZlNyY1trUG9zIC0gNF0gOiAyICogYnVmU3JjW2tQb3NdIC0gYnVmU3JjW2tQb3MgKyA0XTtcbiAgICAgICAgICBjb25zdCB4MSA9IGJ1ZlNyY1trUG9zXTtcbiAgICAgICAgICBjb25zdCB4MiA9IGJ1ZlNyY1trUG9zICsgNF07XG4gICAgICAgICAgY29uc3QgeDMgPSB4UG9zIDwgd1NyYyAtIDIgPyBidWZTcmNba1BvcyArIDhdIDogMiAqIGJ1ZlNyY1trUG9zICsgNF0gLSBidWZTcmNba1Bvc107XG4gICAgICAgICAgYnVmMVtidWYxUG9zICsga10gPSBpbnRlcnBvbGF0ZSh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhpcy5fd3JpdGVGaWxlKHdEc3QyLCBoU3JjLCBidWYxLCBcIm91dC9idWYxLmpwZ1wiKTtcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUGFzcyAyIC0gaW50ZXJwb2xhdGUgY29sdW1uc1xuICAgIC8vIGJ1ZjIgaGFzIHdpZHRoIGFuZCBoZWlnaHQgb2YgZHN0MlxuICAgIGNvbnN0IGJ1ZjIgPSBCdWZmZXIuYWxsb2Mod0RzdDIgKiBoRHN0MiAqIDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaERzdDI7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3RHN0MjsgaisrKSB7XG4gICAgICAgIC8vIGkmaiBpbiBkc3QyIGNvb3Jkc1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB5IGluIGJ1ZjEgY29vcmRzXG4gICAgICAgIC8vIHRoaXMgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyA0IHNhbXBsZSBwb2ludHMgYW5kIHRoZSB0d28gaW5uZXIgb25lcyBtdXN0IGJlIHJlYWxcbiAgICAgICAgLy8gdGhlIG91dGVyIHBvaW50cyBjYW4gYmUgZnVkZ2VkIGZvciB0aGUgZWRnZXMuXG4gICAgICAgIC8vIHRoZXJlZm9yZSAoaFNyYy0xKS9oRHN0MlxuICAgICAgICBjb25zdCB5ID0gaSAqIChoU3JjIC0gMSkgLyBoRHN0MjtcbiAgICAgICAgY29uc3QgeVBvcyA9IE1hdGguZmxvb3IoeSk7XG4gICAgICAgIGNvbnN0IHQgPSB5IC0geVBvcztcbiAgICAgICAgY29uc3QgYnVmMVBvcyA9ICh5UG9zICogd0RzdDIgKyBqKSAqIDQ7XG4gICAgICAgIGNvbnN0IGJ1ZjJQb3MgPSAoaSAqIHdEc3QyICsgaikgKiA0O1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDQ7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGtQb3MgPSBidWYxUG9zICsgaztcbiAgICAgICAgICBjb25zdCB5MCA9IHlQb3MgPiAwID8gYnVmMVtrUG9zIC0gd0RzdDIgKiA0XSA6IDIgKiBidWYxW2tQb3NdIC0gYnVmMVtrUG9zICsgd0RzdDIgKiA0XTtcbiAgICAgICAgICBjb25zdCB5MSA9IGJ1ZjFba1Bvc107XG4gICAgICAgICAgY29uc3QgeTIgPSBidWYxW2tQb3MgKyB3RHN0MiAqIDRdO1xuICAgICAgICAgIGNvbnN0IHkzID0geVBvcyA8IGhTcmMgLSAyID8gYnVmMVtrUG9zICsgd0RzdDIgKiA4XSA6IDIgKiBidWYxW2tQb3MgKyB3RHN0MiAqIDRdIC0gYnVmMVtrUG9zXTtcbiAgICAgICAgICBidWYyW2J1ZjJQb3MgKyBrXSA9IGludGVycG9sYXRlKHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGlzLl93cml0ZUZpbGUod0RzdDIsIGhEc3QyLCBidWYyLCBcIm91dC9idWYyLmpwZ1wiKTtcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUGFzcyAzIC0gc2NhbGUgdG8gZHN0XG4gICAgY29uc3QgbSA9IHdNICogaE07XG4gICAgaWYgKG0gPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhEc3Q7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdEc3Q7IGorKykge1xuICAgICAgICAgIC8vIGkmaiBpbiBkc3QgYm91bmRlZCBjb29yZHNcbiAgICAgICAgICBsZXQgciA9IDA7XG4gICAgICAgICAgbGV0IGcgPSAwO1xuICAgICAgICAgIGxldCBiID0gMDtcbiAgICAgICAgICBsZXQgYSA9IDA7XG4gICAgICAgICAgbGV0IHJlYWxDb2xvcnMgPSAwO1xuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaE07IHkrKykge1xuICAgICAgICAgICAgY29uc3QgeVBvcyA9IGkgKiBoTSArIHk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdNOyB4KyspIHtcbiAgICAgICAgICAgICAgY29uc3QgeFBvcyA9IGogKiB3TSArIHg7XG4gICAgICAgICAgICAgIGNvbnN0IHh5UG9zID0gKHlQb3MgKiB3RHN0MiArIHhQb3MpICogNDtcbiAgICAgICAgICAgICAgY29uc3QgcGl4ZWxBbHBoYSA9IGJ1ZjJbeHlQb3MgKyAzXTtcbiAgICAgICAgICAgICAgaWYgKHBpeGVsQWxwaGEpIHtcbiAgICAgICAgICAgICAgICByICs9IGJ1ZjJbeHlQb3NdO1xuICAgICAgICAgICAgICAgIGcgKz0gYnVmMlt4eVBvcyArIDFdO1xuICAgICAgICAgICAgICAgIGIgKz0gYnVmMlt4eVBvcyArIDJdO1xuICAgICAgICAgICAgICAgIHJlYWxDb2xvcnMrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhICs9IHBpeGVsQWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvcyA9IChpICogd0RzdCArIGopICogNDtcbiAgICAgICAgICBidWZEc3RbcG9zXSA9IHJlYWxDb2xvcnMgPyBNYXRoLnJvdW5kKHIgLyByZWFsQ29sb3JzKSA6IDA7XG4gICAgICAgICAgYnVmRHN0W3BvcyArIDFdID0gcmVhbENvbG9ycyA/IE1hdGgucm91bmQoZyAvIHJlYWxDb2xvcnMpIDogMDtcbiAgICAgICAgICBidWZEc3RbcG9zICsgMl0gPSByZWFsQ29sb3JzID8gTWF0aC5yb3VuZChiIC8gcmVhbENvbG9ycykgOiAwO1xuICAgICAgICAgIGJ1ZkRzdFtwb3MgKyAzXSA9IE1hdGgucm91bmQoYSAvIG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlcGxhY2UgZHN0IGJ1ZmZlciB3aXRoIGJ1ZjJcbiAgICAgIGRzdC5kYXRhID0gYnVmMjtcbiAgICB9XG4gIH0sXG4gIGJpY3ViaWNJbnRlcnBvbGF0aW9uKHNyYywgZHN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVDdWJpYyA9IGZ1bmN0aW9uICh4MCwgeDEsIHgyLCB4MywgdCkge1xuICAgICAgY29uc3QgYTAgPSB4MyAtIHgyIC0geDAgKyB4MTtcbiAgICAgIGNvbnN0IGExID0geDAgLSB4MSAtIGEwO1xuICAgICAgY29uc3QgYTIgPSB4MiAtIHgwO1xuICAgICAgY29uc3QgYTMgPSB4MTtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGEwICogKHQgKiB0ICogdCkgKyBhMSAqICh0ICogdCkgKyBhMiAqIHQgKyBhMykpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRlMkQoc3JjLCBkc3QsIG9wdGlvbnMsIGludGVycG9sYXRlQ3ViaWMpO1xuICB9LFxuICBoZXJtaXRlSW50ZXJwb2xhdGlvbihzcmMsIGRzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGludGVycG9sYXRlSGVybWl0ZSA9IGZ1bmN0aW9uICh4MCwgeDEsIHgyLCB4MywgdCkge1xuICAgICAgY29uc3QgYzAgPSB4MTtcbiAgICAgIGNvbnN0IGMxID0gMC41ICogKHgyIC0geDApO1xuICAgICAgY29uc3QgYzIgPSB4MCAtIDIuNSAqIHgxICsgMiAqIHgyIC0gMC41ICogeDM7XG4gICAgICBjb25zdCBjMyA9IDAuNSAqICh4MyAtIHgwKSArIDEuNSAqICh4MSAtIHgyKTtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoKChjMyAqIHQgKyBjMikgKiB0ICsgYzEpICogdCArIGMwKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRlMkQoc3JjLCBkc3QsIG9wdGlvbnMsIGludGVycG9sYXRlSGVybWl0ZSk7XG4gIH0sXG4gIGJlemllckludGVycG9sYXRpb24oc3JjLCBkc3QsIG9wdGlvbnMpIHtcbiAgICAvLyBiZXR3ZWVuIDIgcG9pbnRzIHkobiksIHkobisxKSwgdXNlIG5leHQgcG9pbnRzIG91dCwgeShuLTEpLCB5KG4rMilcbiAgICAvLyB0byBwcmVkaWN0IGNvbnRyb2wgcG9pbnRzIChhICYgYikgdG8gYmUgcGxhY2VkIGF0IG4rMC41XG4gICAgLy8gIHlhKG4pID0geShuKSArICh5KG4rMSkteShuLTEpKS80XG4gICAgLy8gIHliKG4pID0geShuKzEpIC0gKHkobisyKS15KG4pKS80XG4gICAgLy8gdGhlbiB1c2Ugc3RkIGJlemllciB0byBpbnRlcnBvbGF0ZSBbbixuKzEpXG4gICAgLy8gIHkobit0KSA9IHkobikqKDEtdCleMyArIDMgKiB5YShuKSooMS10KV4yKnQgKyAzICogeWIobikqKDEtdCkqdF4yICsgeShuKzEpKnReM1xuICAgIC8vICBub3RlIHRoZSAzKiBmYWN0b3IgZm9yIHRoZSB0d28gY29udHJvbCBwb2ludHNcbiAgICAvLyBmb3IgZWRnZSBjYXNlcywgY2FuIGNob29zZTpcbiAgICAvLyAgeSgtMSkgPSB5KDApIC0gMiooeSgxKS15KDApKVxuICAgIC8vICB5KHcpID0geSh3LTEpICsgMiooeSh3LTEpLXkody0yKSlcbiAgICAvLyBidXQgY2FuIGdvIHdpdGggeSgtMSkgPSB5KDApIGFuZCB5KHcpID0geSh3LTEpXG4gICAgY29uc3QgaW50ZXJwb2xhdGVCZXppZXIgPSBmdW5jdGlvbiAoeDAsIHgxLCB4MiwgeDMsIHQpIHtcbiAgICAgIC8vIHgxLCB4MiBhcmUgdGhlIGtub3RzLCB1c2UgeDAgYW5kIHgzIHRvIGNhbGN1bGF0ZSBjb250cm9sIHBvaW50c1xuICAgICAgY29uc3QgY3AxID0geDEgKyAoeDIgLSB4MCkgLyA0O1xuICAgICAgY29uc3QgY3AyID0geDIgLSAoeDMgLSB4MSkgLyA0O1xuICAgICAgY29uc3QgbnQgPSAxIC0gdDtcbiAgICAgIGNvbnN0IGMwID0geDEgKiBudCAqIG50ICogbnQ7XG4gICAgICBjb25zdCBjMSA9IDMgKiBjcDEgKiBudCAqIG50ICogdDtcbiAgICAgIGNvbnN0IGMyID0gMyAqIGNwMiAqIG50ICogdCAqIHQ7XG4gICAgICBjb25zdCBjMyA9IHgyICogdCAqIHQgKiB0O1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChjMCArIGMxICsgYzIgKyBjMykpKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0ZTJEKHNyYywgZHN0LCBvcHRpb25zLCBpbnRlcnBvbGF0ZUJlemllcik7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBvcGVyYXRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaXplMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-resize/es/modules/resize2.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-rotate/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-rotate/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Rotates an image counter-clockwise by multiple of 90 degrees. NB: 'this' must be a Jimp object.\n *\n * This function is based on matrix rotation. Check this to get an initial idea how it works: https://stackoverflow.com/a/8664879/10561909\n *\n * @param {number} deg the number of degrees to rotate the image by, it should be a multiple of 90\n */\nfunction matrixRotate(deg) {\n  if (Math.abs(deg) % 90 !== 0) {\n    throw new Error(\"Unsupported matrix rotation degree\");\n  }\n  deg %= 360;\n  if (Math.abs(deg) === 0) {\n    // no rotation for 0, 360, -360, 720, -720, ...\n    return;\n  }\n  const w = this.bitmap.width;\n  const h = this.bitmap.height;\n\n  // decide which rotation angle to use\n  let angle;\n  switch (deg) {\n    // 90 degree & -270 degree are same\n    case 90:\n    case -270:\n      angle = 90;\n      break;\n    case 180:\n    case -180:\n      angle = 180;\n      break;\n    case 270:\n    case -90:\n      angle = -90;\n      break;\n    default:\n      throw new Error(\"Unsupported matrix rotation degree\");\n  }\n  // After this switch block, angle will be 90, 180 or -90\n\n  // calculate the new width and height\n  const nW = angle === 180 ? w : h;\n  const nH = angle === 180 ? h : w;\n  const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n  // function to translate the x, y coordinate to the index of the pixel in the buffer\n  function createIdxTranslationFunction(w, h) {\n    return function (x, y) {\n      return y * w + x << 2;\n    };\n  }\n  const srcIdxFunction = createIdxTranslationFunction(w, h);\n  const dstIdxFunction = createIdxTranslationFunction(nW, nH);\n  for (let x = 0; x < w; x++) {\n    for (let y = 0; y < h; y++) {\n      const srcIdx = srcIdxFunction(x, y);\n      const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n      let dstIdx;\n      switch (angle) {\n        case 90:\n          dstIdx = dstIdxFunction(y, w - x - 1);\n          break;\n        case -90:\n          dstIdx = dstIdxFunction(h - y - 1, x);\n          break;\n        case 180:\n          dstIdx = dstIdxFunction(w - x - 1, h - y - 1);\n          break;\n        default:\n          throw new Error(\"Unsupported matrix rotation angle\");\n      }\n      dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n    }\n  }\n  this.bitmap.data = dstBuffer;\n  this.bitmap.width = nW;\n  this.bitmap.height = nH;\n}\n\n/**\n * Rotates an image counter-clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\nfunction advancedRotate(deg, mode) {\n  deg %= 360;\n  const rad = deg * Math.PI / 180;\n  const cosine = Math.cos(rad);\n  const sine = Math.sin(rad);\n\n  // the final width and height will change if resize == true\n  let w = this.bitmap.width;\n  let h = this.bitmap.height;\n  if (mode === true || typeof mode === \"string\") {\n    // resize the image to it maximum dimension and blit the existing image\n    // onto the center so that when it is rotated the image is kept in bounds\n\n    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n    // Plus 1 border pixel to ensure to show all rotated result for some cases.\n    w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;\n    h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1;\n    // Ensure destination to have even size to a better result.\n    if (w % 2 !== 0) {\n      w++;\n    }\n    if (h % 2 !== 0) {\n      h++;\n    }\n    const c = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    const max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n    this.resize(max, max, mode);\n    this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);\n  }\n  const bW = this.bitmap.width;\n  const bH = this.bitmap.height;\n  const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n  function createTranslationFunction(deltaX, deltaY) {\n    return function (x, y) {\n      return {\n        x: x + deltaX,\n        y: y + deltaY\n      };\n    };\n  }\n  const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n  const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);\n  for (let y = 1; y <= bH; y++) {\n    for (let x = 1; x <= bW; x++) {\n      const cartesian = translate2Cartesian(x, y);\n      const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);\n      const dstIdx = bW * (y - 1) + x - 1 << 2;\n      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n        const srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;\n        const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n      } else {\n        // reset off-image pixels\n        dstBuffer.writeUInt32BE(this._background, dstIdx);\n      }\n    }\n  }\n  this.bitmap.data = dstBuffer;\n  if (mode === true || typeof mode === \"string\") {\n    // now crop the image to the final size\n    const x = bW / 2 - w / 2;\n    const y = bH / 2 - h / 2;\n    this.crop(x, y, w, h);\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  /**\n   * Rotates the image counter-clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n   * @param {number} deg the number of degrees to rotate the image by\n   * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rotate(deg, mode, cb) {\n    // enable overloading\n    if (typeof mode === \"undefined\" || mode === null) {\n      // e.g. image.resize(120);\n      // e.g. image.resize(120, null, cb);\n      // e.g. image.resize(120, undefined, cb);\n      mode = true;\n    }\n    if (typeof mode === \"function\" && typeof cb === \"undefined\") {\n      // e.g. image.resize(120, cb);\n      cb = mode;\n      mode = true;\n    }\n    if (typeof deg !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"deg must be a number\", cb);\n    }\n    if (typeof mode !== \"boolean\" && typeof mode !== \"string\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"mode must be a boolean or a string\", cb);\n    }\n\n    // use matrixRotate if the angle is a multiple of 90 degrees (eg: 180 or -90) and resize is allowed or not needed.\n    const matrixRotateAllowed = deg % 90 === 0 && (mode || this.bitmap.width === this.bitmap.height || deg % 180 === 0);\n    if (matrixRotateAllowed) {\n      matrixRotate.call(this, deg);\n    } else {\n      advancedRotate.call(this, deg, mode, cb);\n    }\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcm90YXRlL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLEVBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yb3RhdGUvZXMvaW5kZXguanM/OWQ4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5cbi8qKlxuICogUm90YXRlcyBhbiBpbWFnZSBjb3VudGVyLWNsb2Nrd2lzZSBieSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLiBOQjogJ3RoaXMnIG11c3QgYmUgYSBKaW1wIG9iamVjdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIG1hdHJpeCByb3RhdGlvbi4gQ2hlY2sgdGhpcyB0byBnZXQgYW4gaW5pdGlhbCBpZGVhIGhvdyBpdCB3b3JrczogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg2NjQ4NzkvMTA1NjE5MDlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnIHRoZSBudW1iZXIgb2YgZGVncmVlcyB0byByb3RhdGUgdGhlIGltYWdlIGJ5LCBpdCBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiA5MFxuICovXG5mdW5jdGlvbiBtYXRyaXhSb3RhdGUoZGVnKSB7XG4gIGlmIChNYXRoLmFicyhkZWcpICUgOTAgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBtYXRyaXggcm90YXRpb24gZGVncmVlXCIpO1xuICB9XG4gIGRlZyAlPSAzNjA7XG4gIGlmIChNYXRoLmFicyhkZWcpID09PSAwKSB7XG4gICAgLy8gbm8gcm90YXRpb24gZm9yIDAsIDM2MCwgLTM2MCwgNzIwLCAtNzIwLCAuLi5cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdyA9IHRoaXMuYml0bWFwLndpZHRoO1xuICBjb25zdCBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuXG4gIC8vIGRlY2lkZSB3aGljaCByb3RhdGlvbiBhbmdsZSB0byB1c2VcbiAgbGV0IGFuZ2xlO1xuICBzd2l0Y2ggKGRlZykge1xuICAgIC8vIDkwIGRlZ3JlZSAmIC0yNzAgZGVncmVlIGFyZSBzYW1lXG4gICAgY2FzZSA5MDpcbiAgICBjYXNlIC0yNzA6XG4gICAgICBhbmdsZSA9IDkwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxODA6XG4gICAgY2FzZSAtMTgwOlxuICAgICAgYW5nbGUgPSAxODA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI3MDpcbiAgICBjYXNlIC05MDpcbiAgICAgIGFuZ2xlID0gLTkwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG1hdHJpeCByb3RhdGlvbiBkZWdyZWVcIik7XG4gIH1cbiAgLy8gQWZ0ZXIgdGhpcyBzd2l0Y2ggYmxvY2ssIGFuZ2xlIHdpbGwgYmUgOTAsIDE4MCBvciAtOTBcblxuICAvLyBjYWxjdWxhdGUgdGhlIG5ldyB3aWR0aCBhbmQgaGVpZ2h0XG4gIGNvbnN0IG5XID0gYW5nbGUgPT09IDE4MCA/IHcgOiBoO1xuICBjb25zdCBuSCA9IGFuZ2xlID09PSAxODAgPyBoIDogdztcbiAgY29uc3QgZHN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRoaXMuYml0bWFwLmRhdGEubGVuZ3RoKTtcblxuICAvLyBmdW5jdGlvbiB0byB0cmFuc2xhdGUgdGhlIHgsIHkgY29vcmRpbmF0ZSB0byB0aGUgaW5kZXggb2YgdGhlIHBpeGVsIGluIHRoZSBidWZmZXJcbiAgZnVuY3Rpb24gY3JlYXRlSWR4VHJhbnNsYXRpb25GdW5jdGlvbih3LCBoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geSAqIHcgKyB4IDw8IDI7XG4gICAgfTtcbiAgfVxuICBjb25zdCBzcmNJZHhGdW5jdGlvbiA9IGNyZWF0ZUlkeFRyYW5zbGF0aW9uRnVuY3Rpb24odywgaCk7XG4gIGNvbnN0IGRzdElkeEZ1bmN0aW9uID0gY3JlYXRlSWR4VHJhbnNsYXRpb25GdW5jdGlvbihuVywgbkgpO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHc7IHgrKykge1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICBjb25zdCBzcmNJZHggPSBzcmNJZHhGdW5jdGlvbih4LCB5KTtcbiAgICAgIGNvbnN0IHBpeGVsUkdCQSA9IHRoaXMuYml0bWFwLmRhdGEucmVhZFVJbnQzMkJFKHNyY0lkeCk7XG4gICAgICBsZXQgZHN0SWR4O1xuICAgICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgIGRzdElkeCA9IGRzdElkeEZ1bmN0aW9uKHksIHcgLSB4IC0gMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTkwOlxuICAgICAgICAgIGRzdElkeCA9IGRzdElkeEZ1bmN0aW9uKGggLSB5IC0gMSwgeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgIGRzdElkeCA9IGRzdElkeEZ1bmN0aW9uKHcgLSB4IC0gMSwgaCAtIHkgLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBtYXRyaXggcm90YXRpb24gYW5nbGVcIik7XG4gICAgICB9XG4gICAgICBkc3RCdWZmZXIud3JpdGVVSW50MzJCRShwaXhlbFJHQkEsIGRzdElkeCk7XG4gICAgfVxuICB9XG4gIHRoaXMuYml0bWFwLmRhdGEgPSBkc3RCdWZmZXI7XG4gIHRoaXMuYml0bWFwLndpZHRoID0gblc7XG4gIHRoaXMuYml0bWFwLmhlaWdodCA9IG5IO1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYW4gaW1hZ2UgY291bnRlci1jbG9ja3dpc2UgYnkgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBkZWdyZWVzLiBOQjogJ3RoaXMnIG11c3QgYmUgYSBKaW1wIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgdGhlIG51bWJlciBvZiBkZWdyZWVzIHRvIHJvdGF0ZSB0aGUgaW1hZ2UgYnlcbiAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IG1vZGUgKG9wdGlvbmFsKSByZXNpemUgbW9kZSBvciBhIGJvb2xlYW4sIGlmIGZhbHNlIHRoZW4gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGltYWdlIHdpbGwgbm90IGJlIGNoYW5nZWRcbiAqL1xuZnVuY3Rpb24gYWR2YW5jZWRSb3RhdGUoZGVnLCBtb2RlKSB7XG4gIGRlZyAlPSAzNjA7XG4gIGNvbnN0IHJhZCA9IGRlZyAqIE1hdGguUEkgLyAxODA7XG4gIGNvbnN0IGNvc2luZSA9IE1hdGguY29zKHJhZCk7XG4gIGNvbnN0IHNpbmUgPSBNYXRoLnNpbihyYWQpO1xuXG4gIC8vIHRoZSBmaW5hbCB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgY2hhbmdlIGlmIHJlc2l6ZSA9PSB0cnVlXG4gIGxldCB3ID0gdGhpcy5iaXRtYXAud2lkdGg7XG4gIGxldCBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0O1xuICBpZiAobW9kZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgbW9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gaXQgbWF4aW11bSBkaW1lbnNpb24gYW5kIGJsaXQgdGhlIGV4aXN0aW5nIGltYWdlXG4gICAgLy8gb250byB0aGUgY2VudGVyIHNvIHRoYXQgd2hlbiBpdCBpcyByb3RhdGVkIHRoZSBpbWFnZSBpcyBrZXB0IGluIGJvdW5kc1xuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMjMxMTc2L2hvdy10by1nZXQtc2l6ZS1vZi1hLXJvdGF0ZWQtcmVjdGFuZ2xlXG4gICAgLy8gUGx1cyAxIGJvcmRlciBwaXhlbCB0byBlbnN1cmUgdG8gc2hvdyBhbGwgcm90YXRlZCByZXN1bHQgZm9yIHNvbWUgY2FzZXMuXG4gICAgdyA9IE1hdGguY2VpbChNYXRoLmFicyh0aGlzLmJpdG1hcC53aWR0aCAqIGNvc2luZSkgKyBNYXRoLmFicyh0aGlzLmJpdG1hcC5oZWlnaHQgKiBzaW5lKSkgKyAxO1xuICAgIGggPSBNYXRoLmNlaWwoTWF0aC5hYnModGhpcy5iaXRtYXAud2lkdGggKiBzaW5lKSArIE1hdGguYWJzKHRoaXMuYml0bWFwLmhlaWdodCAqIGNvc2luZSkpICsgMTtcbiAgICAvLyBFbnN1cmUgZGVzdGluYXRpb24gdG8gaGF2ZSBldmVuIHNpemUgdG8gYSBiZXR0ZXIgcmVzdWx0LlxuICAgIGlmICh3ICUgMiAhPT0gMCkge1xuICAgICAgdysrO1xuICAgIH1cbiAgICBpZiAoaCAlIDIgIT09IDApIHtcbiAgICAgIGgrKztcbiAgICB9XG4gICAgY29uc3QgYyA9IHRoaXMuY2xvbmVRdWlldCgpO1xuICAgIHRoaXMuc2NhblF1aWV0KDAsIDAsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGEud3JpdGVVSW50MzJCRSh0aGlzLl9iYWNrZ3JvdW5kLCBpZHgpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHcsIGgsIHRoaXMuYml0bWFwLndpZHRoLCB0aGlzLmJpdG1hcC5oZWlnaHQpO1xuICAgIHRoaXMucmVzaXplKG1heCwgbWF4LCBtb2RlKTtcbiAgICB0aGlzLmJsaXQoYywgdGhpcy5iaXRtYXAud2lkdGggLyAyIC0gYy5iaXRtYXAud2lkdGggLyAyLCB0aGlzLmJpdG1hcC5oZWlnaHQgLyAyIC0gYy5iaXRtYXAuaGVpZ2h0IC8gMik7XG4gIH1cbiAgY29uc3QgYlcgPSB0aGlzLmJpdG1hcC53aWR0aDtcbiAgY29uc3QgYkggPSB0aGlzLmJpdG1hcC5oZWlnaHQ7XG4gIGNvbnN0IGRzdEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0aGlzLmJpdG1hcC5kYXRhLmxlbmd0aCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVRyYW5zbGF0aW9uRnVuY3Rpb24oZGVsdGFYLCBkZWx0YVkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkZWx0YVgsXG4gICAgICAgIHk6IHkgKyBkZWx0YVlcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBjb25zdCB0cmFuc2xhdGUyQ2FydGVzaWFuID0gY3JlYXRlVHJhbnNsYXRpb25GdW5jdGlvbigtKGJXIC8gMiksIC0oYkggLyAyKSk7XG4gIGNvbnN0IHRyYW5zbGF0ZTJTY3JlZW4gPSBjcmVhdGVUcmFuc2xhdGlvbkZ1bmN0aW9uKGJXIC8gMiArIDAuNSwgYkggLyAyICsgMC41KTtcbiAgZm9yIChsZXQgeSA9IDE7IHkgPD0gYkg7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAxOyB4IDw9IGJXOyB4KyspIHtcbiAgICAgIGNvbnN0IGNhcnRlc2lhbiA9IHRyYW5zbGF0ZTJDYXJ0ZXNpYW4oeCwgeSk7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0cmFuc2xhdGUyU2NyZWVuKGNvc2luZSAqIGNhcnRlc2lhbi54IC0gc2luZSAqIGNhcnRlc2lhbi55LCBjb3NpbmUgKiBjYXJ0ZXNpYW4ueSArIHNpbmUgKiBjYXJ0ZXNpYW4ueCk7XG4gICAgICBjb25zdCBkc3RJZHggPSBiVyAqICh5IC0gMSkgKyB4IC0gMSA8PCAyO1xuICAgICAgaWYgKHNvdXJjZS54ID49IDAgJiYgc291cmNlLnggPCBiVyAmJiBzb3VyY2UueSA+PSAwICYmIHNvdXJjZS55IDwgYkgpIHtcbiAgICAgICAgY29uc3Qgc3JjSWR4ID0gKGJXICogKHNvdXJjZS55IHwgMCkgKyBzb3VyY2UueCB8IDApIDw8IDI7XG4gICAgICAgIGNvbnN0IHBpeGVsUkdCQSA9IHRoaXMuYml0bWFwLmRhdGEucmVhZFVJbnQzMkJFKHNyY0lkeCk7XG4gICAgICAgIGRzdEJ1ZmZlci53cml0ZVVJbnQzMkJFKHBpeGVsUkdCQSwgZHN0SWR4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc2V0IG9mZi1pbWFnZSBwaXhlbHNcbiAgICAgICAgZHN0QnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5fYmFja2dyb3VuZCwgZHN0SWR4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5iaXRtYXAuZGF0YSA9IGRzdEJ1ZmZlcjtcbiAgaWYgKG1vZGUgPT09IHRydWUgfHwgdHlwZW9mIG1vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyBub3cgY3JvcCB0aGUgaW1hZ2UgdG8gdGhlIGZpbmFsIHNpemVcbiAgICBjb25zdCB4ID0gYlcgLyAyIC0gdyAvIDI7XG4gICAgY29uc3QgeSA9IGJIIC8gMiAtIGggLyAyO1xuICAgIHRoaXMuY3JvcCh4LCB5LCB3LCBoKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgKCgpID0+ICh7XG4gIC8qKlxuICAgKiBSb3RhdGVzIHRoZSBpbWFnZSBjb3VudGVyLWNsb2Nrd2lzZSBieSBhIG51bWJlciBvZiBkZWdyZWVzLiBCeSBkZWZhdWx0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgYXBwcm9wcmlhdGVseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZyB0aGUgbnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpbWFnZSBieVxuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBtb2RlIChvcHRpb25hbCkgcmVzaXplIG1vZGUgb3IgYSBib29sZWFuLCBpZiBmYWxzZSB0aGVuIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBpbWFnZSB3aWxsIG5vdCBiZSBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIHJvdGF0ZShkZWcsIG1vZGUsIGNiKSB7XG4gICAgLy8gZW5hYmxlIG92ZXJsb2FkaW5nXG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSBcInVuZGVmaW5lZFwiIHx8IG1vZGUgPT09IG51bGwpIHtcbiAgICAgIC8vIGUuZy4gaW1hZ2UucmVzaXplKDEyMCk7XG4gICAgICAvLyBlLmcuIGltYWdlLnJlc2l6ZSgxMjAsIG51bGwsIGNiKTtcbiAgICAgIC8vIGUuZy4gaW1hZ2UucmVzaXplKDEyMCwgdW5kZWZpbmVkLCBjYik7XG4gICAgICBtb2RlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNiID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBlLmcuIGltYWdlLnJlc2l6ZSgxMjAsIGNiKTtcbiAgICAgIGNiID0gbW9kZTtcbiAgICAgIG1vZGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlZyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcImRlZyBtdXN0IGJlIGEgbnVtYmVyXCIsIGNiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtb2RlICE9PSBcImJvb2xlYW5cIiAmJiB0eXBlb2YgbW9kZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIm1vZGUgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBzdHJpbmdcIiwgY2IpO1xuICAgIH1cblxuICAgIC8vIHVzZSBtYXRyaXhSb3RhdGUgaWYgdGhlIGFuZ2xlIGlzIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcyAoZWc6IDE4MCBvciAtOTApIGFuZCByZXNpemUgaXMgYWxsb3dlZCBvciBub3QgbmVlZGVkLlxuICAgIGNvbnN0IG1hdHJpeFJvdGF0ZUFsbG93ZWQgPSBkZWcgJSA5MCA9PT0gMCAmJiAobW9kZSB8fCB0aGlzLmJpdG1hcC53aWR0aCA9PT0gdGhpcy5iaXRtYXAuaGVpZ2h0IHx8IGRlZyAlIDE4MCA9PT0gMCk7XG4gICAgaWYgKG1hdHJpeFJvdGF0ZUFsbG93ZWQpIHtcbiAgICAgIG1hdHJpeFJvdGF0ZS5jYWxsKHRoaXMsIGRlZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdmFuY2VkUm90YXRlLmNhbGwodGhpcywgZGVnLCBtb2RlLCBjYik7XG4gICAgfVxuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-rotate/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-scale/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jimp/plugin-scale/es/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  /**\n   * Uniformly scales the image by a factor.\n   * @param {number} f the factor to scale the image by\n   * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  scale(f, mode, cb) {\n    if (typeof f !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"f must be a number\", cb);\n    }\n    if (f < 0) {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"f must be a positive number\", cb);\n    }\n    if (typeof mode === \"function\" && typeof cb === \"undefined\") {\n      cb = mode;\n      mode = null;\n    }\n    const w = this.bitmap.width * f;\n    const h = this.bitmap.height * f;\n    this.resize(w, h, mode);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  },\n  /**\n   * Scale the image to the largest size that fits inside the rectangle that has the given width and height.\n   * @param {number} w the width to resize the image to\n   * @param {number} h the height to resize the image to\n   * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  scaleToFit(w, h, mode, cb) {\n    if (typeof w !== \"number\" || typeof h !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"w and h must be numbers\", cb);\n    }\n    if (typeof mode === \"function\" && typeof cb === \"undefined\") {\n      cb = mode;\n      mode = null;\n    }\n    const f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;\n    this.scale(f, mode);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tc2NhbGUvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0Q7QUFDeEQsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLG1EQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLEVBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1zY2FsZS9lcy9pbmRleC5qcz84ZTZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTm9kZVBhdHRlcm4sIHRocm93RXJyb3IgfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiAoe1xuICAvKipcbiAgICogVW5pZm9ybWx5IHNjYWxlcyB0aGUgaW1hZ2UgYnkgYSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmIHRoZSBmYWN0b3IgdG8gc2NhbGUgdGhlIGltYWdlIGJ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIChvcHRpb25hbCkgYSBzY2FsaW5nIG1ldGhvZCAoZS5nLiBKaW1wLlJFU0laRV9CRVpJRVIpXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICovXG4gIHNjYWxlKGYsIG1vZGUsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBmICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiZiBtdXN0IGJlIGEgbnVtYmVyXCIsIGNiKTtcbiAgICB9XG4gICAgaWYgKGYgPCAwKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiZiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIsIGNiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNiID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjYiA9IG1vZGU7XG4gICAgICBtb2RlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdyA9IHRoaXMuYml0bWFwLndpZHRoICogZjtcbiAgICBjb25zdCBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0ICogZjtcbiAgICB0aGlzLnJlc2l6ZSh3LCBoLCBtb2RlKTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogU2NhbGUgdGhlIGltYWdlIHRvIHRoZSBsYXJnZXN0IHNpemUgdGhhdCBmaXRzIGluc2lkZSB0aGUgcmVjdGFuZ2xlIHRoYXQgaGFzIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdyB0aGUgd2lkdGggdG8gcmVzaXplIHRoZSBpbWFnZSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gaCB0aGUgaGVpZ2h0IHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgKG9wdGlvbmFsKSBhIHNjYWxpbmcgbWV0aG9kIChlLmcuIEppbXAuUkVTSVpFX0JFWklFUilcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgKi9cbiAgc2NhbGVUb0ZpdCh3LCBoLCBtb2RlLCBjYikge1xuICAgIGlmICh0eXBlb2YgdyAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgaCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIncgYW5kIGggbXVzdCBiZSBudW1iZXJzXCIsIGNiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNiID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjYiA9IG1vZGU7XG4gICAgICBtb2RlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZiA9IHcgLyBoID4gdGhpcy5iaXRtYXAud2lkdGggLyB0aGlzLmJpdG1hcC5oZWlnaHQgPyBoIC8gdGhpcy5iaXRtYXAuaGVpZ2h0IDogdyAvIHRoaXMuYml0bWFwLndpZHRoO1xuICAgIHRoaXMuc2NhbGUoZiwgbW9kZSk7XG4gICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-scale/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-shadow/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@jimp/plugin-shadow/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Creates a circle out of an image.\n * @param {function(Error, Jimp)} options (optional)\n * opacity - opacity of the shadow between 0 and 1\n * size,- of the shadow\n * blur - how blurry the shadow is\n * x- x position of shadow\n * y - y position of shadow\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  shadow() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cb = arguments.length > 1 ? arguments[1] : undefined;\n    if (typeof options === \"function\") {\n      cb = options;\n      options = {};\n    }\n    const {\n      opacity = 0.7,\n      size = 1.1,\n      x = -25,\n      y = 25,\n      blur = 5\n    } = options;\n\n    // clone the image\n    const orig = this.clone();\n    const shadow = this.clone();\n\n    // turn all it's pixels black\n    shadow.scan(0, 0, shadow.bitmap.width, shadow.bitmap.height, (x, y, idx) => {\n      shadow.bitmap.data[idx] = 0x00;\n      shadow.bitmap.data[idx + 1] = 0x00;\n      shadow.bitmap.data[idx + 2] = 0x00;\n      // up the opacity a little,\n      shadow.bitmap.data[idx + 3] = shadow.constructor.limit255(shadow.bitmap.data[idx + 3] * opacity);\n      this.bitmap.data[idx] = 0x00;\n      this.bitmap.data[idx + 1] = 0x00;\n      this.bitmap.data[idx + 2] = 0x00;\n      this.bitmap.data[idx + 3] = 0x00;\n    });\n\n    // enlarge it. This creates a \"shadow\".\n    shadow.resize(shadow.bitmap.width * size, shadow.bitmap.height * size).blur(blur);\n\n    // Then blit the \"shadow\" onto the background and the image on top of that.\n    this.composite(shadow, x, y);\n    this.composite(orig, 0, 0);\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tc2hhZG93L2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDOztBQUU1QztBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGlFQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tc2hhZG93L2VzL2luZGV4LmpzPzE4YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOb2RlUGF0dGVybiB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXJjbGUgb3V0IG9mIGFuIGltYWdlLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgSmltcCl9IG9wdGlvbnMgKG9wdGlvbmFsKVxuICogb3BhY2l0eSAtIG9wYWNpdHkgb2YgdGhlIHNoYWRvdyBiZXR3ZWVuIDAgYW5kIDFcbiAqIHNpemUsLSBvZiB0aGUgc2hhZG93XG4gKiBibHVyIC0gaG93IGJsdXJyeSB0aGUgc2hhZG93IGlzXG4gKiB4LSB4IHBvc2l0aW9uIG9mIHNoYWRvd1xuICogeSAtIHkgcG9zaXRpb24gb2Ygc2hhZG93XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgc2hhZG93KCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvcGFjaXR5ID0gMC43LFxuICAgICAgc2l6ZSA9IDEuMSxcbiAgICAgIHggPSAtMjUsXG4gICAgICB5ID0gMjUsXG4gICAgICBibHVyID0gNVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgLy8gY2xvbmUgdGhlIGltYWdlXG4gICAgY29uc3Qgb3JpZyA9IHRoaXMuY2xvbmUoKTtcbiAgICBjb25zdCBzaGFkb3cgPSB0aGlzLmNsb25lKCk7XG5cbiAgICAvLyB0dXJuIGFsbCBpdCdzIHBpeGVscyBibGFja1xuICAgIHNoYWRvdy5zY2FuKDAsIDAsIHNoYWRvdy5iaXRtYXAud2lkdGgsIHNoYWRvdy5iaXRtYXAuaGVpZ2h0LCAoeCwgeSwgaWR4KSA9PiB7XG4gICAgICBzaGFkb3cuYml0bWFwLmRhdGFbaWR4XSA9IDB4MDA7XG4gICAgICBzaGFkb3cuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSAweDAwO1xuICAgICAgc2hhZG93LmJpdG1hcC5kYXRhW2lkeCArIDJdID0gMHgwMDtcbiAgICAgIC8vIHVwIHRoZSBvcGFjaXR5IGEgbGl0dGxlLFxuICAgICAgc2hhZG93LmJpdG1hcC5kYXRhW2lkeCArIDNdID0gc2hhZG93LmNvbnN0cnVjdG9yLmxpbWl0MjU1KHNoYWRvdy5iaXRtYXAuZGF0YVtpZHggKyAzXSAqIG9wYWNpdHkpO1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHhdID0gMHgwMDtcbiAgICAgIHRoaXMuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSAweDAwO1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IDB4MDA7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDNdID0gMHgwMDtcbiAgICB9KTtcblxuICAgIC8vIGVubGFyZ2UgaXQuIFRoaXMgY3JlYXRlcyBhIFwic2hhZG93XCIuXG4gICAgc2hhZG93LnJlc2l6ZShzaGFkb3cuYml0bWFwLndpZHRoICogc2l6ZSwgc2hhZG93LmJpdG1hcC5oZWlnaHQgKiBzaXplKS5ibHVyKGJsdXIpO1xuXG4gICAgLy8gVGhlbiBibGl0IHRoZSBcInNoYWRvd1wiIG9udG8gdGhlIGJhY2tncm91bmQgYW5kIHRoZSBpbWFnZSBvbiB0b3Agb2YgdGhhdC5cbiAgICB0aGlzLmNvbXBvc2l0ZShzaGFkb3csIHgsIHkpO1xuICAgIHRoaXMuY29tcG9zaXRlKG9yaWcsIDAsIDApO1xuICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-shadow/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugin-threshold/es/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@jimp/plugin-threshold/es/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\n/**\n * Applies a minimum color threshold to a greyscale image.  Converts image to greyscale by default\n * @param {number} options object\n *  max: A number auto limited between 0 - 255\n *  replace: (optional) A number auto limited between 0 - 255 (default 255)\n *  autoGreyscale: (optional) A boolean whether to apply greyscale beforehand (default true)\n * @param {number} cb (optional) a callback for when complete\n * @return {this} this for chaining of methods\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  threshold(_ref, cb) {\n    let {\n      max,\n      replace = 255,\n      autoGreyscale = true\n    } = _ref;\n    if (typeof max !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"max must be a number\", cb);\n    }\n    if (typeof replace !== \"number\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"replace must be a number\", cb);\n    }\n    if (typeof autoGreyscale !== \"boolean\") {\n      return _jimp_utils__WEBPACK_IMPORTED_MODULE_0__.throwError.call(this, \"autoGreyscale must be a boolean\", cb);\n    }\n    max = this.constructor.limit255(max);\n    replace = this.constructor.limit255(replace);\n    if (autoGreyscale) {\n      this.greyscale();\n    }\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {\n      const grey = this.bitmap.data[idx] < max ? this.bitmap.data[idx] : replace;\n      this.bitmap.data[idx] = grey;\n      this.bitmap.data[idx + 1] = grey;\n      this.bitmap.data[idx + 2] = grey;\n    });\n    if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_0__.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tdGhyZXNob2xkL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdEOztBQUV4RDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQSxpRUFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBLGFBQWEsbURBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxRQUFRLDBEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLEVBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi10aHJlc2hvbGQvZXMvaW5kZXguanM/MTc2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05vZGVQYXR0ZXJuLCB0aHJvd0Vycm9yIH0gZnJvbSBcIkBqaW1wL3V0aWxzXCI7XG5cbi8qKlxuICogQXBwbGllcyBhIG1pbmltdW0gY29sb3IgdGhyZXNob2xkIHRvIGEgZ3JleXNjYWxlIGltYWdlLiAgQ29udmVydHMgaW1hZ2UgdG8gZ3JleXNjYWxlIGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zIG9iamVjdFxuICogIG1heDogQSBudW1iZXIgYXV0byBsaW1pdGVkIGJldHdlZW4gMCAtIDI1NVxuICogIHJlcGxhY2U6IChvcHRpb25hbCkgQSBudW1iZXIgYXV0byBsaW1pdGVkIGJldHdlZW4gMCAtIDI1NSAoZGVmYXVsdCAyNTUpXG4gKiAgYXV0b0dyZXlzY2FsZTogKG9wdGlvbmFsKSBBIGJvb2xlYW4gd2hldGhlciB0byBhcHBseSBncmV5c2NhbGUgYmVmb3JlaGFuZCAoZGVmYXVsdCB0cnVlKVxuICogQHBhcmFtIHtudW1iZXJ9IGNiIChvcHRpb25hbCkgYSBjYWxsYmFjayBmb3Igd2hlbiBjb21wbGV0ZVxuICogQHJldHVybiB7dGhpc30gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gKHtcbiAgdGhyZXNob2xkKF9yZWYsIGNiKSB7XG4gICAgbGV0IHtcbiAgICAgIG1heCxcbiAgICAgIHJlcGxhY2UgPSAyNTUsXG4gICAgICBhdXRvR3JleXNjYWxlID0gdHJ1ZVxuICAgIH0gPSBfcmVmO1xuICAgIGlmICh0eXBlb2YgbWF4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwibWF4IG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlcGxhY2UgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJyZXBsYWNlIG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGF1dG9HcmV5c2NhbGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwiYXV0b0dyZXlzY2FsZSBtdXN0IGJlIGEgYm9vbGVhblwiLCBjYik7XG4gICAgfVxuICAgIG1heCA9IHRoaXMuY29uc3RydWN0b3IubGltaXQyNTUobWF4KTtcbiAgICByZXBsYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5saW1pdDI1NShyZXBsYWNlKTtcbiAgICBpZiAoYXV0b0dyZXlzY2FsZSkge1xuICAgICAgdGhpcy5ncmV5c2NhbGUoKTtcbiAgICB9XG4gICAgdGhpcy5zY2FuUXVpZXQoMCwgMCwgdGhpcy5iaXRtYXAud2lkdGgsIHRoaXMuYml0bWFwLmhlaWdodCwgKHgsIHksIGlkeCkgPT4ge1xuICAgICAgY29uc3QgZ3JleSA9IHRoaXMuYml0bWFwLmRhdGFbaWR4XSA8IG1heCA/IHRoaXMuYml0bWFwLmRhdGFbaWR4XSA6IHJlcGxhY2U7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeF0gPSBncmV5O1xuICAgICAgdGhpcy5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IGdyZXk7XG4gICAgICB0aGlzLmJpdG1hcC5kYXRhW2lkeCArIDJdID0gZ3JleTtcbiAgICB9KTtcbiAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugin-threshold/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/plugins/es/index.js":
/*!************************************************!*\
  !*** ./node_modules/@jimp/plugins/es/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var timm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timm */ \"(action-browser)/./node_modules/timm/lib/timm.js\");\n/* harmony import */ var _jimp_plugin_blit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/plugin-blit */ \"(action-browser)/./node_modules/@jimp/plugin-blit/es/index.js\");\n/* harmony import */ var _jimp_plugin_blur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/plugin-blur */ \"(action-browser)/./node_modules/@jimp/plugin-blur/es/index.js\");\n/* harmony import */ var _jimp_plugin_circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jimp/plugin-circle */ \"(action-browser)/./node_modules/@jimp/plugin-circle/es/index.js\");\n/* harmony import */ var _jimp_plugin_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jimp/plugin-color */ \"(action-browser)/./node_modules/@jimp/plugin-color/es/index.js\");\n/* harmony import */ var _jimp_plugin_contain__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jimp/plugin-contain */ \"(action-browser)/./node_modules/@jimp/plugin-contain/es/index.js\");\n/* harmony import */ var _jimp_plugin_cover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jimp/plugin-cover */ \"(action-browser)/./node_modules/@jimp/plugin-cover/es/index.js\");\n/* harmony import */ var _jimp_plugin_crop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jimp/plugin-crop */ \"(action-browser)/./node_modules/@jimp/plugin-crop/es/index.js\");\n/* harmony import */ var _jimp_plugin_displace__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @jimp/plugin-displace */ \"(action-browser)/./node_modules/@jimp/plugin-displace/es/index.js\");\n/* harmony import */ var _jimp_plugin_dither__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @jimp/plugin-dither */ \"(action-browser)/./node_modules/@jimp/plugin-dither/es/index.js\");\n/* harmony import */ var _jimp_plugin_fisheye__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @jimp/plugin-fisheye */ \"(action-browser)/./node_modules/@jimp/plugin-fisheye/es/index.js\");\n/* harmony import */ var _jimp_plugin_flip__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @jimp/plugin-flip */ \"(action-browser)/./node_modules/@jimp/plugin-flip/es/index.js\");\n/* harmony import */ var _jimp_plugin_gaussian__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @jimp/plugin-gaussian */ \"(action-browser)/./node_modules/@jimp/plugin-gaussian/es/index.js\");\n/* harmony import */ var _jimp_plugin_invert__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @jimp/plugin-invert */ \"(action-browser)/./node_modules/@jimp/plugin-invert/es/index.js\");\n/* harmony import */ var _jimp_plugin_mask__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @jimp/plugin-mask */ \"(action-browser)/./node_modules/@jimp/plugin-mask/es/index.js\");\n/* harmony import */ var _jimp_plugin_normalize__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @jimp/plugin-normalize */ \"(action-browser)/./node_modules/@jimp/plugin-normalize/es/index.js\");\n/* harmony import */ var _jimp_plugin_print__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @jimp/plugin-print */ \"(action-browser)/./node_modules/@jimp/plugin-print/es/index.js\");\n/* harmony import */ var _jimp_plugin_resize__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @jimp/plugin-resize */ \"(action-browser)/./node_modules/@jimp/plugin-resize/es/index.js\");\n/* harmony import */ var _jimp_plugin_rotate__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @jimp/plugin-rotate */ \"(action-browser)/./node_modules/@jimp/plugin-rotate/es/index.js\");\n/* harmony import */ var _jimp_plugin_scale__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @jimp/plugin-scale */ \"(action-browser)/./node_modules/@jimp/plugin-scale/es/index.js\");\n/* harmony import */ var _jimp_plugin_shadow__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @jimp/plugin-shadow */ \"(action-browser)/./node_modules/@jimp/plugin-shadow/es/index.js\");\n/* harmony import */ var _jimp_plugin_threshold__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @jimp/plugin-threshold */ \"(action-browser)/./node_modules/@jimp/plugin-threshold/es/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst plugins = [_jimp_plugin_blit__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _jimp_plugin_blur__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _jimp_plugin_circle__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _jimp_plugin_color__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _jimp_plugin_contain__WEBPACK_IMPORTED_MODULE_5__[\"default\"], _jimp_plugin_cover__WEBPACK_IMPORTED_MODULE_6__[\"default\"], _jimp_plugin_crop__WEBPACK_IMPORTED_MODULE_7__[\"default\"], _jimp_plugin_displace__WEBPACK_IMPORTED_MODULE_8__[\"default\"], _jimp_plugin_dither__WEBPACK_IMPORTED_MODULE_9__[\"default\"], _jimp_plugin_fisheye__WEBPACK_IMPORTED_MODULE_10__[\"default\"], _jimp_plugin_flip__WEBPACK_IMPORTED_MODULE_11__[\"default\"], _jimp_plugin_gaussian__WEBPACK_IMPORTED_MODULE_12__[\"default\"], _jimp_plugin_invert__WEBPACK_IMPORTED_MODULE_13__[\"default\"], _jimp_plugin_mask__WEBPACK_IMPORTED_MODULE_14__[\"default\"], _jimp_plugin_normalize__WEBPACK_IMPORTED_MODULE_15__[\"default\"], _jimp_plugin_print__WEBPACK_IMPORTED_MODULE_16__[\"default\"], _jimp_plugin_resize__WEBPACK_IMPORTED_MODULE_17__[\"default\"], _jimp_plugin_rotate__WEBPACK_IMPORTED_MODULE_18__[\"default\"], _jimp_plugin_scale__WEBPACK_IMPORTED_MODULE_19__[\"default\"], _jimp_plugin_shadow__WEBPACK_IMPORTED_MODULE_20__[\"default\"], _jimp_plugin_threshold__WEBPACK_IMPORTED_MODULE_21__[\"default\"]];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jimpEvChange => {\n  const initializedPlugins = plugins.map(pluginModule => {\n    let plugin = pluginModule(jimpEvChange) || {};\n    if (!plugin.class && !plugin.constants) {\n      // Default to class function\n      plugin = {\n        class: plugin\n      };\n    }\n    return plugin;\n  });\n  return (0,timm__WEBPACK_IMPORTED_MODULE_0__.mergeDeep)(...initializedPlugins);\n});\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW5zL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQ0k7QUFDQTtBQUNJO0FBQ0Y7QUFDSTtBQUNKO0FBQ0Y7QUFDUTtBQUNKO0FBQ0U7QUFDTjtBQUNRO0FBQ0o7QUFDSjtBQUNVO0FBQ1I7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNNO0FBQy9DLGlCQUFpQix5REFBSSxFQUFFLHlEQUFJLEVBQUUsMkRBQU0sRUFBRSwwREFBSyxFQUFFLDREQUFPLEVBQUUsMERBQUssRUFBRSx5REFBSSxFQUFFLDZEQUFRLEVBQUUsMkRBQU0sRUFBRSw2REFBTyxFQUFFLDBEQUFJLEVBQUUsOERBQVEsRUFBRSw0REFBTSxFQUFFLDBEQUFJLEVBQUUsK0RBQVMsRUFBRSwyREFBSyxFQUFFLDREQUFNLEVBQUUsNERBQU0sRUFBRSwyREFBSyxFQUFFLDREQUFNLEVBQUUsK0RBQVM7QUFDckwsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLCtDQUFTO0FBQ2xCLENBQUMsRUFBRTtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2lucy9lcy9pbmRleC5qcz9jZmI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1lcmdlRGVlcCB9IGZyb20gXCJ0aW1tXCI7XG5pbXBvcnQgYmxpdCBmcm9tIFwiQGppbXAvcGx1Z2luLWJsaXRcIjtcbmltcG9ydCBibHVyIGZyb20gXCJAamltcC9wbHVnaW4tYmx1clwiO1xuaW1wb3J0IGNpcmNsZSBmcm9tIFwiQGppbXAvcGx1Z2luLWNpcmNsZVwiO1xuaW1wb3J0IGNvbG9yIGZyb20gXCJAamltcC9wbHVnaW4tY29sb3JcIjtcbmltcG9ydCBjb250YWluIGZyb20gXCJAamltcC9wbHVnaW4tY29udGFpblwiO1xuaW1wb3J0IGNvdmVyIGZyb20gXCJAamltcC9wbHVnaW4tY292ZXJcIjtcbmltcG9ydCBjcm9wIGZyb20gXCJAamltcC9wbHVnaW4tY3JvcFwiO1xuaW1wb3J0IGRpc3BsYWNlIGZyb20gXCJAamltcC9wbHVnaW4tZGlzcGxhY2VcIjtcbmltcG9ydCBkaXRoZXIgZnJvbSBcIkBqaW1wL3BsdWdpbi1kaXRoZXJcIjtcbmltcG9ydCBmaXNoZXllIGZyb20gXCJAamltcC9wbHVnaW4tZmlzaGV5ZVwiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIkBqaW1wL3BsdWdpbi1mbGlwXCI7XG5pbXBvcnQgZ2F1c3NpYW4gZnJvbSBcIkBqaW1wL3BsdWdpbi1nYXVzc2lhblwiO1xuaW1wb3J0IGludmVydCBmcm9tIFwiQGppbXAvcGx1Z2luLWludmVydFwiO1xuaW1wb3J0IG1hc2sgZnJvbSBcIkBqaW1wL3BsdWdpbi1tYXNrXCI7XG5pbXBvcnQgbm9ybWFsaXplIGZyb20gXCJAamltcC9wbHVnaW4tbm9ybWFsaXplXCI7XG5pbXBvcnQgcHJpbnQgZnJvbSBcIkBqaW1wL3BsdWdpbi1wcmludFwiO1xuaW1wb3J0IHJlc2l6ZSBmcm9tIFwiQGppbXAvcGx1Z2luLXJlc2l6ZVwiO1xuaW1wb3J0IHJvdGF0ZSBmcm9tIFwiQGppbXAvcGx1Z2luLXJvdGF0ZVwiO1xuaW1wb3J0IHNjYWxlIGZyb20gXCJAamltcC9wbHVnaW4tc2NhbGVcIjtcbmltcG9ydCBzaGFkb3cgZnJvbSBcIkBqaW1wL3BsdWdpbi1zaGFkb3dcIjtcbmltcG9ydCB0aHJlc2hvbGQgZnJvbSBcIkBqaW1wL3BsdWdpbi10aHJlc2hvbGRcIjtcbmNvbnN0IHBsdWdpbnMgPSBbYmxpdCwgYmx1ciwgY2lyY2xlLCBjb2xvciwgY29udGFpbiwgY292ZXIsIGNyb3AsIGRpc3BsYWNlLCBkaXRoZXIsIGZpc2hleWUsIGZsaXAsIGdhdXNzaWFuLCBpbnZlcnQsIG1hc2ssIG5vcm1hbGl6ZSwgcHJpbnQsIHJlc2l6ZSwgcm90YXRlLCBzY2FsZSwgc2hhZG93LCB0aHJlc2hvbGRdO1xuZXhwb3J0IGRlZmF1bHQgKGppbXBFdkNoYW5nZSA9PiB7XG4gIGNvbnN0IGluaXRpYWxpemVkUGx1Z2lucyA9IHBsdWdpbnMubWFwKHBsdWdpbk1vZHVsZSA9PiB7XG4gICAgbGV0IHBsdWdpbiA9IHBsdWdpbk1vZHVsZShqaW1wRXZDaGFuZ2UpIHx8IHt9O1xuICAgIGlmICghcGx1Z2luLmNsYXNzICYmICFwbHVnaW4uY29uc3RhbnRzKSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIGNsYXNzIGZ1bmN0aW9uXG4gICAgICBwbHVnaW4gPSB7XG4gICAgICAgIGNsYXNzOiBwbHVnaW5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW47XG4gIH0pO1xuICByZXR1cm4gbWVyZ2VEZWVwKC4uLmluaXRpYWxpemVkUGx1Z2lucyk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/plugins/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/png/es/index.js":
/*!********************************************!*\
  !*** ./node_modules/@jimp/png/es/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var pngjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pngjs */ \"(action-browser)/./node_modules/pngjs/lib/png.js\");\n/* harmony import */ var _jimp_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/utils */ \"(action-browser)/./node_modules/@jimp/utils/es/index.js\");\n\n\nconst MIME_TYPE = \"image/png\";\n\n// PNG filter types\nconst PNG_FILTER_AUTO = -1;\nconst PNG_FILTER_NONE = 0;\nconst PNG_FILTER_SUB = 1;\nconst PNG_FILTER_UP = 2;\nconst PNG_FILTER_AVERAGE = 3;\nconst PNG_FILTER_PATH = 4;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  mime: {\n    [MIME_TYPE]: [\"png\"]\n  },\n  constants: {\n    MIME_PNG: MIME_TYPE,\n    PNG_FILTER_AUTO,\n    PNG_FILTER_NONE,\n    PNG_FILTER_SUB,\n    PNG_FILTER_UP,\n    PNG_FILTER_AVERAGE,\n    PNG_FILTER_PATH\n  },\n  hasAlpha: {\n    [MIME_TYPE]: true\n  },\n  decoders: {\n    [MIME_TYPE]: pngjs__WEBPACK_IMPORTED_MODULE_0__.PNG.sync.read\n  },\n  encoders: {\n    [MIME_TYPE](data) {\n      const png = new pngjs__WEBPACK_IMPORTED_MODULE_0__.PNG({\n        width: data.bitmap.width,\n        height: data.bitmap.height\n      });\n      png.data = data.bitmap.data;\n      return pngjs__WEBPACK_IMPORTED_MODULE_0__.PNG.sync.write(png, {\n        deflateLevel: data._deflateLevel,\n        deflateStrategy: data._deflateStrategy,\n        filterType: data._filterType,\n        colorType: typeof data._colorType === \"number\" ? data._colorType : data._rgba ? 6 : 2,\n        inputHasAlpha: data._rgba\n      });\n    }\n  },\n  class: {\n    _deflateLevel: 9,\n    _deflateStrategy: 3,\n    _filterType: PNG_FILTER_AUTO,\n    _colorType: null,\n    /**\n     * Sets the deflate level used when saving as PNG format (default is 9)\n     * @param {number} l Deflate level to use 0-9. 0 is no compression. 9 (default) is maximum compression.\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    deflateLevel(l, cb) {\n      if (typeof l !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"l must be a number\", cb);\n      }\n      if (l < 0 || l > 9) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"l must be a number 0 - 9\", cb);\n      }\n      this._deflateLevel = Math.round(l);\n      if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Sets the deflate strategy used when saving as PNG format (default is 3)\n     * @param {number} s Deflate strategy to use 0-3.\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    deflateStrategy(s, cb) {\n      if (typeof s !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"s must be a number\", cb);\n      }\n      if (s < 0 || s > 3) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"s must be a number 0 - 3\", cb);\n      }\n      this._deflateStrategy = Math.round(s);\n      if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Sets the filter type used when saving as PNG format (default is automatic filters)\n     * @param {number} f The quality to use -1-4.\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    filterType(f, cb) {\n      if (typeof f !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"n must be a number\", cb);\n      }\n      if (f < -1 || f > 4) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"n must be -1 (auto) or a number 0 - 4\", cb);\n      }\n      this._filterType = Math.round(f);\n      if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    },\n    /**\n     * Sets the color type used when saving as PNG format\n     * @param {number} s color type to use 0, 2, 4, 6.\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    colorType(s, cb) {\n      if (typeof s !== \"number\") {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"s must be a number\", cb);\n      }\n      if (s !== 0 && s !== 2 && s !== 4 && s !== 6) {\n        return _jimp_utils__WEBPACK_IMPORTED_MODULE_1__.throwError.call(this, \"s must be a number 0, 2, 4, 6.\", cb);\n      }\n      this._colorType = Math.round(s);\n      if ((0,_jimp_utils__WEBPACK_IMPORTED_MODULE_1__.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    }\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC9wbmcvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRCO0FBQzRCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHNDQUFHO0FBQ3BCLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCLHNDQUFHO0FBQ3pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxhQUFhLHNDQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0EsVUFBVSwwREFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQSxVQUFVLDBEQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBLFVBQVUsMERBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0EsVUFBVSwwREFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLEVBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3BuZy9lcy9pbmRleC5qcz9mMGRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBORyB9IGZyb20gXCJwbmdqc1wiO1xuaW1wb3J0IHsgdGhyb3dFcnJvciwgaXNOb2RlUGF0dGVybiB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuY29uc3QgTUlNRV9UWVBFID0gXCJpbWFnZS9wbmdcIjtcblxuLy8gUE5HIGZpbHRlciB0eXBlc1xuY29uc3QgUE5HX0ZJTFRFUl9BVVRPID0gLTE7XG5jb25zdCBQTkdfRklMVEVSX05PTkUgPSAwO1xuY29uc3QgUE5HX0ZJTFRFUl9TVUIgPSAxO1xuY29uc3QgUE5HX0ZJTFRFUl9VUCA9IDI7XG5jb25zdCBQTkdfRklMVEVSX0FWRVJBR0UgPSAzO1xuY29uc3QgUE5HX0ZJTFRFUl9QQVRIID0gNDtcbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiAoe1xuICBtaW1lOiB7XG4gICAgW01JTUVfVFlQRV06IFtcInBuZ1wiXVxuICB9LFxuICBjb25zdGFudHM6IHtcbiAgICBNSU1FX1BORzogTUlNRV9UWVBFLFxuICAgIFBOR19GSUxURVJfQVVUTyxcbiAgICBQTkdfRklMVEVSX05PTkUsXG4gICAgUE5HX0ZJTFRFUl9TVUIsXG4gICAgUE5HX0ZJTFRFUl9VUCxcbiAgICBQTkdfRklMVEVSX0FWRVJBR0UsXG4gICAgUE5HX0ZJTFRFUl9QQVRIXG4gIH0sXG4gIGhhc0FscGhhOiB7XG4gICAgW01JTUVfVFlQRV06IHRydWVcbiAgfSxcbiAgZGVjb2RlcnM6IHtcbiAgICBbTUlNRV9UWVBFXTogUE5HLnN5bmMucmVhZFxuICB9LFxuICBlbmNvZGVyczoge1xuICAgIFtNSU1FX1RZUEVdKGRhdGEpIHtcbiAgICAgIGNvbnN0IHBuZyA9IG5ldyBQTkcoe1xuICAgICAgICB3aWR0aDogZGF0YS5iaXRtYXAud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YS5iaXRtYXAuaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHBuZy5kYXRhID0gZGF0YS5iaXRtYXAuZGF0YTtcbiAgICAgIHJldHVybiBQTkcuc3luYy53cml0ZShwbmcsIHtcbiAgICAgICAgZGVmbGF0ZUxldmVsOiBkYXRhLl9kZWZsYXRlTGV2ZWwsXG4gICAgICAgIGRlZmxhdGVTdHJhdGVneTogZGF0YS5fZGVmbGF0ZVN0cmF0ZWd5LFxuICAgICAgICBmaWx0ZXJUeXBlOiBkYXRhLl9maWx0ZXJUeXBlLFxuICAgICAgICBjb2xvclR5cGU6IHR5cGVvZiBkYXRhLl9jb2xvclR5cGUgPT09IFwibnVtYmVyXCIgPyBkYXRhLl9jb2xvclR5cGUgOiBkYXRhLl9yZ2JhID8gNiA6IDIsXG4gICAgICAgIGlucHV0SGFzQWxwaGE6IGRhdGEuX3JnYmFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY2xhc3M6IHtcbiAgICBfZGVmbGF0ZUxldmVsOiA5LFxuICAgIF9kZWZsYXRlU3RyYXRlZ3k6IDMsXG4gICAgX2ZpbHRlclR5cGU6IFBOR19GSUxURVJfQVVUTyxcbiAgICBfY29sb3JUeXBlOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlZmxhdGUgbGV2ZWwgdXNlZCB3aGVuIHNhdmluZyBhcyBQTkcgZm9ybWF0IChkZWZhdWx0IGlzIDkpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGwgRGVmbGF0ZSBsZXZlbCB0byB1c2UgMC05LiAwIGlzIG5vIGNvbXByZXNzaW9uLiA5IChkZWZhdWx0KSBpcyBtYXhpbXVtIGNvbXByZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIGRlZmxhdGVMZXZlbChsLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBsICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJsIG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKGwgPCAwIHx8IGwgPiA5KSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJsIG11c3QgYmUgYSBudW1iZXIgMCAtIDlcIiwgY2IpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGVmbGF0ZUxldmVsID0gTWF0aC5yb3VuZChsKTtcbiAgICAgIGlmIChpc05vZGVQYXR0ZXJuKGNiKSkge1xuICAgICAgICBjYi5jYWxsKHRoaXMsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZsYXRlIHN0cmF0ZWd5IHVzZWQgd2hlbiBzYXZpbmcgYXMgUE5HIGZvcm1hdCAoZGVmYXVsdCBpcyAzKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzIERlZmxhdGUgc3RyYXRlZ3kgdG8gdXNlIDAtMy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBKaW1wKX0gY2IgKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZvciB3aGVuIGNvbXBsZXRlXG4gICAgICogQHJldHVybnMge0ppbXB9IHRoaXMgZm9yIGNoYWluaW5nIG9mIG1ldGhvZHNcbiAgICAgKi9cbiAgICBkZWZsYXRlU3RyYXRlZ3kocywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgcyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwicyBtdXN0IGJlIGEgbnVtYmVyXCIsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzIDwgMCB8fCBzID4gMykge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwicyBtdXN0IGJlIGEgbnVtYmVyIDAgLSAzXCIsIGNiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RlZmxhdGVTdHJhdGVneSA9IE1hdGgucm91bmQocyk7XG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZmlsdGVyIHR5cGUgdXNlZCB3aGVuIHNhdmluZyBhcyBQTkcgZm9ybWF0IChkZWZhdWx0IGlzIGF1dG9tYXRpYyBmaWx0ZXJzKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmIFRoZSBxdWFsaXR5IHRvIHVzZSAtMS00LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIGZpbHRlclR5cGUoZiwgY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgZiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvci5jYWxsKHRoaXMsIFwibiBtdXN0IGJlIGEgbnVtYmVyXCIsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChmIDwgLTEgfHwgZiA+IDQpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcIm4gbXVzdCBiZSAtMSAoYXV0bykgb3IgYSBudW1iZXIgMCAtIDRcIiwgY2IpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZmlsdGVyVHlwZSA9IE1hdGgucm91bmQoZik7XG4gICAgICBpZiAoaXNOb2RlUGF0dGVybihjYikpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzLCBudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sb3IgdHlwZSB1c2VkIHdoZW4gc2F2aW5nIGFzIFBORyBmb3JtYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcyBjb2xvciB0eXBlIHRvIHVzZSAwLCAyLCA0LCA2LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEppbXApfSBjYiAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZm9yIHdoZW4gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7SmltcH0gdGhpcyBmb3IgY2hhaW5pbmcgb2YgbWV0aG9kc1xuICAgICAqL1xuICAgIGNvbG9yVHlwZShzLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBzICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yLmNhbGwodGhpcywgXCJzIG11c3QgYmUgYSBudW1iZXJcIiwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKHMgIT09IDAgJiYgcyAhPT0gMiAmJiBzICE9PSA0ICYmIHMgIT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IuY2FsbCh0aGlzLCBcInMgbXVzdCBiZSBhIG51bWJlciAwLCAyLCA0LCA2LlwiLCBjYik7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb2xvclR5cGUgPSBNYXRoLnJvdW5kKHMpO1xuICAgICAgaWYgKGlzTm9kZVBhdHRlcm4oY2IpKSB7XG4gICAgICAgIGNiLmNhbGwodGhpcywgbnVsbCwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/png/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/tiff/es/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@jimp/tiff/es/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var utif2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utif2 */ \"(action-browser)/./node_modules/utif2/UTIF.js\");\n/* harmony import */ var utif2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(utif2__WEBPACK_IMPORTED_MODULE_0__);\n\nconst MIME_TYPE = \"image/tiff\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => ({\n  mime: {\n    [MIME_TYPE]: [\"tiff\", \"tif\"]\n  },\n  constants: {\n    MIME_TIFF: MIME_TYPE\n  },\n  decoders: {\n    [MIME_TYPE]: data => {\n      const ifds = utif2__WEBPACK_IMPORTED_MODULE_0___default().decode(data);\n      const page = ifds[0];\n      ifds.forEach(ifd => {\n        utif2__WEBPACK_IMPORTED_MODULE_0___default().decodeImage(data, ifd);\n      });\n      const rgba = utif2__WEBPACK_IMPORTED_MODULE_0___default().toRGBA8(page);\n      return {\n        data: Buffer.from(rgba),\n        width: page.t256[0],\n        height: page.t257[0]\n      };\n    }\n  },\n  encoders: {\n    [MIME_TYPE]: image => {\n      const tiff = utif2__WEBPACK_IMPORTED_MODULE_0___default().encodeImage(image.bitmap.data, image.bitmap.width, image.bitmap.height);\n      return Buffer.from(tiff);\n    }\n  }\n}));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC90aWZmL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QjtBQUN6QjtBQUNBLGlFQUFnQjtBQUNoQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixtREFBVztBQUM5QjtBQUNBO0FBQ0EsUUFBUSx3REFBZ0I7QUFDeEIsT0FBTztBQUNQLG1CQUFtQixvREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQix3REFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLEVBQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3RpZmYvZXMvaW5kZXguanM/NDliYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXRpZiBmcm9tIFwidXRpZjJcIjtcbmNvbnN0IE1JTUVfVFlQRSA9IFwiaW1hZ2UvdGlmZlwiO1xuZXhwb3J0IGRlZmF1bHQgKCgpID0+ICh7XG4gIG1pbWU6IHtcbiAgICBbTUlNRV9UWVBFXTogW1widGlmZlwiLCBcInRpZlwiXVxuICB9LFxuICBjb25zdGFudHM6IHtcbiAgICBNSU1FX1RJRkY6IE1JTUVfVFlQRVxuICB9LFxuICBkZWNvZGVyczoge1xuICAgIFtNSU1FX1RZUEVdOiBkYXRhID0+IHtcbiAgICAgIGNvbnN0IGlmZHMgPSB1dGlmLmRlY29kZShkYXRhKTtcbiAgICAgIGNvbnN0IHBhZ2UgPSBpZmRzWzBdO1xuICAgICAgaWZkcy5mb3JFYWNoKGlmZCA9PiB7XG4gICAgICAgIHV0aWYuZGVjb2RlSW1hZ2UoZGF0YSwgaWZkKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmdiYSA9IHV0aWYudG9SR0JBOChwYWdlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKHJnYmEpLFxuICAgICAgICB3aWR0aDogcGFnZS50MjU2WzBdLFxuICAgICAgICBoZWlnaHQ6IHBhZ2UudDI1N1swXVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGVuY29kZXJzOiB7XG4gICAgW01JTUVfVFlQRV06IGltYWdlID0+IHtcbiAgICAgIGNvbnN0IHRpZmYgPSB1dGlmLmVuY29kZUltYWdlKGltYWdlLmJpdG1hcC5kYXRhLCBpbWFnZS5iaXRtYXAud2lkdGgsIGltYWdlLmJpdG1hcC5oZWlnaHQpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRpZmYpO1xuICAgIH1cbiAgfVxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/tiff/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/types/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@jimp/types/es/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var timm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timm */ \"(action-browser)/./node_modules/timm/lib/timm.js\");\n/* harmony import */ var _jimp_jpeg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jimp/jpeg */ \"(action-browser)/./node_modules/@jimp/jpeg/es/index.js\");\n/* harmony import */ var _jimp_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jimp/png */ \"(action-browser)/./node_modules/@jimp/png/es/index.js\");\n/* harmony import */ var _jimp_bmp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jimp/bmp */ \"(action-browser)/./node_modules/@jimp/bmp/es/index.js\");\n/* harmony import */ var _jimp_tiff__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jimp/tiff */ \"(action-browser)/./node_modules/@jimp/tiff/es/index.js\");\n/* harmony import */ var _jimp_gif__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jimp/gif */ \"(action-browser)/./node_modules/@jimp/gif/es/index.js\");\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => (0,timm__WEBPACK_IMPORTED_MODULE_0__.mergeDeep)((0,_jimp_jpeg__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(), (0,_jimp_png__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(), (0,_jimp_bmp__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(), (0,_jimp_tiff__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(), (0,_jimp_gif__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC90eXBlcy9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWlDO0FBQ0g7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUM1QixpRUFBZ0IsTUFBTSwrQ0FBUyxDQUFDLHNEQUFJLElBQUkscURBQUcsSUFBSSxxREFBRyxJQUFJLHNEQUFJLElBQUkscURBQUcsR0FBRyxFQUFFO0FBQ3RFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvQGppbXAvdHlwZXMvZXMvaW5kZXguanM/YTE1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tIFwidGltbVwiO1xuaW1wb3J0IGpwZWcgZnJvbSBcIkBqaW1wL2pwZWdcIjtcbmltcG9ydCBwbmcgZnJvbSBcIkBqaW1wL3BuZ1wiO1xuaW1wb3J0IGJtcCBmcm9tIFwiQGppbXAvYm1wXCI7XG5pbXBvcnQgdGlmZiBmcm9tIFwiQGppbXAvdGlmZlwiO1xuaW1wb3J0IGdpZiBmcm9tIFwiQGppbXAvZ2lmXCI7XG5leHBvcnQgZGVmYXVsdCAoKCkgPT4gbWVyZ2VEZWVwKGpwZWcoKSwgcG5nKCksIGJtcCgpLCB0aWZmKCksIGdpZigpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/types/es/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@jimp/utils/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@jimp/utils/es/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isNodePattern: () => (/* binding */ isNodePattern),\n/* harmony export */   scan: () => (/* binding */ scan),\n/* harmony export */   scanIterator: () => (/* binding */ scanIterator),\n/* harmony export */   throwError: () => (/* binding */ throwError)\n/* harmony export */ });\nfunction isNodePattern(cb) {\n  if (typeof cb === \"undefined\") {\n    return false;\n  }\n  if (typeof cb !== \"function\") {\n    throw new TypeError(\"Callback must be a function\");\n  }\n  return true;\n}\nfunction throwError(error, cb) {\n  if (typeof error === \"string\") {\n    error = new Error(error);\n  }\n  if (typeof cb === \"function\") {\n    return cb.call(this, error);\n  }\n  throw error;\n}\nfunction scan(image, x, y, w, h, f) {\n  // round input\n  x = Math.round(x);\n  y = Math.round(y);\n  w = Math.round(w);\n  h = Math.round(h);\n  for (let _y = y; _y < y + h; _y++) {\n    for (let _x = x; _x < x + w; _x++) {\n      const idx = image.bitmap.width * _y + _x << 2;\n      f.call(image, _x, _y, idx);\n    }\n  }\n  return image;\n}\nfunction* scanIterator(image, x, y, w, h) {\n  // round input\n  x = Math.round(x);\n  y = Math.round(y);\n  w = Math.round(w);\n  h = Math.round(h);\n  for (let _y = y; _y < y + h; _y++) {\n    for (let _x = x; _x < x + w; _x++) {\n      const idx = image.bitmap.width * _y + _x << 2;\n      yield {\n        x: _x,\n        y: _y,\n        idx,\n        image\n      };\n    }\n  }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AamltcC91dGlscy9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL0BqaW1wL3V0aWxzL2VzL2luZGV4LmpzP2U2M2MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVBhdHRlcm4oY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRocm93RXJyb3IoZXJyb3IsIGNiKSB7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNiLmNhbGwodGhpcywgZXJyb3IpO1xuICB9XG4gIHRocm93IGVycm9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNjYW4oaW1hZ2UsIHgsIHksIHcsIGgsIGYpIHtcbiAgLy8gcm91bmQgaW5wdXRcbiAgeCA9IE1hdGgucm91bmQoeCk7XG4gIHkgPSBNYXRoLnJvdW5kKHkpO1xuICB3ID0gTWF0aC5yb3VuZCh3KTtcbiAgaCA9IE1hdGgucm91bmQoaCk7XG4gIGZvciAobGV0IF95ID0geTsgX3kgPCB5ICsgaDsgX3krKykge1xuICAgIGZvciAobGV0IF94ID0geDsgX3ggPCB4ICsgdzsgX3grKykge1xuICAgICAgY29uc3QgaWR4ID0gaW1hZ2UuYml0bWFwLndpZHRoICogX3kgKyBfeCA8PCAyO1xuICAgICAgZi5jYWxsKGltYWdlLCBfeCwgX3ksIGlkeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbWFnZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiogc2Nhbkl0ZXJhdG9yKGltYWdlLCB4LCB5LCB3LCBoKSB7XG4gIC8vIHJvdW5kIGlucHV0XG4gIHggPSBNYXRoLnJvdW5kKHgpO1xuICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgdyA9IE1hdGgucm91bmQodyk7XG4gIGggPSBNYXRoLnJvdW5kKGgpO1xuICBmb3IgKGxldCBfeSA9IHk7IF95IDwgeSArIGg7IF95KyspIHtcbiAgICBmb3IgKGxldCBfeCA9IHg7IF94IDwgeCArIHc7IF94KyspIHtcbiAgICAgIGNvbnN0IGlkeCA9IGltYWdlLmJpdG1hcC53aWR0aCAqIF95ICsgX3ggPDwgMjtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgeDogX3gsXG4gICAgICAgIHk6IF95LFxuICAgICAgICBpZHgsXG4gICAgICAgIGltYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@jimp/utils/es/index.js\n");

/***/ })

};
;