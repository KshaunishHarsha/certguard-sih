/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/image-q";
exports.ids = ["vendor-chunks/image-q"];
exports.modules = {

/***/ "(action-browser)/./node_modules/image-q/dist/cjs/image-q.cjs":
/*!***************************************************!*\
  !*** ./node_modules/image-q/dist/cjs/image-q.cjs ***!
  \***************************************************/
/***/ ((module) => {

eval("var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, copyDefault, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== \"default\"))\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toCommonJS = /* @__PURE__ */ ((cache) => {\n  return (module2, temp) => {\n    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);\n  };\n})(typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : 0);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  applyPalette: () => applyPalette,\n  applyPaletteSync: () => applyPaletteSync,\n  buildPalette: () => buildPalette,\n  buildPaletteSync: () => buildPaletteSync,\n  constants: () => constants_exports,\n  conversion: () => conversion_exports,\n  distance: () => distance_exports,\n  image: () => image_exports,\n  palette: () => palette_exports,\n  quality: () => quality_exports,\n  utils: () => utils_exports\n});\n\n// src/constants/index.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  bt709: () => bt709_exports\n});\n\n// src/constants/bt709.ts\nvar bt709_exports = {};\n__export(bt709_exports, {\n  Y: () => Y,\n  x: () => x,\n  y: () => y\n});\nvar Y = /* @__PURE__ */ ((Y2) => {\n  Y2[Y2[\"RED\"] = 0.2126] = \"RED\";\n  Y2[Y2[\"GREEN\"] = 0.7152] = \"GREEN\";\n  Y2[Y2[\"BLUE\"] = 0.0722] = \"BLUE\";\n  Y2[Y2[\"WHITE\"] = 1] = \"WHITE\";\n  return Y2;\n})(Y || {});\nvar x = /* @__PURE__ */ ((x2) => {\n  x2[x2[\"RED\"] = 0.64] = \"RED\";\n  x2[x2[\"GREEN\"] = 0.3] = \"GREEN\";\n  x2[x2[\"BLUE\"] = 0.15] = \"BLUE\";\n  x2[x2[\"WHITE\"] = 0.3127] = \"WHITE\";\n  return x2;\n})(x || {});\nvar y = /* @__PURE__ */ ((y2) => {\n  y2[y2[\"RED\"] = 0.33] = \"RED\";\n  y2[y2[\"GREEN\"] = 0.6] = \"GREEN\";\n  y2[y2[\"BLUE\"] = 0.06] = \"BLUE\";\n  y2[y2[\"WHITE\"] = 0.329] = \"WHITE\";\n  return y2;\n})(y || {});\n\n// src/conversion/index.ts\nvar conversion_exports = {};\n__export(conversion_exports, {\n  lab2rgb: () => lab2rgb,\n  lab2xyz: () => lab2xyz,\n  rgb2hsl: () => rgb2hsl,\n  rgb2lab: () => rgb2lab,\n  rgb2xyz: () => rgb2xyz,\n  xyz2lab: () => xyz2lab,\n  xyz2rgb: () => xyz2rgb\n});\n\n// src/conversion/rgb2xyz.ts\nfunction correctGamma(n) {\n  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;\n}\nfunction rgb2xyz(r, g, b) {\n  r = correctGamma(r / 255);\n  g = correctGamma(g / 255);\n  b = correctGamma(b / 255);\n  return {\n    x: r * 0.4124 + g * 0.3576 + b * 0.1805,\n    y: r * 0.2126 + g * 0.7152 + b * 0.0722,\n    z: r * 0.0193 + g * 0.1192 + b * 0.9505\n  };\n}\n\n// src/utils/arithmetic.ts\nvar arithmetic_exports = {};\n__export(arithmetic_exports, {\n  degrees2radians: () => degrees2radians,\n  inRange0to255: () => inRange0to255,\n  inRange0to255Rounded: () => inRange0to255Rounded,\n  intInRange: () => intInRange,\n  max3: () => max3,\n  min3: () => min3,\n  stableSort: () => stableSort\n});\nfunction degrees2radians(n) {\n  return n * (Math.PI / 180);\n}\nfunction max3(a, b, c) {\n  let m = a;\n  if (m < b)\n    m = b;\n  if (m < c)\n    m = c;\n  return m;\n}\nfunction min3(a, b, c) {\n  let m = a;\n  if (m > b)\n    m = b;\n  if (m > c)\n    m = c;\n  return m;\n}\nfunction intInRange(value, low, high) {\n  if (value > high)\n    value = high;\n  if (value < low)\n    value = low;\n  return value | 0;\n}\nfunction inRange0to255Rounded(n) {\n  n = Math.round(n);\n  if (n > 255)\n    n = 255;\n  else if (n < 0)\n    n = 0;\n  return n;\n}\nfunction inRange0to255(n) {\n  if (n > 255)\n    n = 255;\n  else if (n < 0)\n    n = 0;\n  return n;\n}\nfunction stableSort(arrayToSort, callback) {\n  const type = typeof arrayToSort[0];\n  let sorted;\n  if (type === \"number\" || type === \"string\") {\n    const ord = /* @__PURE__ */ Object.create(null);\n    for (let i = 0, l = arrayToSort.length; i < l; i++) {\n      const val = arrayToSort[i];\n      if (ord[val] || ord[val] === 0)\n        continue;\n      ord[val] = i;\n    }\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);\n  } else {\n    const ord2 = arrayToSort.slice(0);\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));\n  }\n  return sorted;\n}\n\n// src/conversion/rgb2hsl.ts\nfunction rgb2hsl(r, g, b) {\n  const min = min3(r, g, b);\n  const max = max3(r, g, b);\n  const delta = max - min;\n  const l = (min + max) / 510;\n  let s = 0;\n  if (l > 0 && l < 1)\n    s = delta / (l < 0.5 ? max + min : 510 - max - min);\n  let h = 0;\n  if (delta > 0) {\n    if (max === r) {\n      h = (g - b) / delta;\n    } else if (max === g) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n    h *= 60;\n    if (h < 0)\n      h += 360;\n  }\n  return { h, s, l };\n}\n\n// src/conversion/xyz2lab.ts\nvar refX = 0.95047;\nvar refY = 1;\nvar refZ = 1.08883;\nfunction pivot(n) {\n  return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;\n}\nfunction xyz2lab(x2, y2, z) {\n  x2 = pivot(x2 / refX);\n  y2 = pivot(y2 / refY);\n  z = pivot(z / refZ);\n  if (116 * y2 - 16 < 0)\n    throw new Error(\"xxx\");\n  return {\n    L: Math.max(0, 116 * y2 - 16),\n    a: 500 * (x2 - y2),\n    b: 200 * (y2 - z)\n  };\n}\n\n// src/conversion/rgb2lab.ts\nfunction rgb2lab(r, g, b) {\n  const xyz = rgb2xyz(r, g, b);\n  return xyz2lab(xyz.x, xyz.y, xyz.z);\n}\n\n// src/conversion/lab2xyz.ts\nvar refX2 = 0.95047;\nvar refY2 = 1;\nvar refZ2 = 1.08883;\nfunction pivot2(n) {\n  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;\n}\nfunction lab2xyz(L, a, b) {\n  const y2 = (L + 16) / 116;\n  const x2 = a / 500 + y2;\n  const z = y2 - b / 200;\n  return {\n    x: refX2 * pivot2(x2),\n    y: refY2 * pivot2(y2),\n    z: refZ2 * pivot2(z)\n  };\n}\n\n// src/conversion/xyz2rgb.ts\nfunction correctGamma2(n) {\n  return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;\n}\nfunction xyz2rgb(x2, y2, z) {\n  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);\n  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);\n  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);\n  return {\n    r: inRange0to255Rounded(r * 255),\n    g: inRange0to255Rounded(g * 255),\n    b: inRange0to255Rounded(b * 255)\n  };\n}\n\n// src/conversion/lab2rgb.ts\nfunction lab2rgb(L, a, b) {\n  const xyz = lab2xyz(L, a, b);\n  return xyz2rgb(xyz.x, xyz.y, xyz.z);\n}\n\n// src/distance/index.ts\nvar distance_exports = {};\n__export(distance_exports, {\n  AbstractDistanceCalculator: () => AbstractDistanceCalculator,\n  AbstractEuclidean: () => AbstractEuclidean,\n  AbstractManhattan: () => AbstractManhattan,\n  CIE94GraphicArts: () => CIE94GraphicArts,\n  CIE94Textiles: () => CIE94Textiles,\n  CIEDE2000: () => CIEDE2000,\n  CMetric: () => CMetric,\n  Euclidean: () => Euclidean,\n  EuclideanBT709: () => EuclideanBT709,\n  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,\n  Manhattan: () => Manhattan,\n  ManhattanBT709: () => ManhattanBT709,\n  ManhattanNommyde: () => ManhattanNommyde,\n  PNGQuant: () => PNGQuant\n});\n\n// src/distance/distanceCalculator.ts\nvar AbstractDistanceCalculator = class {\n  constructor() {\n    __publicField(this, \"_maxDistance\");\n    __publicField(this, \"_whitePoint\");\n    this._setDefaults();\n    this.setWhitePoint(255, 255, 255, 255);\n  }\n  setWhitePoint(r, g, b, a) {\n    this._whitePoint = {\n      r: r > 0 ? 255 / r : 0,\n      g: g > 0 ? 255 / g : 0,\n      b: b > 0 ? 255 / b : 0,\n      a: a > 0 ? 255 / a : 0\n    };\n    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\n  }\n  calculateNormalized(colorA, colorB) {\n    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;\n  }\n};\n\n// src/distance/cie94.ts\nvar AbstractCIE94 = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));\n    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));\n    const dL = lab1.L - lab2.L;\n    const dA = lab1.a - lab2.a;\n    const dB = lab1.b - lab2.b;\n    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);\n    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);\n    const dC = c1 - c2;\n    let deltaH = dA * dA + dB * dB - dC * dC;\n    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\n    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);\n  }\n};\nvar CIE94Textiles = class extends AbstractCIE94 {\n  _setDefaults() {\n    this._Kl = 2;\n    this._K1 = 0.048;\n    this._K2 = 0.014;\n    this._kA = 0.25 * 50 / 255;\n  }\n};\nvar CIE94GraphicArts = class extends AbstractCIE94 {\n  _setDefaults() {\n    this._Kl = 1;\n    this._K1 = 0.045;\n    this._K2 = 0.015;\n    this._kA = 0.25 * 100 / 255;\n  }\n};\n\n// src/distance/ciede2000.ts\nvar _CIEDE2000 = class extends AbstractDistanceCalculator {\n  _setDefaults() {\n  }\n  static _calculatehp(b, ap) {\n    const hp = Math.atan2(b, ap);\n    if (hp >= 0)\n      return hp;\n    return hp + _CIEDE2000._deg360InRad;\n  }\n  static _calculateRT(ahp, aCp) {\n    const aCp_to_7 = aCp ** 7;\n    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));\n    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));\n    return -Math.sin(2 * delta_theta) * R_C;\n  }\n  static _calculateT(ahp) {\n    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);\n  }\n  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {\n    const hpSum = h1p + h2p;\n    if (C1pC2p === 0)\n      return hpSum;\n    if (h_bar <= _CIEDE2000._deg180InRad)\n      return hpSum / 2;\n    if (hpSum < _CIEDE2000._deg360InRad) {\n      return (hpSum + _CIEDE2000._deg360InRad) / 2;\n    }\n    return (hpSum - _CIEDE2000._deg360InRad) / 2;\n  }\n  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {\n    let dhp;\n    if (C1pC2p === 0) {\n      dhp = 0;\n    } else if (h_bar <= _CIEDE2000._deg180InRad) {\n      dhp = h2p - h1p;\n    } else if (h2p <= h1p) {\n      dhp = h2p - h1p + _CIEDE2000._deg360InRad;\n    } else {\n      dhp = h2p - h1p - _CIEDE2000._deg360InRad;\n    }\n    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);\n  }\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));\n    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));\n    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;\n    const dE2 = this.calculateRawInLab(lab1, lab2);\n    return Math.sqrt(dE2 + dA * dA);\n  }\n  calculateRawInLab(Lab1, Lab2) {\n    const L1 = Lab1.L;\n    const a1 = Lab1.a;\n    const b1 = Lab1.b;\n    const L2 = Lab2.L;\n    const a2 = Lab2.a;\n    const b2 = Lab2.b;\n    const C1 = Math.sqrt(a1 * a1 + b1 * b1);\n    const C2 = Math.sqrt(a2 * a2 + b2 * b2);\n    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;\n    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));\n    const a1p = (1 + G) * a1;\n    const a2p = (1 + G) * a2;\n    const C1p = Math.sqrt(a1p * a1p + b1 * b1);\n    const C2p = Math.sqrt(a2p * a2p + b2 * b2);\n    const C1pC2p = C1p * C2p;\n    const h1p = _CIEDE2000._calculatehp(b1, a1p);\n    const h2p = _CIEDE2000._calculatehp(b2, a2p);\n    const h_bar = Math.abs(h1p - h2p);\n    const dLp = L2 - L1;\n    const dCp = C2p - C1p;\n    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);\n    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);\n    const T = _CIEDE2000._calculateT(ahp);\n    const aCp = (C1p + C2p) / 2;\n    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;\n    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);\n    const S_C = 1 + 0.045 * aCp;\n    const S_H = 1 + 0.015 * T * aCp;\n    const R_T = _CIEDE2000._calculateRT(ahp, aCp);\n    const dLpSL = dLp / S_L;\n    const dCpSC = dCp / S_C;\n    const dHpSH = dHp / S_H;\n    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;\n  }\n};\nvar CIEDE2000 = _CIEDE2000;\n__publicField(CIEDE2000, \"_kA\", 0.25 * 100 / 255);\n__publicField(CIEDE2000, \"_pow25to7\", 25 ** 7);\n__publicField(CIEDE2000, \"_deg360InRad\", degrees2radians(360));\n__publicField(CIEDE2000, \"_deg180InRad\", degrees2radians(180));\n__publicField(CIEDE2000, \"_deg30InRad\", degrees2radians(30));\n__publicField(CIEDE2000, \"_deg6InRad\", degrees2radians(6));\n__publicField(CIEDE2000, \"_deg63InRad\", degrees2radians(63));\n__publicField(CIEDE2000, \"_deg275InRad\", degrees2radians(275));\n__publicField(CIEDE2000, \"_deg25InRad\", degrees2radians(25));\n\n// src/distance/cmetric.ts\nvar CMetric = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const rmean = (r1 + r2) / 2 * this._whitePoint.r;\n    const r = (r1 - r2) * this._whitePoint.r;\n    const g = (g1 - g2) * this._whitePoint.g;\n    const b = (b1 - b2) * this._whitePoint.b;\n    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);\n    const dA = (a2 - a1) * this._whitePoint.a;\n    return Math.sqrt(dE + dA * dA);\n  }\n  _setDefaults() {\n  }\n};\n\n// src/distance/euclidean.ts\nvar AbstractEuclidean = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const dR = r2 - r1;\n    const dG = g2 - g1;\n    const dB = b2 - b1;\n    const dA = a2 - a1;\n    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);\n  }\n};\nvar Euclidean = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n};\nvar EuclideanBT709 = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 0.2126 /* RED */;\n    this._kG = 0.7152 /* GREEN */;\n    this._kB = 0.0722 /* BLUE */;\n    this._kA = 1;\n  }\n};\nvar EuclideanBT709NoAlpha = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 0.2126 /* RED */;\n    this._kG = 0.7152 /* GREEN */;\n    this._kB = 0.0722 /* BLUE */;\n    this._kA = 0;\n  }\n};\n\n// src/distance/manhattan.ts\nvar AbstractManhattan = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    let dR = r2 - r1;\n    let dG = g2 - g1;\n    let dB = b2 - b1;\n    let dA = a2 - a1;\n    if (dR < 0)\n      dR = 0 - dR;\n    if (dG < 0)\n      dG = 0 - dG;\n    if (dB < 0)\n      dB = 0 - dB;\n    if (dA < 0)\n      dA = 0 - dA;\n    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\n  }\n};\nvar Manhattan = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n};\nvar ManhattanNommyde = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 0.4984;\n    this._kG = 0.8625;\n    this._kB = 0.2979;\n    this._kA = 1;\n  }\n};\nvar ManhattanBT709 = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 0.2126 /* RED */;\n    this._kG = 0.7152 /* GREEN */;\n    this._kB = 0.0722 /* BLUE */;\n    this._kA = 1;\n  }\n};\n\n// src/distance/pngQuant.ts\nvar PNGQuant = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const alphas = (a2 - a1) * this._whitePoint.a;\n    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);\n  }\n  _colordifferenceCh(x2, y2, alphas) {\n    const black = x2 - y2;\n    const white = black + alphas;\n    return black * black + white * white;\n  }\n  _setDefaults() {\n  }\n};\n\n// src/palette/index.ts\nvar palette_exports = {};\n__export(palette_exports, {\n  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,\n  ColorHistogram: () => ColorHistogram,\n  NeuQuant: () => NeuQuant,\n  NeuQuantFloat: () => NeuQuantFloat,\n  RGBQuant: () => RGBQuant,\n  WuColorCube: () => WuColorCube,\n  WuQuant: () => WuQuant\n});\n\n// src/palette/paletteQuantizer.ts\nvar AbstractPaletteQuantizer = class {\n  quantizeSync() {\n    for (const value of this.quantize()) {\n      if (value.palette) {\n        return value.palette;\n      }\n    }\n    throw new Error(\"unreachable\");\n  }\n};\n\n// src/utils/point.ts\nvar Point = class {\n  constructor() {\n    __publicField(this, \"r\");\n    __publicField(this, \"g\");\n    __publicField(this, \"b\");\n    __publicField(this, \"a\");\n    __publicField(this, \"uint32\");\n    __publicField(this, \"rgba\");\n    this.uint32 = -1 >>> 0;\n    this.r = this.g = this.b = this.a = 0;\n    this.rgba = new Array(4);\n    this.rgba[0] = 0;\n    this.rgba[1] = 0;\n    this.rgba[2] = 0;\n    this.rgba[3] = 0;\n  }\n  static createByQuadruplet(quadruplet) {\n    const point = new Point();\n    point.r = quadruplet[0] | 0;\n    point.g = quadruplet[1] | 0;\n    point.b = quadruplet[2] | 0;\n    point.a = quadruplet[3] | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    return point;\n  }\n  static createByRGBA(red, green, blue, alpha) {\n    const point = new Point();\n    point.r = red | 0;\n    point.g = green | 0;\n    point.b = blue | 0;\n    point.a = alpha | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    return point;\n  }\n  static createByUint32(uint32) {\n    const point = new Point();\n    point.uint32 = uint32 >>> 0;\n    point._loadRGBA();\n    point._loadQuadruplet();\n    return point;\n  }\n  from(point) {\n    this.r = point.r;\n    this.g = point.g;\n    this.b = point.b;\n    this.a = point.a;\n    this.uint32 = point.uint32;\n    this.rgba[0] = point.r;\n    this.rgba[1] = point.g;\n    this.rgba[2] = point.b;\n    this.rgba[3] = point.a;\n  }\n  getLuminosity(useAlphaChannel) {\n    let r = this.r;\n    let g = this.g;\n    let b = this.b;\n    if (useAlphaChannel) {\n      r = Math.min(255, 255 - this.a + this.a * r / 255);\n      g = Math.min(255, 255 - this.a + this.a * g / 255);\n      b = Math.min(255, 255 - this.a + this.a * b / 255);\n    }\n    return r * 0.2126 /* RED */ + g * 0.7152 /* GREEN */ + b * 0.0722 /* BLUE */;\n  }\n  _loadUINT32() {\n    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;\n  }\n  _loadRGBA() {\n    this.r = this.uint32 & 255;\n    this.g = this.uint32 >>> 8 & 255;\n    this.b = this.uint32 >>> 16 & 255;\n    this.a = this.uint32 >>> 24 & 255;\n  }\n  _loadQuadruplet() {\n    this.rgba[0] = this.r;\n    this.rgba[1] = this.g;\n    this.rgba[2] = this.b;\n    this.rgba[3] = this.a;\n  }\n};\n\n// src/utils/pointContainer.ts\nvar PointContainer = class {\n  constructor() {\n    __publicField(this, \"_pointArray\");\n    __publicField(this, \"_width\");\n    __publicField(this, \"_height\");\n    this._width = 0;\n    this._height = 0;\n    this._pointArray = [];\n  }\n  getWidth() {\n    return this._width;\n  }\n  getHeight() {\n    return this._height;\n  }\n  setWidth(width) {\n    this._width = width;\n  }\n  setHeight(height) {\n    this._height = height;\n  }\n  getPointArray() {\n    return this._pointArray;\n  }\n  clone() {\n    const clone = new PointContainer();\n    clone._width = this._width;\n    clone._height = this._height;\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      clone._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);\n    }\n    return clone;\n  }\n  toUint32Array() {\n    const l = this._pointArray.length;\n    const uint32Array = new Uint32Array(l);\n    for (let i = 0; i < l; i++) {\n      uint32Array[i] = this._pointArray[i].uint32;\n    }\n    return uint32Array;\n  }\n  toUint8Array() {\n    return new Uint8Array(this.toUint32Array().buffer);\n  }\n  static fromHTMLImageElement(img) {\n    const width = img.naturalWidth;\n    const height = img.naturalHeight;\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\n    return PointContainer.fromHTMLCanvasElement(canvas);\n  }\n  static fromHTMLCanvasElement(canvas) {\n    const width = canvas.width;\n    const height = canvas.height;\n    const ctx = canvas.getContext(\"2d\");\n    const imgData = ctx.getImageData(0, 0, width, height);\n    return PointContainer.fromImageData(imgData);\n  }\n  static fromImageData(imageData) {\n    const width = imageData.width;\n    const height = imageData.height;\n    return PointContainer.fromUint8Array(imageData.data, width, height);\n  }\n  static fromUint8Array(uint8Array, width, height) {\n    switch (Object.prototype.toString.call(uint8Array)) {\n      case \"[object Uint8ClampedArray]\":\n      case \"[object Uint8Array]\":\n        break;\n      default:\n        uint8Array = new Uint8Array(uint8Array);\n    }\n    const uint32Array = new Uint32Array(uint8Array.buffer);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n  static fromUint32Array(uint32Array, width, height) {\n    const container = new PointContainer();\n    container._width = width;\n    container._height = height;\n    for (let i = 0, l = uint32Array.length; i < l; i++) {\n      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0);\n    }\n    return container;\n  }\n  static fromBuffer(buffer, width, height) {\n    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n};\n\n// src/utils/palette.ts\nvar hueGroups = 10;\nfunction hueGroup(hue, segmentsNumber) {\n  const maxHue = 360;\n  const seg = maxHue / segmentsNumber;\n  const half = seg / 2;\n  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\n    if (hue >= mid && hue < mid + seg)\n      return i;\n  }\n  return 0;\n}\nvar Palette = class {\n  constructor() {\n    __publicField(this, \"_pointContainer\");\n    __publicField(this, \"_pointArray\", []);\n    __publicField(this, \"_i32idx\", {});\n    this._pointContainer = new PointContainer();\n    this._pointContainer.setHeight(1);\n    this._pointArray = this._pointContainer.getPointArray();\n  }\n  add(color) {\n    this._pointArray.push(color);\n    this._pointContainer.setWidth(this._pointArray.length);\n  }\n  has(color) {\n    for (let i = this._pointArray.length - 1; i >= 0; i--) {\n      if (color.uint32 === this._pointArray[i].uint32)\n        return true;\n    }\n    return false;\n  }\n  getNearestColor(colorDistanceCalculator, color) {\n    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];\n  }\n  getPointContainer() {\n    return this._pointContainer;\n  }\n  _nearestPointFromCache(key) {\n    return typeof this._i32idx[key] === \"number\" ? this._i32idx[key] : -1;\n  }\n  _getNearestIndex(colorDistanceCalculator, point) {\n    let idx = this._nearestPointFromCache(\"\" + point.uint32);\n    if (idx >= 0)\n      return idx;\n    let minimalDistance = Number.MAX_VALUE;\n    idx = 0;\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      const p = this._pointArray[i];\n      const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);\n      if (distance < minimalDistance) {\n        minimalDistance = distance;\n        idx = i;\n      }\n    }\n    this._i32idx[point.uint32] = idx;\n    return idx;\n  }\n  sort() {\n    this._i32idx = {};\n    this._pointArray.sort((a, b) => {\n      const hslA = rgb2hsl(a.r, a.g, a.b);\n      const hslB = rgb2hsl(b.r, b.g, b.b);\n      const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);\n      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);\n      const hueDiff = hueB - hueA;\n      if (hueDiff)\n        return -hueDiff;\n      const lA = a.getLuminosity(true);\n      const lB = b.getLuminosity(true);\n      if (lB - lA !== 0)\n        return lB - lA;\n      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);\n      if (satDiff)\n        return -satDiff;\n      return 0;\n    });\n  }\n};\n\n// src/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  HueStatistics: () => HueStatistics,\n  Palette: () => Palette,\n  Point: () => Point,\n  PointContainer: () => PointContainer,\n  ProgressTracker: () => ProgressTracker,\n  arithmetic: () => arithmetic_exports\n});\n\n// src/utils/hueStatistics.ts\nvar HueGroup = class {\n  constructor() {\n    __publicField(this, \"num\", 0);\n    __publicField(this, \"cols\", []);\n  }\n};\nvar HueStatistics = class {\n  constructor(numGroups, minCols) {\n    __publicField(this, \"_numGroups\");\n    __publicField(this, \"_minCols\");\n    __publicField(this, \"_stats\");\n    __publicField(this, \"_groupsFull\");\n    this._numGroups = numGroups;\n    this._minCols = minCols;\n    this._stats = [];\n    for (let i = 0; i <= numGroups; i++) {\n      this._stats[i] = new HueGroup();\n    }\n    this._groupsFull = 0;\n  }\n  check(i32) {\n    if (this._groupsFull === this._numGroups + 1) {\n      this.check = () => {\n      };\n    }\n    const r = i32 & 255;\n    const g = i32 >>> 8 & 255;\n    const b = i32 >>> 16 & 255;\n    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);\n    const gr = this._stats[hg];\n    const min = this._minCols;\n    gr.num++;\n    if (gr.num > min) {\n      return;\n    }\n    if (gr.num === min) {\n      this._groupsFull++;\n    }\n    if (gr.num <= min) {\n      this._stats[hg].cols.push(i32);\n    }\n  }\n  injectIntoDictionary(histG) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col) => {\n          if (!histG[col]) {\n            histG[col] = 1;\n          } else {\n            histG[col]++;\n          }\n        });\n      }\n    }\n  }\n  injectIntoArray(histG) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col) => {\n          if (histG.indexOf(col) === -1) {\n            histG.push(col);\n          }\n        });\n      }\n    }\n  }\n};\n\n// src/utils/progressTracker.ts\nvar _ProgressTracker = class {\n  constructor(valueRange, progressRange) {\n    __publicField(this, \"progress\");\n    __publicField(this, \"_step\");\n    __publicField(this, \"_range\");\n    __publicField(this, \"_last\");\n    __publicField(this, \"_progressRange\");\n    this._range = valueRange;\n    this._progressRange = progressRange;\n    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);\n    this._last = -this._step;\n    this.progress = 0;\n  }\n  shouldNotify(current) {\n    if (current - this._last >= this._step) {\n      this._last = current;\n      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);\n      return true;\n    }\n    return false;\n  }\n};\nvar ProgressTracker = _ProgressTracker;\n__publicField(ProgressTracker, \"steps\", 100);\n\n// src/palette/neuquant/neuquant.ts\nvar networkBiasShift = 3;\nvar Neuron = class {\n  constructor(defaultValue) {\n    __publicField(this, \"r\");\n    __publicField(this, \"g\");\n    __publicField(this, \"b\");\n    __publicField(this, \"a\");\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n  toPoint() {\n    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\n  }\n  subtract(r, g, b, a) {\n    this.r -= r | 0;\n    this.g -= g | 0;\n    this.b -= b | 0;\n    this.a -= a | 0;\n  }\n};\nvar _NeuQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator, colors = 256) {\n    super();\n    __publicField(this, \"_pointArray\");\n    __publicField(this, \"_networkSize\");\n    __publicField(this, \"_network\");\n    __publicField(this, \"_sampleFactor\");\n    __publicField(this, \"_radPower\");\n    __publicField(this, \"_freq\");\n    __publicField(this, \"_bias\");\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\n  }\n  sample(pointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n  *quantize() {\n    this._init();\n    yield* this._learn();\n    yield {\n      palette: this._buildPalette(),\n      progress: 100\n    };\n  }\n  _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);\n      this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0;\n      this._bias[i] = 0;\n    }\n  }\n  *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < _NeuQuant._minpicturebytes)\n      sampleFactor = 1;\n    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;\n    const pointsToSample = pointsNumber / sampleFactor | 0;\n    let delta = pointsToSample / _NeuQuant._nCycles | 0;\n    let alpha = _NeuQuant._initAlpha;\n    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;\n    let rad = radius >> _NeuQuant._radiusBiasShift;\n    if (rad <= 1)\n      rad = 0;\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;\n    }\n    let step;\n    if (pointsNumber < _NeuQuant._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {\n      step = _NeuQuant._prime1;\n    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {\n      step = _NeuQuant._prime2;\n    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {\n      step = _NeuQuant._prime3;\n    } else {\n      step = _NeuQuant._prime4;\n    }\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0)\n        this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n      pointIndex += step;\n      if (pointIndex >= pointsNumber)\n        pointIndex -= pointsNumber;\n      i++;\n      if (delta === 0)\n        delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec | 0;\n        radius -= radius / _NeuQuant._radiusDecrease | 0;\n        rad = radius >> _NeuQuant._radiusBiasShift;\n        if (rad <= 1)\n          rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;\n        }\n      }\n    }\n  }\n  _buildPalette() {\n    const palette = new Palette();\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n    palette.sort();\n    return palette;\n  }\n  _alterNeighbour(rad, i, b, g, r, al) {\n    let lo = i - rad;\n    if (lo < -1)\n      lo = -1;\n    let hi = i + rad;\n    if (hi > this._networkSize)\n      hi = this._networkSize;\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / _NeuQuant._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n  _alterSingle(alpha, i, b, g, r, a) {\n    alpha /= _NeuQuant._initAlpha;\n    const n = this._network[i];\n    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\n  }\n  _contest(b, g, r, a) {\n    const multiplier = 255 * 4 << networkBiasShift;\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n      const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - networkBiasShift);\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> _NeuQuant._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << _NeuQuant._gammaShift;\n    }\n    this._freq[bestpos] += _NeuQuant._beta;\n    this._bias[bestpos] -= _NeuQuant._betaGamma;\n    return bestbiaspos;\n  }\n};\nvar NeuQuant = _NeuQuant;\n__publicField(NeuQuant, \"_prime1\", 499);\n__publicField(NeuQuant, \"_prime2\", 491);\n__publicField(NeuQuant, \"_prime3\", 487);\n__publicField(NeuQuant, \"_prime4\", 503);\n__publicField(NeuQuant, \"_minpicturebytes\", _NeuQuant._prime4);\n__publicField(NeuQuant, \"_nCycles\", 100);\n__publicField(NeuQuant, \"_initialBiasShift\", 16);\n__publicField(NeuQuant, \"_initialBias\", 1 << _NeuQuant._initialBiasShift);\n__publicField(NeuQuant, \"_gammaShift\", 10);\n__publicField(NeuQuant, \"_betaShift\", 10);\n__publicField(NeuQuant, \"_beta\", _NeuQuant._initialBias >> _NeuQuant._betaShift);\n__publicField(NeuQuant, \"_betaGamma\", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);\n__publicField(NeuQuant, \"_radiusBiasShift\", 6);\n__publicField(NeuQuant, \"_radiusBias\", 1 << _NeuQuant._radiusBiasShift);\n__publicField(NeuQuant, \"_radiusDecrease\", 30);\n__publicField(NeuQuant, \"_alphaBiasShift\", 10);\n__publicField(NeuQuant, \"_initAlpha\", 1 << _NeuQuant._alphaBiasShift);\n__publicField(NeuQuant, \"_radBiasShift\", 8);\n__publicField(NeuQuant, \"_radBias\", 1 << _NeuQuant._radBiasShift);\n__publicField(NeuQuant, \"_alphaRadBiasShift\", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);\n__publicField(NeuQuant, \"_alphaRadBias\", 1 << _NeuQuant._alphaRadBiasShift);\n\n// src/palette/neuquant/neuquantFloat.ts\nvar networkBiasShift2 = 3;\nvar NeuronFloat = class {\n  constructor(defaultValue) {\n    __publicField(this, \"r\");\n    __publicField(this, \"g\");\n    __publicField(this, \"b\");\n    __publicField(this, \"a\");\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n  toPoint() {\n    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);\n  }\n  subtract(r, g, b, a) {\n    this.r -= r;\n    this.g -= g;\n    this.b -= b;\n    this.a -= a;\n  }\n};\nvar _NeuQuantFloat = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator, colors = 256) {\n    super();\n    __publicField(this, \"_pointArray\");\n    __publicField(this, \"_networkSize\");\n    __publicField(this, \"_network\");\n    __publicField(this, \"_sampleFactor\");\n    __publicField(this, \"_radPower\");\n    __publicField(this, \"_freq\");\n    __publicField(this, \"_bias\");\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);\n  }\n  sample(pointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n  *quantize() {\n    this._init();\n    yield* this._learn();\n    yield {\n      palette: this._buildPalette(),\n      progress: 100\n    };\n  }\n  _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new NeuronFloat((i << networkBiasShift2 + 8) / this._networkSize);\n      this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize;\n      this._bias[i] = 0;\n    }\n  }\n  *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < _NeuQuantFloat._minpicturebytes)\n      sampleFactor = 1;\n    const alphadec = 30 + (sampleFactor - 1) / 3;\n    const pointsToSample = pointsNumber / sampleFactor;\n    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;\n    let alpha = _NeuQuantFloat._initAlpha;\n    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;\n    let rad = radius >> _NeuQuantFloat._radiusBiasShift;\n    if (rad <= 1)\n      rad = 0;\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));\n    }\n    let step;\n    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {\n      step = _NeuQuantFloat._prime1;\n    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {\n      step = _NeuQuantFloat._prime2;\n    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {\n      step = _NeuQuantFloat._prime3;\n    } else {\n      step = _NeuQuantFloat._prime4;\n    }\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift2;\n      const g = point.g << networkBiasShift2;\n      const r = point.r << networkBiasShift2;\n      const a = point.a << networkBiasShift2;\n      const neuronIndex = this._contest(b, g, r, a);\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0)\n        this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n      pointIndex += step;\n      if (pointIndex >= pointsNumber)\n        pointIndex -= pointsNumber;\n      i++;\n      if (delta === 0)\n        delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / _NeuQuantFloat._radiusDecrease;\n        rad = radius >> _NeuQuantFloat._radiusBiasShift;\n        if (rad <= 1)\n          rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));\n        }\n      }\n    }\n  }\n  _buildPalette() {\n    const palette = new Palette();\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n    palette.sort();\n    return palette;\n  }\n  _alterNeighbour(rad, i, b, g, r, al) {\n    let lo = i - rad;\n    if (lo < -1)\n      lo = -1;\n    let hi = i + rad;\n    if (hi > this._networkSize)\n      hi = this._networkSize;\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n  _alterSingle(alpha, i, b, g, r, a) {\n    alpha /= _NeuQuantFloat._initAlpha;\n    const n = this._network[i];\n    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\n  }\n  _contest(b, g, r, al) {\n    const multiplier = 255 * 4 << networkBiasShift2;\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n      const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;\n    }\n    this._freq[bestpos] += _NeuQuantFloat._beta;\n    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;\n    return bestbiaspos;\n  }\n};\nvar NeuQuantFloat = _NeuQuantFloat;\n__publicField(NeuQuantFloat, \"_prime1\", 499);\n__publicField(NeuQuantFloat, \"_prime2\", 491);\n__publicField(NeuQuantFloat, \"_prime3\", 487);\n__publicField(NeuQuantFloat, \"_prime4\", 503);\n__publicField(NeuQuantFloat, \"_minpicturebytes\", _NeuQuantFloat._prime4);\n__publicField(NeuQuantFloat, \"_nCycles\", 100);\n__publicField(NeuQuantFloat, \"_initialBiasShift\", 16);\n__publicField(NeuQuantFloat, \"_initialBias\", 1 << _NeuQuantFloat._initialBiasShift);\n__publicField(NeuQuantFloat, \"_gammaShift\", 10);\n__publicField(NeuQuantFloat, \"_betaShift\", 10);\n__publicField(NeuQuantFloat, \"_beta\", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);\n__publicField(NeuQuantFloat, \"_betaGamma\", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);\n__publicField(NeuQuantFloat, \"_radiusBiasShift\", 6);\n__publicField(NeuQuantFloat, \"_radiusBias\", 1 << _NeuQuantFloat._radiusBiasShift);\n__publicField(NeuQuantFloat, \"_radiusDecrease\", 30);\n__publicField(NeuQuantFloat, \"_alphaBiasShift\", 10);\n__publicField(NeuQuantFloat, \"_initAlpha\", 1 << _NeuQuantFloat._alphaBiasShift);\n__publicField(NeuQuantFloat, \"_radBiasShift\", 8);\n__publicField(NeuQuantFloat, \"_radBias\", 1 << _NeuQuantFloat._radBiasShift);\n__publicField(NeuQuantFloat, \"_alphaRadBiasShift\", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);\n__publicField(NeuQuantFloat, \"_alphaRadBias\", 1 << _NeuQuantFloat._alphaRadBiasShift);\n\n// src/palette/rgbquant/colorHistogram.ts\nvar _ColorHistogram = class {\n  constructor(method, colors) {\n    __publicField(this, \"_method\");\n    __publicField(this, \"_hueStats\");\n    __publicField(this, \"_histogram\");\n    __publicField(this, \"_initColors\");\n    __publicField(this, \"_minHueCols\");\n    this._method = method;\n    this._minHueCols = colors << 2;\n    this._initColors = colors << 2;\n    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);\n    this._histogram = /* @__PURE__ */ Object.create(null);\n  }\n  sample(pointContainer) {\n    switch (this._method) {\n      case 1:\n        this._colorStats1D(pointContainer);\n        break;\n      case 2:\n        this._colorStats2D(pointContainer);\n        break;\n    }\n  }\n  getImportanceSortedColorsIDXI32() {\n    const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);\n    if (sorted.length === 0) {\n      return [];\n    }\n    let idxi32;\n    switch (this._method) {\n      case 1:\n        const initialColorsLimit = Math.min(sorted.length, this._initColors);\n        const last = sorted[initialColorsLimit - 1];\n        const freq = this._histogram[last];\n        idxi32 = sorted.slice(0, initialColorsLimit);\n        let pos = initialColorsLimit;\n        const len = sorted.length;\n        while (pos < len && this._histogram[sorted[pos]] === freq) {\n          idxi32.push(sorted[pos++]);\n        }\n        this._hueStats.injectIntoArray(idxi32);\n        break;\n      case 2:\n        idxi32 = sorted;\n        break;\n      default:\n        throw new Error(\"Incorrect method\");\n    }\n    return idxi32.map((v) => +v);\n  }\n  _colorStats1D(pointContainer) {\n    const histG = this._histogram;\n    const pointArray = pointContainer.getPointArray();\n    const len = pointArray.length;\n    for (let i = 0; i < len; i++) {\n      const col = pointArray[i].uint32;\n      this._hueStats.check(col);\n      if (col in histG) {\n        histG[col]++;\n      } else {\n        histG[col] = 1;\n      }\n    }\n  }\n  _colorStats2D(pointContainer) {\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const pointArray = pointContainer.getPointArray();\n    const boxW = _ColorHistogram._boxSize[0];\n    const boxH = _ColorHistogram._boxSize[1];\n    const area = boxW * boxH;\n    const boxes = this._makeBoxes(width, height, boxW, boxH);\n    const histG = this._histogram;\n    boxes.forEach((box) => {\n      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;\n      if (effc < 2)\n        effc = 2;\n      const histL = {};\n      this._iterateBox(box, width, (i) => {\n        const col = pointArray[i].uint32;\n        this._hueStats.check(col);\n        if (col in histG) {\n          histG[col]++;\n        } else if (col in histL) {\n          if (++histL[col] >= effc) {\n            histG[col] = histL[col];\n          }\n        } else {\n          histL[col] = 1;\n        }\n      });\n    });\n    this._hueStats.injectIntoDictionary(histG);\n  }\n  _iterateBox(bbox, wid, fn) {\n    const b = bbox;\n    const i0 = b.y * wid + b.x;\n    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\n    const incr = wid - b.w + 1;\n    let cnt = 0;\n    let i = i0;\n    do {\n      fn.call(this, i);\n      i += ++cnt % b.w === 0 ? incr : 1;\n    } while (i <= i1);\n  }\n  _makeBoxes(width, height, stepX, stepY) {\n    const wrem = width % stepX;\n    const hrem = height % stepY;\n    const xend = width - wrem;\n    const yend = height - hrem;\n    const boxesArray = [];\n    for (let y2 = 0; y2 < height; y2 += stepY) {\n      for (let x2 = 0; x2 < width; x2 += stepX) {\n        boxesArray.push({\n          x: x2,\n          y: y2,\n          w: x2 === xend ? wrem : stepX,\n          h: y2 === yend ? hrem : stepY\n        });\n      }\n    }\n    return boxesArray;\n  }\n};\nvar ColorHistogram = _ColorHistogram;\n__publicField(ColorHistogram, \"_boxSize\", [64, 64]);\n__publicField(ColorHistogram, \"_boxPixels\", 2);\n__publicField(ColorHistogram, \"_hueGroups\", 10);\n\n// src/palette/rgbquant/rgbquant.ts\nvar RemovedColor = class {\n  constructor(index, color, distance) {\n    __publicField(this, \"index\");\n    __publicField(this, \"color\");\n    __publicField(this, \"distance\");\n    this.index = index;\n    this.color = color;\n    this.distance = distance;\n  }\n};\nvar RGBQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator, colors = 256, method = 2) {\n    super();\n    __publicField(this, \"_colors\");\n    __publicField(this, \"_initialDistance\");\n    __publicField(this, \"_distanceIncrement\");\n    __publicField(this, \"_histogram\");\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n    this._colors = colors;\n    this._histogram = new ColorHistogram(method, colors);\n    this._initialDistance = 0.01;\n    this._distanceIncrement = 5e-3;\n  }\n  sample(image) {\n    this._histogram.sample(image);\n  }\n  *quantize() {\n    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\n    if (idxi32.length === 0) {\n      throw new Error(\"No colors in image\");\n    }\n    yield* this._buildPalette(idxi32);\n  }\n  *_buildPalette(idxi32) {\n    const palette = new Palette();\n    const colorArray = palette.getPointContainer().getPointArray();\n    const usageArray = new Array(idxi32.length);\n    for (let i = 0; i < idxi32.length; i++) {\n      colorArray.push(Point.createByUint32(idxi32[i]));\n      usageArray[i] = 1;\n    }\n    const len = colorArray.length;\n    const memDist = [];\n    let palLen = len;\n    let thold = this._initialDistance;\n    const tracker = new ProgressTracker(palLen - this._colors, 99);\n    while (palLen > this._colors) {\n      memDist.length = 0;\n      for (let i = 0; i < len; i++) {\n        if (tracker.shouldNotify(len - palLen)) {\n          yield {\n            progress: tracker.progress\n          };\n        }\n        if (usageArray[i] === 0)\n          continue;\n        const pxi = colorArray[i];\n        for (let j = i + 1; j < len; j++) {\n          if (usageArray[j] === 0)\n            continue;\n          const pxj = colorArray[j];\n          const dist = this._distance.calculateNormalized(pxi, pxj);\n          if (dist < thold) {\n            memDist.push(new RemovedColor(j, pxj, dist));\n            usageArray[j] = 0;\n            palLen--;\n          }\n        }\n      }\n      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;\n    }\n    if (palLen < this._colors) {\n      stableSort(memDist, (a, b) => b.distance - a.distance);\n      let k = 0;\n      while (palLen < this._colors && k < memDist.length) {\n        const removedColor = memDist[k];\n        usageArray[removedColor.index] = 1;\n        palLen++;\n        k++;\n      }\n    }\n    let colors = colorArray.length;\n    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n      if (usageArray[colorIndex] === 0) {\n        if (colorIndex !== colors - 1) {\n          colorArray[colorIndex] = colorArray[colors - 1];\n        }\n        --colors;\n      }\n    }\n    colorArray.length = colors;\n    palette.sort();\n    yield {\n      palette,\n      progress: 100\n    };\n  }\n};\n\n// src/palette/wu/wuQuant.ts\nfunction createArray1D(dimension1) {\n  const a = [];\n  for (let k = 0; k < dimension1; k++) {\n    a[k] = 0;\n  }\n  return a;\n}\nfunction createArray4D(dimension1, dimension2, dimension3, dimension4) {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = new Array(dimension4);\n        for (let l = 0; l < dimension4; l++) {\n          a[i][j][k][l] = 0;\n        }\n      }\n    }\n  }\n  return a;\n}\nfunction createArray3D(dimension1, dimension2, dimension3) {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = 0;\n      }\n    }\n  }\n  return a;\n}\nfunction fillArray3D(a, dimension1, dimension2, dimension3, value) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = [];\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = [];\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = value;\n      }\n    }\n  }\n}\nfunction fillArray1D(a, dimension1, value) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = value;\n  }\n}\nvar WuColorCube = class {\n  constructor() {\n    __publicField(this, \"redMinimum\");\n    __publicField(this, \"redMaximum\");\n    __publicField(this, \"greenMinimum\");\n    __publicField(this, \"greenMaximum\");\n    __publicField(this, \"blueMinimum\");\n    __publicField(this, \"blueMaximum\");\n    __publicField(this, \"volume\");\n    __publicField(this, \"alphaMinimum\");\n    __publicField(this, \"alphaMaximum\");\n  }\n};\nvar _WuQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {\n    super();\n    __publicField(this, \"_reds\");\n    __publicField(this, \"_greens\");\n    __publicField(this, \"_blues\");\n    __publicField(this, \"_alphas\");\n    __publicField(this, \"_sums\");\n    __publicField(this, \"_weights\");\n    __publicField(this, \"_momentsRed\");\n    __publicField(this, \"_momentsGreen\");\n    __publicField(this, \"_momentsBlue\");\n    __publicField(this, \"_momentsAlpha\");\n    __publicField(this, \"_moments\");\n    __publicField(this, \"_table\");\n    __publicField(this, \"_pixels\");\n    __publicField(this, \"_cubes\");\n    __publicField(this, \"_colors\");\n    __publicField(this, \"_significantBitsPerChannel\");\n    __publicField(this, \"_maxSideIndex\");\n    __publicField(this, \"_alphaMaxSideIndex\");\n    __publicField(this, \"_sideSize\");\n    __publicField(this, \"_alphaSideSize\");\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n    this._setQuality(significantBitsPerChannel);\n    this._initialize(colors);\n  }\n  sample(image) {\n    const pointArray = image.getPointArray();\n    for (let i = 0, l = pointArray.length; i < l; i++) {\n      this._addColor(pointArray[i]);\n    }\n    this._pixels = this._pixels.concat(pointArray);\n  }\n  *quantize() {\n    yield* this._preparePalette();\n    const palette = new Palette();\n    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\n      if (this._sums[paletteIndex] > 0) {\n        const sum = this._sums[paletteIndex];\n        const r = this._reds[paletteIndex] / sum;\n        const g = this._greens[paletteIndex] / sum;\n        const b = this._blues[paletteIndex] / sum;\n        const a = this._alphas[paletteIndex] / sum;\n        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\n        palette.add(color);\n      }\n    }\n    palette.sort();\n    yield {\n      palette,\n      progress: 100\n    };\n  }\n  *_preparePalette() {\n    yield* this._calculateMoments();\n    let next = 0;\n    const volumeVariance = createArray1D(this._colors);\n    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\n      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\n        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;\n        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;\n      } else {\n        volumeVariance[next] = 0;\n        cubeIndex--;\n      }\n      next = 0;\n      let temp = volumeVariance[0];\n      for (let index = 1; index <= cubeIndex; ++index) {\n        if (volumeVariance[index] > temp) {\n          temp = volumeVariance[index];\n          next = index;\n        }\n      }\n      if (temp <= 0) {\n        this._colors = cubeIndex + 1;\n        break;\n      }\n    }\n    const lookupRed = [];\n    const lookupGreen = [];\n    const lookupBlue = [];\n    const lookupAlpha = [];\n    for (let k = 0; k < this._colors; ++k) {\n      const weight = _WuQuant._volume(this._cubes[k], this._weights);\n      if (weight > 0) {\n        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;\n        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;\n        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;\n        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;\n      } else {\n        lookupRed[k] = 0;\n        lookupGreen[k] = 0;\n        lookupBlue[k] = 0;\n        lookupAlpha[k] = 0;\n      }\n    }\n    this._reds = createArray1D(this._colors + 1);\n    this._greens = createArray1D(this._colors + 1);\n    this._blues = createArray1D(this._colors + 1);\n    this._alphas = createArray1D(this._colors + 1);\n    this._sums = createArray1D(this._colors + 1);\n    for (let index = 0, l = this._pixels.length; index < l; index++) {\n      const color = this._pixels[index];\n      const match = -1;\n      let bestMatch = match;\n      let bestDistance = Number.MAX_VALUE;\n      for (let lookup = 0; lookup < this._colors; lookup++) {\n        const foundRed = lookupRed[lookup];\n        const foundGreen = lookupGreen[lookup];\n        const foundBlue = lookupBlue[lookup];\n        const foundAlpha = lookupAlpha[lookup];\n        const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = lookup;\n        }\n      }\n      this._reds[bestMatch] += color.r;\n      this._greens[bestMatch] += color.g;\n      this._blues[bestMatch] += color.b;\n      this._alphas[bestMatch] += color.a;\n      this._sums[bestMatch]++;\n    }\n  }\n  _addColor(color) {\n    const bitsToRemove = 8 - this._significantBitsPerChannel;\n    const indexRed = (color.r >> bitsToRemove) + 1;\n    const indexGreen = (color.g >> bitsToRemove) + 1;\n    const indexBlue = (color.b >> bitsToRemove) + 1;\n    const indexAlpha = (color.a >> bitsToRemove) + 1;\n    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\n    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\n    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\n    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\n    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\n    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];\n  }\n  *_calculateMoments() {\n    const area = [];\n    const areaRed = [];\n    const areaGreen = [];\n    const areaBlue = [];\n    const areaAlpha = [];\n    const area2 = [];\n    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    let trackerProgress = 0;\n    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);\n    for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {\n      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);\n      for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {\n        if (tracker.shouldNotify(trackerProgress)) {\n          yield {\n            progress: tracker.progress\n          };\n        }\n        fillArray1D(area, this._sideSize, 0);\n        fillArray1D(areaRed, this._sideSize, 0);\n        fillArray1D(areaGreen, this._sideSize, 0);\n        fillArray1D(areaBlue, this._sideSize, 0);\n        fillArray1D(areaAlpha, this._sideSize, 0);\n        fillArray1D(area2, this._sideSize, 0);\n        for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {\n          let line = 0;\n          let lineRed = 0;\n          let lineGreen = 0;\n          let lineBlue = 0;\n          let lineAlpha = 0;\n          let line2 = 0;\n          for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {\n            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\n            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\n            area[blueIndex] += line;\n            areaRed[blueIndex] += lineRed;\n            areaGreen[blueIndex] += lineGreen;\n            areaBlue[blueIndex] += lineBlue;\n            areaAlpha[blueIndex] += lineAlpha;\n            area2[blueIndex] += line2;\n            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\n            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];\n            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];\n            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];\n            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];\n            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\n            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];\n            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];\n            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];\n            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];\n            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];\n            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];\n          }\n        }\n      }\n    }\n  }\n  static _volumeFloat(cube, moment) {\n    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n  }\n  static _volume(cube, moment) {\n    return _WuQuant._volumeFloat(cube, moment) | 0;\n  }\n  static _top(cube, direction, position, moment) {\n    let result;\n    switch (direction) {\n      case _WuQuant._alpha:\n        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n        break;\n      case _WuQuant._red:\n        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);\n        break;\n      case _WuQuant._green:\n        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);\n        break;\n      case _WuQuant._blue:\n        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);\n        break;\n      default:\n        throw new Error(\"impossible\");\n    }\n    return result | 0;\n  }\n  static _bottom(cube, direction, moment) {\n    switch (direction) {\n      case _WuQuant._alpha:\n        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n      case _WuQuant._red:\n        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n      case _WuQuant._green:\n        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n      case _WuQuant._blue:\n        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n      default:\n        return 0;\n    }\n  }\n  _calculateVariance(cube) {\n    const volumeRed = _WuQuant._volume(cube, this._momentsRed);\n    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);\n    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);\n    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);\n    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);\n    const volumeWeight = _WuQuant._volume(cube, this._weights);\n    const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;\n    return volumeMoment - distance / volumeWeight;\n  }\n  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {\n    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;\n    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;\n    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;\n    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;\n    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;\n    let result = 0;\n    let cutPosition = -1;\n    for (let position = first; position < last; ++position) {\n      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);\n      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);\n      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);\n      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);\n      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);\n      if (halfWeight !== 0) {\n        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\n        let temp = halfDistance / halfWeight;\n        halfRed = wholeRed - halfRed;\n        halfGreen = wholeGreen - halfGreen;\n        halfBlue = wholeBlue - halfBlue;\n        halfAlpha = wholeAlpha - halfAlpha;\n        halfWeight = wholeWeight - halfWeight;\n        if (halfWeight !== 0) {\n          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\n          temp += halfDistance / halfWeight;\n          if (temp > result) {\n            result = temp;\n            cutPosition = position;\n          }\n        }\n      }\n    }\n    return { max: result, position: cutPosition };\n  }\n  _cut(first, second) {\n    let direction;\n    const wholeRed = _WuQuant._volume(first, this._momentsRed);\n    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);\n    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);\n    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);\n    const wholeWeight = _WuQuant._volume(first, this._weights);\n    const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n    const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n    const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {\n      direction = _WuQuant._alpha;\n      if (alpha.position < 0)\n        return false;\n    } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {\n      direction = _WuQuant._red;\n    } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {\n      direction = _WuQuant._green;\n    } else {\n      direction = _WuQuant._blue;\n    }\n    second.redMaximum = first.redMaximum;\n    second.greenMaximum = first.greenMaximum;\n    second.blueMaximum = first.blueMaximum;\n    second.alphaMaximum = first.alphaMaximum;\n    switch (direction) {\n      case _WuQuant._red:\n        second.redMinimum = first.redMaximum = red.position;\n        second.greenMinimum = first.greenMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n      case _WuQuant._green:\n        second.greenMinimum = first.greenMaximum = green.position;\n        second.redMinimum = first.redMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n      case _WuQuant._blue:\n        second.blueMinimum = first.blueMaximum = blue.position;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n      case _WuQuant._alpha:\n        second.alphaMinimum = first.alphaMaximum = alpha.position;\n        second.blueMinimum = first.blueMinimum;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        break;\n    }\n    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);\n    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);\n    return true;\n  }\n  _initialize(colors) {\n    this._colors = colors;\n    this._cubes = [];\n    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\n      this._cubes[cubeIndex] = new WuColorCube();\n    }\n    this._cubes[0].redMinimum = 0;\n    this._cubes[0].greenMinimum = 0;\n    this._cubes[0].blueMinimum = 0;\n    this._cubes[0].alphaMinimum = 0;\n    this._cubes[0].redMaximum = this._maxSideIndex;\n    this._cubes[0].greenMaximum = this._maxSideIndex;\n    this._cubes[0].blueMaximum = this._maxSideIndex;\n    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\n    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._table = [];\n    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\n      this._table[tableIndex] = tableIndex * tableIndex;\n    }\n    this._pixels = [];\n  }\n  _setQuality(significantBitsPerChannel = 5) {\n    this._significantBitsPerChannel = significantBitsPerChannel;\n    this._maxSideIndex = 1 << this._significantBitsPerChannel;\n    this._alphaMaxSideIndex = this._maxSideIndex;\n    this._sideSize = this._maxSideIndex + 1;\n    this._alphaSideSize = this._alphaMaxSideIndex + 1;\n  }\n};\nvar WuQuant = _WuQuant;\n__publicField(WuQuant, \"_alpha\", 3);\n__publicField(WuQuant, \"_red\", 2);\n__publicField(WuQuant, \"_green\", 1);\n__publicField(WuQuant, \"_blue\", 0);\n\n// src/image/index.ts\nvar image_exports = {};\n__export(image_exports, {\n  AbstractImageQuantizer: () => AbstractImageQuantizer,\n  ErrorDiffusionArray: () => ErrorDiffusionArray,\n  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,\n  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,\n  NearestColor: () => NearestColor\n});\n\n// src/image/imageQuantizer.ts\nvar AbstractImageQuantizer = class {\n  quantizeSync(pointContainer, palette) {\n    for (const value of this.quantize(pointContainer, palette)) {\n      if (value.pointContainer) {\n        return value.pointContainer;\n      }\n    }\n    throw new Error(\"unreachable\");\n  }\n};\n\n// src/image/nearestColor.ts\nvar NearestColor = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator) {\n    super();\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n  }\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const tracker = new ProgressTracker(height, 99);\n    for (let y2 = 0; y2 < height; y2++) {\n      if (tracker.shouldNotify(y2)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n      for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {\n        const point = pointArray[idx];\n        point.from(palette.getNearestColor(this._distance, point));\n      }\n    }\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n};\n\n// src/image/array.ts\nvar ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"FloydSteinberg\"] = 0] = \"FloydSteinberg\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"FalseFloydSteinberg\"] = 1] = \"FalseFloydSteinberg\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Stucki\"] = 2] = \"Stucki\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Atkinson\"] = 3] = \"Atkinson\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Jarvis\"] = 4] = \"Jarvis\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Burkes\"] = 5] = \"Burkes\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Sierra\"] = 6] = \"Sierra\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"TwoSierra\"] = 7] = \"TwoSierra\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"SierraLite\"] = 8] = \"SierraLite\";\n  return ErrorDiffusionArrayKernel2;\n})(ErrorDiffusionArrayKernel || {});\nvar ErrorDiffusionArray = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {\n    super();\n    __publicField(this, \"_minColorDistance\");\n    __publicField(this, \"_serpentine\");\n    __publicField(this, \"_kernel\");\n    __publicField(this, \"_calculateErrorLikeGIMP\");\n    __publicField(this, \"_distance\");\n    this._setKernel(kernel);\n    this._distance = colorDistanceCalculator;\n    this._minColorDistance = minimumColorDistanceToDither;\n    this._serpentine = serpentine;\n    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\n  }\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const originalPoint = new Point();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorLines = [];\n    let dir = 1;\n    let maxErrorLines = 1;\n    for (const kernel of this._kernel) {\n      const kernelErrorLines = kernel[2] + 1;\n      if (maxErrorLines < kernelErrorLines)\n        maxErrorLines = kernelErrorLines;\n    }\n    for (let i = 0; i < maxErrorLines; i++) {\n      this._fillErrorLine(errorLines[i] = [], width);\n    }\n    const tracker = new ProgressTracker(height, 99);\n    for (let y2 = 0; y2 < height; y2++) {\n      if (tracker.shouldNotify(y2)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n      if (this._serpentine)\n        dir *= -1;\n      const lni = y2 * width;\n      const xStart = dir === 1 ? 0 : width - 1;\n      const xEnd = dir === 1 ? width : -1;\n      this._fillErrorLine(errorLines[0], width);\n      errorLines.push(errorLines.shift());\n      const errorLine = errorLines[0];\n      for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {\n        const point = pointArray[idx];\n        const error = errorLine[x2];\n        originalPoint.from(point);\n        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));\n        const palettePoint = palette.getNearestColor(this._distance, correctedPoint);\n        point.from(palettePoint);\n        if (this._minColorDistance) {\n          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);\n          if (dist < this._minColorDistance)\n            continue;\n        }\n        let er;\n        let eg;\n        let eb;\n        let ea;\n        if (this._calculateErrorLikeGIMP) {\n          er = correctedPoint.r - palettePoint.r;\n          eg = correctedPoint.g - palettePoint.g;\n          eb = correctedPoint.b - palettePoint.b;\n          ea = correctedPoint.a - palettePoint.a;\n        } else {\n          er = originalPoint.r - palettePoint.r;\n          eg = originalPoint.g - palettePoint.g;\n          eb = originalPoint.b - palettePoint.b;\n          ea = originalPoint.a - palettePoint.a;\n        }\n        const dStart = dir === 1 ? 0 : this._kernel.length - 1;\n        const dEnd = dir === 1 ? this._kernel.length : -1;\n        for (let i = dStart; i !== dEnd; i += dir) {\n          const x1 = this._kernel[i][1] * dir;\n          const y1 = this._kernel[i][2];\n          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {\n            const d = this._kernel[i][0];\n            const e = errorLines[y1][x1 + x2];\n            e[0] += er * d;\n            e[1] += eg * d;\n            e[2] += eb * d;\n            e[3] += ea * d;\n          }\n        }\n      }\n    }\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n  _fillErrorLine(errorLine, width) {\n    if (errorLine.length > width) {\n      errorLine.length = width;\n    }\n    const l = errorLine.length;\n    for (let i = 0; i < l; i++) {\n      const error = errorLine[i];\n      error[0] = error[1] = error[2] = error[3] = 0;\n    }\n    for (let i = l; i < width; i++) {\n      errorLine[i] = [0, 0, 0, 0];\n    }\n  }\n  _setKernel(kernel) {\n    switch (kernel) {\n      case 0 /* FloydSteinberg */:\n        this._kernel = [\n          [7 / 16, 1, 0],\n          [3 / 16, -1, 1],\n          [5 / 16, 0, 1],\n          [1 / 16, 1, 1]\n        ];\n        break;\n      case 1 /* FalseFloydSteinberg */:\n        this._kernel = [\n          [3 / 8, 1, 0],\n          [3 / 8, 0, 1],\n          [2 / 8, 1, 1]\n        ];\n        break;\n      case 2 /* Stucki */:\n        this._kernel = [\n          [8 / 42, 1, 0],\n          [4 / 42, 2, 0],\n          [2 / 42, -2, 1],\n          [4 / 42, -1, 1],\n          [8 / 42, 0, 1],\n          [4 / 42, 1, 1],\n          [2 / 42, 2, 1],\n          [1 / 42, -2, 2],\n          [2 / 42, -1, 2],\n          [4 / 42, 0, 2],\n          [2 / 42, 1, 2],\n          [1 / 42, 2, 2]\n        ];\n        break;\n      case 3 /* Atkinson */:\n        this._kernel = [\n          [1 / 8, 1, 0],\n          [1 / 8, 2, 0],\n          [1 / 8, -1, 1],\n          [1 / 8, 0, 1],\n          [1 / 8, 1, 1],\n          [1 / 8, 0, 2]\n        ];\n        break;\n      case 4 /* Jarvis */:\n        this._kernel = [\n          [7 / 48, 1, 0],\n          [5 / 48, 2, 0],\n          [3 / 48, -2, 1],\n          [5 / 48, -1, 1],\n          [7 / 48, 0, 1],\n          [5 / 48, 1, 1],\n          [3 / 48, 2, 1],\n          [1 / 48, -2, 2],\n          [3 / 48, -1, 2],\n          [5 / 48, 0, 2],\n          [3 / 48, 1, 2],\n          [1 / 48, 2, 2]\n        ];\n        break;\n      case 5 /* Burkes */:\n        this._kernel = [\n          [8 / 32, 1, 0],\n          [4 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [8 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1]\n        ];\n        break;\n      case 6 /* Sierra */:\n        this._kernel = [\n          [5 / 32, 1, 0],\n          [3 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [5 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1],\n          [2 / 32, -1, 2],\n          [3 / 32, 0, 2],\n          [2 / 32, 1, 2]\n        ];\n        break;\n      case 7 /* TwoSierra */:\n        this._kernel = [\n          [4 / 16, 1, 0],\n          [3 / 16, 2, 0],\n          [1 / 16, -2, 1],\n          [2 / 16, -1, 1],\n          [3 / 16, 0, 1],\n          [2 / 16, 1, 1],\n          [1 / 16, 2, 1]\n        ];\n        break;\n      case 8 /* SierraLite */:\n        this._kernel = [\n          [2 / 4, 1, 0],\n          [1 / 4, -1, 1],\n          [1 / 4, 0, 1]\n        ];\n        break;\n      default:\n        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);\n    }\n  }\n};\n\n// src/image/spaceFillingCurves/hilbertCurve.ts\nfunction* hilbertCurve(width, height, callback) {\n  const maxBound = Math.max(width, height);\n  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);\n  const tracker = new ProgressTracker(width * height, 99);\n  const data = {\n    width,\n    height,\n    level,\n    callback,\n    tracker,\n    index: 0,\n    x: 0,\n    y: 0\n  };\n  yield* walkHilbert(data, 1 /* UP */);\n  visit(data, 0 /* NONE */);\n}\nfunction* walkHilbert(data, direction) {\n  if (data.level < 1)\n    return;\n  if (data.tracker.shouldNotify(data.index)) {\n    yield { progress: data.tracker.progress };\n  }\n  data.level--;\n  switch (direction) {\n    case 2 /* LEFT */:\n      yield* walkHilbert(data, 1 /* UP */);\n      visit(data, 3 /* RIGHT */);\n      yield* walkHilbert(data, 2 /* LEFT */);\n      visit(data, 4 /* DOWN */);\n      yield* walkHilbert(data, 2 /* LEFT */);\n      visit(data, 2 /* LEFT */);\n      yield* walkHilbert(data, 4 /* DOWN */);\n      break;\n    case 3 /* RIGHT */:\n      yield* walkHilbert(data, 4 /* DOWN */);\n      visit(data, 2 /* LEFT */);\n      yield* walkHilbert(data, 3 /* RIGHT */);\n      visit(data, 1 /* UP */);\n      yield* walkHilbert(data, 3 /* RIGHT */);\n      visit(data, 3 /* RIGHT */);\n      yield* walkHilbert(data, 1 /* UP */);\n      break;\n    case 1 /* UP */:\n      yield* walkHilbert(data, 2 /* LEFT */);\n      visit(data, 4 /* DOWN */);\n      yield* walkHilbert(data, 1 /* UP */);\n      visit(data, 3 /* RIGHT */);\n      yield* walkHilbert(data, 1 /* UP */);\n      visit(data, 1 /* UP */);\n      yield* walkHilbert(data, 3 /* RIGHT */);\n      break;\n    case 4 /* DOWN */:\n      yield* walkHilbert(data, 3 /* RIGHT */);\n      visit(data, 1 /* UP */);\n      yield* walkHilbert(data, 4 /* DOWN */);\n      visit(data, 2 /* LEFT */);\n      yield* walkHilbert(data, 4 /* DOWN */);\n      visit(data, 4 /* DOWN */);\n      yield* walkHilbert(data, 2 /* LEFT */);\n      break;\n    default:\n      break;\n  }\n  data.level++;\n}\nfunction visit(data, direction) {\n  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {\n    data.callback(data.x, data.y);\n    data.index++;\n  }\n  switch (direction) {\n    case 2 /* LEFT */:\n      data.x--;\n      break;\n    case 3 /* RIGHT */:\n      data.x++;\n      break;\n    case 1 /* UP */:\n      data.y--;\n      break;\n    case 4 /* DOWN */:\n      data.y++;\n      break;\n  }\n}\n\n// src/image/riemersma.ts\nvar ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {\n    super();\n    __publicField(this, \"_distance\");\n    __publicField(this, \"_weights\");\n    __publicField(this, \"_errorQueueSize\");\n    this._distance = colorDistanceCalculator;\n    this._errorQueueSize = errorQueueSize;\n    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);\n  }\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorQueue = [];\n    let head = 0;\n    for (let i = 0; i < this._errorQueueSize; i++) {\n      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };\n    }\n    yield* hilbertCurve(width, height, (x2, y2) => {\n      const p = pointArray[x2 + y2 * width];\n      let { r, g, b, a } = p;\n      for (let i = 0; i < this._errorQueueSize; i++) {\n        const weight = this._weights[i];\n        const e = errorQueue[(i + head) % this._errorQueueSize];\n        r += e.r * weight;\n        g += e.g * weight;\n        b += e.b * weight;\n        a += e.a * weight;\n      }\n      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));\n      const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);\n      head = (head + 1) % this._errorQueueSize;\n      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\n      errorQueue[tail].r = p.r - quantizedPoint.r;\n      errorQueue[tail].g = p.g - quantizedPoint.g;\n      errorQueue[tail].b = p.b - quantizedPoint.b;\n      errorQueue[tail].a = p.a - quantizedPoint.a;\n      p.from(quantizedPoint);\n    });\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n  static _createWeights(errorPropagation, errorQueueSize) {\n    const weights = [];\n    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));\n    for (let i = 0, next = 1; i < errorQueueSize; i++) {\n      weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;\n      next *= multiplier;\n    }\n    return weights;\n  }\n};\n\n// src/quality/index.ts\nvar quality_exports = {};\n__export(quality_exports, {\n  ssim: () => ssim\n});\n\n// src/quality/ssim.ts\nvar K1 = 0.01;\nvar K2 = 0.03;\nfunction ssim(image1, image2) {\n  if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {\n    throw new Error(\"Images have different sizes!\");\n  }\n  const bitsPerComponent = 8;\n  const L = (1 << bitsPerComponent) - 1;\n  const c1 = (K1 * L) ** 2;\n  const c2 = (K2 * L) ** 2;\n  let numWindows = 0;\n  let mssim = 0;\n  iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {\n    let sigxy = 0;\n    let sigsqx = 0;\n    let sigsqy = 0;\n    for (let i = 0; i < lumaValues1.length; i++) {\n      sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;\n      sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;\n      sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);\n    }\n    const numPixelsInWin = lumaValues1.length - 1;\n    sigsqx /= numPixelsInWin;\n    sigsqy /= numPixelsInWin;\n    sigxy /= numPixelsInWin;\n    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\n    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);\n    const ssim2 = numerator / denominator;\n    mssim += ssim2;\n    numWindows++;\n  });\n  return mssim / numWindows;\n}\nfunction iterate(image1, image2, callback) {\n  const windowSize = 8;\n  const width = image1.getWidth();\n  const height = image1.getHeight();\n  for (let y2 = 0; y2 < height; y2 += windowSize) {\n    for (let x2 = 0; x2 < width; x2 += windowSize) {\n      const windowWidth = Math.min(windowSize, width - x2);\n      const windowHeight = Math.min(windowSize, height - y2);\n      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);\n      const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);\n      const averageLuma1 = calculateAverageLuma(lumaValues1);\n      const averageLuma2 = calculateAverageLuma(lumaValues2);\n      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\n    }\n  }\n}\nfunction calculateLumaValuesForWindow(image, x2, y2, width, height) {\n  const pointArray = image.getPointArray();\n  const lumaValues = [];\n  let counter = 0;\n  for (let j = y2; j < y2 + height; j++) {\n    const offset = j * image.getWidth();\n    for (let i = x2; i < x2 + width; i++) {\n      const point = pointArray[offset + i];\n      lumaValues[counter] = point.r * 0.2126 /* RED */ + point.g * 0.7152 /* GREEN */ + point.b * 0.0722 /* BLUE */;\n      counter++;\n    }\n  }\n  return lumaValues;\n}\nfunction calculateAverageLuma(lumaValues) {\n  let sumLuma = 0;\n  for (const luma of lumaValues) {\n    sumLuma += luma;\n  }\n  return sumLuma / lumaValues.length;\n}\n\n// src/basicAPI.ts\nvar setImmediateImpl = typeof setImmediate === \"function\" ? setImmediate : typeof process !== \"undefined\" && typeof (process == null ? void 0 : process.nextTick) === \"function\" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);\nfunction buildPaletteSync(images, {\n  colorDistanceFormula,\n  paletteQuantization,\n  colors\n} = {}) {\n  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\n  images.forEach((image) => paletteQuantizer.sample(image));\n  return paletteQuantizer.quantizeSync();\n}\nasync function buildPalette(images, {\n  colorDistanceFormula,\n  paletteQuantization,\n  colors,\n  onProgress\n} = {}) {\n  return new Promise((resolve, reject) => {\n    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\n    images.forEach((image) => paletteQuantizer.sample(image));\n    let palette;\n    const iterator = paletteQuantizer.quantize();\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(palette);\n        } else {\n          if (result.value.palette)\n            palette = result.value.palette;\n          if (onProgress)\n            onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\nfunction applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {\n  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\n  return imageQuantizer.quantizeSync(image, palette);\n}\nasync function applyPalette(image, palette, {\n  colorDistanceFormula,\n  imageQuantization,\n  onProgress\n} = {}) {\n  return new Promise((resolve, reject) => {\n    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\n    let outPointContainer;\n    const iterator = imageQuantizer.quantize(image, palette);\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(outPointContainer);\n        } else {\n          if (result.value.pointContainer) {\n            outPointContainer = result.value.pointContainer;\n          }\n          if (onProgress)\n            onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\nfunction colorDistanceFormulaToColorDistance(colorDistanceFormula = \"euclidean-bt709\") {\n  switch (colorDistanceFormula) {\n    case \"cie94-graphic-arts\":\n      return new CIE94GraphicArts();\n    case \"cie94-textiles\":\n      return new CIE94Textiles();\n    case \"ciede2000\":\n      return new CIEDE2000();\n    case \"color-metric\":\n      return new CMetric();\n    case \"euclidean\":\n      return new Euclidean();\n    case \"euclidean-bt709\":\n      return new EuclideanBT709();\n    case \"euclidean-bt709-noalpha\":\n      return new EuclideanBT709NoAlpha();\n    case \"manhattan\":\n      return new Manhattan();\n    case \"manhattan-bt709\":\n      return new ManhattanBT709();\n    case \"manhattan-nommyde\":\n      return new ManhattanNommyde();\n    case \"pngquant\":\n      return new PNGQuant();\n    default:\n      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);\n  }\n}\nfunction imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = \"floyd-steinberg\") {\n  switch (imageQuantization) {\n    case \"nearest\":\n      return new NearestColor(distanceCalculator);\n    case \"riemersma\":\n      return new ErrorDiffusionRiemersma(distanceCalculator);\n    case \"floyd-steinberg\":\n      return new ErrorDiffusionArray(distanceCalculator, 0 /* FloydSteinberg */);\n    case \"false-floyd-steinberg\":\n      return new ErrorDiffusionArray(distanceCalculator, 1 /* FalseFloydSteinberg */);\n    case \"stucki\":\n      return new ErrorDiffusionArray(distanceCalculator, 2 /* Stucki */);\n    case \"atkinson\":\n      return new ErrorDiffusionArray(distanceCalculator, 3 /* Atkinson */);\n    case \"jarvis\":\n      return new ErrorDiffusionArray(distanceCalculator, 4 /* Jarvis */);\n    case \"burkes\":\n      return new ErrorDiffusionArray(distanceCalculator, 5 /* Burkes */);\n    case \"sierra\":\n      return new ErrorDiffusionArray(distanceCalculator, 6 /* Sierra */);\n    case \"two-sierra\":\n      return new ErrorDiffusionArray(distanceCalculator, 7 /* TwoSierra */);\n    case \"sierra-lite\":\n      return new ErrorDiffusionArray(distanceCalculator, 8 /* SierraLite */);\n    default:\n      throw new Error(`Unknown imageQuantization ${imageQuantization}`);\n  }\n}\nfunction paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = \"wuquant\", colors = 256) {\n  switch (paletteQuantization) {\n    case \"neuquant\":\n      return new NeuQuant(distanceCalculator, colors);\n    case \"rgbquant\":\n      return new RGBQuant(distanceCalculator, colors);\n    case \"wuquant\":\n      return new WuQuant(distanceCalculator, colors);\n    case \"neuquant-float\":\n      return new NeuQuantFloat(distanceCalculator, colors);\n    default:\n      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);\n  }\n}\nmodule.exports = __toCommonJS(src_exports);\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cie94.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ciede2000.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cmetric.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * euclidean.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * helper.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * hueStatistics.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2rgb.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2xyz.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * manhattanNeuQuant.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * nearestColor.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * palette.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pngQuant.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * point.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pointContainer.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2hsl.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2lab.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2xyz.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ssim.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * wuQuant.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2lab.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2rgb.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * MIT License\n *\n * Copyright 2015-2018 Igor Bezkrovnyi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * riemersma.ts - part of Image Quantization Library\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * colorHistogram.ts - part of Image Quantization Library\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgbquant.ts - part of Image Quantization Library\n */\n//# sourceMappingURL=image-q.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pbWFnZS1xL2Rpc3QvY2pzL2ltYWdlLXEuY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlDQUFpQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxPQUFPO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5Qyx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNENBQTRDLDBDQUEwQyxJQUFJO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9CQUFvQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FZTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dG4vLi9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2Nqcy9pbWFnZS1xLmNqcz9jNWI5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGNvcHlEZWZhdWx0LCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiAoY29weURlZmF1bHQgfHwga2V5ICE9PSBcImRlZmF1bHRcIikpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b0NvbW1vbkpTID0gLyogQF9fUFVSRV9fICovICgoY2FjaGUpID0+IHtcbiAgcmV0dXJuIChtb2R1bGUyLCB0ZW1wKSA9PiB7XG4gICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlLmdldChtb2R1bGUyKSB8fCAodGVtcCA9IF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoe30pLCBtb2R1bGUyLCAxKSwgY2FjaGUgJiYgY2FjaGUuc2V0KG1vZHVsZTIsIHRlbXApLCB0ZW1wKTtcbiAgfTtcbn0pKHR5cGVvZiBXZWFrTWFwICE9PSBcInVuZGVmaW5lZFwiID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkgOiAwKTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgYXBwbHlQYWxldHRlOiAoKSA9PiBhcHBseVBhbGV0dGUsXG4gIGFwcGx5UGFsZXR0ZVN5bmM6ICgpID0+IGFwcGx5UGFsZXR0ZVN5bmMsXG4gIGJ1aWxkUGFsZXR0ZTogKCkgPT4gYnVpbGRQYWxldHRlLFxuICBidWlsZFBhbGV0dGVTeW5jOiAoKSA9PiBidWlsZFBhbGV0dGVTeW5jLFxuICBjb25zdGFudHM6ICgpID0+IGNvbnN0YW50c19leHBvcnRzLFxuICBjb252ZXJzaW9uOiAoKSA9PiBjb252ZXJzaW9uX2V4cG9ydHMsXG4gIGRpc3RhbmNlOiAoKSA9PiBkaXN0YW5jZV9leHBvcnRzLFxuICBpbWFnZTogKCkgPT4gaW1hZ2VfZXhwb3J0cyxcbiAgcGFsZXR0ZTogKCkgPT4gcGFsZXR0ZV9leHBvcnRzLFxuICBxdWFsaXR5OiAoKSA9PiBxdWFsaXR5X2V4cG9ydHMsXG4gIHV0aWxzOiAoKSA9PiB1dGlsc19leHBvcnRzXG59KTtcblxuLy8gc3JjL2NvbnN0YW50cy9pbmRleC50c1xudmFyIGNvbnN0YW50c19leHBvcnRzID0ge307XG5fX2V4cG9ydChjb25zdGFudHNfZXhwb3J0cywge1xuICBidDcwOTogKCkgPT4gYnQ3MDlfZXhwb3J0c1xufSk7XG5cbi8vIHNyYy9jb25zdGFudHMvYnQ3MDkudHNcbnZhciBidDcwOV9leHBvcnRzID0ge307XG5fX2V4cG9ydChidDcwOV9leHBvcnRzLCB7XG4gIFk6ICgpID0+IFksXG4gIHg6ICgpID0+IHgsXG4gIHk6ICgpID0+IHlcbn0pO1xudmFyIFkgPSAvKiBAX19QVVJFX18gKi8gKChZMikgPT4ge1xuICBZMltZMltcIlJFRFwiXSA9IDAuMjEyNl0gPSBcIlJFRFwiO1xuICBZMltZMltcIkdSRUVOXCJdID0gMC43MTUyXSA9IFwiR1JFRU5cIjtcbiAgWTJbWTJbXCJCTFVFXCJdID0gMC4wNzIyXSA9IFwiQkxVRVwiO1xuICBZMltZMltcIldISVRFXCJdID0gMV0gPSBcIldISVRFXCI7XG4gIHJldHVybiBZMjtcbn0pKFkgfHwge30pO1xudmFyIHggPSAvKiBAX19QVVJFX18gKi8gKCh4MikgPT4ge1xuICB4Mlt4MltcIlJFRFwiXSA9IDAuNjRdID0gXCJSRURcIjtcbiAgeDJbeDJbXCJHUkVFTlwiXSA9IDAuM10gPSBcIkdSRUVOXCI7XG4gIHgyW3gyW1wiQkxVRVwiXSA9IDAuMTVdID0gXCJCTFVFXCI7XG4gIHgyW3gyW1wiV0hJVEVcIl0gPSAwLjMxMjddID0gXCJXSElURVwiO1xuICByZXR1cm4geDI7XG59KSh4IHx8IHt9KTtcbnZhciB5ID0gLyogQF9fUFVSRV9fICovICgoeTIpID0+IHtcbiAgeTJbeTJbXCJSRURcIl0gPSAwLjMzXSA9IFwiUkVEXCI7XG4gIHkyW3kyW1wiR1JFRU5cIl0gPSAwLjZdID0gXCJHUkVFTlwiO1xuICB5Mlt5MltcIkJMVUVcIl0gPSAwLjA2XSA9IFwiQkxVRVwiO1xuICB5Mlt5MltcIldISVRFXCJdID0gMC4zMjldID0gXCJXSElURVwiO1xuICByZXR1cm4geTI7XG59KSh5IHx8IHt9KTtcblxuLy8gc3JjL2NvbnZlcnNpb24vaW5kZXgudHNcbnZhciBjb252ZXJzaW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnZlcnNpb25fZXhwb3J0cywge1xuICBsYWIycmdiOiAoKSA9PiBsYWIycmdiLFxuICBsYWIyeHl6OiAoKSA9PiBsYWIyeHl6LFxuICByZ2IyaHNsOiAoKSA9PiByZ2IyaHNsLFxuICByZ2IybGFiOiAoKSA9PiByZ2IybGFiLFxuICByZ2IyeHl6OiAoKSA9PiByZ2IyeHl6LFxuICB4eXoybGFiOiAoKSA9PiB4eXoybGFiLFxuICB4eXoycmdiOiAoKSA9PiB4eXoycmdiXG59KTtcblxuLy8gc3JjL2NvbnZlcnNpb24vcmdiMnh5ei50c1xuZnVuY3Rpb24gY29ycmVjdEdhbW1hKG4pIHtcbiAgcmV0dXJuIG4gPiAwLjA0MDQ1ID8gKChuICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IG4gLyAxMi45Mjtcbn1cbmZ1bmN0aW9uIHJnYjJ4eXoociwgZywgYikge1xuICByID0gY29ycmVjdEdhbW1hKHIgLyAyNTUpO1xuICBnID0gY29ycmVjdEdhbW1hKGcgLyAyNTUpO1xuICBiID0gY29ycmVjdEdhbW1hKGIgLyAyNTUpO1xuICByZXR1cm4ge1xuICAgIHg6IHIgKiAwLjQxMjQgKyBnICogMC4zNTc2ICsgYiAqIDAuMTgwNSxcbiAgICB5OiByICogMC4yMTI2ICsgZyAqIDAuNzE1MiArIGIgKiAwLjA3MjIsXG4gICAgejogciAqIDAuMDE5MyArIGcgKiAwLjExOTIgKyBiICogMC45NTA1XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9hcml0aG1ldGljLnRzXG52YXIgYXJpdGhtZXRpY19leHBvcnRzID0ge307XG5fX2V4cG9ydChhcml0aG1ldGljX2V4cG9ydHMsIHtcbiAgZGVncmVlczJyYWRpYW5zOiAoKSA9PiBkZWdyZWVzMnJhZGlhbnMsXG4gIGluUmFuZ2UwdG8yNTU6ICgpID0+IGluUmFuZ2UwdG8yNTUsXG4gIGluUmFuZ2UwdG8yNTVSb3VuZGVkOiAoKSA9PiBpblJhbmdlMHRvMjU1Um91bmRlZCxcbiAgaW50SW5SYW5nZTogKCkgPT4gaW50SW5SYW5nZSxcbiAgbWF4MzogKCkgPT4gbWF4MyxcbiAgbWluMzogKCkgPT4gbWluMyxcbiAgc3RhYmxlU29ydDogKCkgPT4gc3RhYmxlU29ydFxufSk7XG5mdW5jdGlvbiBkZWdyZWVzMnJhZGlhbnMobikge1xuICByZXR1cm4gbiAqIChNYXRoLlBJIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIG1heDMoYSwgYiwgYykge1xuICBsZXQgbSA9IGE7XG4gIGlmIChtIDwgYilcbiAgICBtID0gYjtcbiAgaWYgKG0gPCBjKVxuICAgIG0gPSBjO1xuICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIG1pbjMoYSwgYiwgYykge1xuICBsZXQgbSA9IGE7XG4gIGlmIChtID4gYilcbiAgICBtID0gYjtcbiAgaWYgKG0gPiBjKVxuICAgIG0gPSBjO1xuICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIGludEluUmFuZ2UodmFsdWUsIGxvdywgaGlnaCkge1xuICBpZiAodmFsdWUgPiBoaWdoKVxuICAgIHZhbHVlID0gaGlnaDtcbiAgaWYgKHZhbHVlIDwgbG93KVxuICAgIHZhbHVlID0gbG93O1xuICByZXR1cm4gdmFsdWUgfCAwO1xufVxuZnVuY3Rpb24gaW5SYW5nZTB0bzI1NVJvdW5kZWQobikge1xuICBuID0gTWF0aC5yb3VuZChuKTtcbiAgaWYgKG4gPiAyNTUpXG4gICAgbiA9IDI1NTtcbiAgZWxzZSBpZiAobiA8IDApXG4gICAgbiA9IDA7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gaW5SYW5nZTB0bzI1NShuKSB7XG4gIGlmIChuID4gMjU1KVxuICAgIG4gPSAyNTU7XG4gIGVsc2UgaWYgKG4gPCAwKVxuICAgIG4gPSAwO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHN0YWJsZVNvcnQoYXJyYXlUb1NvcnQsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJyYXlUb1NvcnRbMF07XG4gIGxldCBzb3J0ZWQ7XG4gIGlmICh0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBvcmQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5VG9Tb3J0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgdmFsID0gYXJyYXlUb1NvcnRbaV07XG4gICAgICBpZiAob3JkW3ZhbF0gfHwgb3JkW3ZhbF0gPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgb3JkW3ZhbF0gPSBpO1xuICAgIH1cbiAgICBzb3J0ZWQgPSBhcnJheVRvU29ydC5zb3J0KChhLCBiKSA9PiBjYWxsYmFjayhhLCBiKSB8fCBvcmRbYV0gLSBvcmRbYl0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG9yZDIgPSBhcnJheVRvU29ydC5zbGljZSgwKTtcbiAgICBzb3J0ZWQgPSBhcnJheVRvU29ydC5zb3J0KChhLCBiKSA9PiBjYWxsYmFjayhhLCBiKSB8fCBvcmQyLmluZGV4T2YoYSkgLSBvcmQyLmluZGV4T2YoYikpO1xuICB9XG4gIHJldHVybiBzb3J0ZWQ7XG59XG5cbi8vIHNyYy9jb252ZXJzaW9uL3JnYjJoc2wudHNcbmZ1bmN0aW9uIHJnYjJoc2wociwgZywgYikge1xuICBjb25zdCBtaW4gPSBtaW4zKHIsIGcsIGIpO1xuICBjb25zdCBtYXggPSBtYXgzKHIsIGcsIGIpO1xuICBjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcbiAgY29uc3QgbCA9IChtaW4gKyBtYXgpIC8gNTEwO1xuICBsZXQgcyA9IDA7XG4gIGlmIChsID4gMCAmJiBsIDwgMSlcbiAgICBzID0gZGVsdGEgLyAobCA8IDAuNSA/IG1heCArIG1pbiA6IDUxMCAtIG1heCAtIG1pbik7XG4gIGxldCBoID0gMDtcbiAgaWYgKGRlbHRhID4gMCkge1xuICAgIGlmIChtYXggPT09IHIpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIGlmIChtYXggPT09IGcpIHtcbiAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICB9XG4gICAgaCAqPSA2MDtcbiAgICBpZiAoaCA8IDApXG4gICAgICBoICs9IDM2MDtcbiAgfVxuICByZXR1cm4geyBoLCBzLCBsIH07XG59XG5cbi8vIHNyYy9jb252ZXJzaW9uL3h5ejJsYWIudHNcbnZhciByZWZYID0gMC45NTA0NztcbnZhciByZWZZID0gMTtcbnZhciByZWZaID0gMS4wODg4MztcbmZ1bmN0aW9uIHBpdm90KG4pIHtcbiAgcmV0dXJuIG4gPiA4ODU2ZS02ID8gbiAqKiAoMSAvIDMpIDogNy43ODcgKiBuICsgMTYgLyAxMTY7XG59XG5mdW5jdGlvbiB4eXoybGFiKHgyLCB5Miwgeikge1xuICB4MiA9IHBpdm90KHgyIC8gcmVmWCk7XG4gIHkyID0gcGl2b3QoeTIgLyByZWZZKTtcbiAgeiA9IHBpdm90KHogLyByZWZaKTtcbiAgaWYgKDExNiAqIHkyIC0gMTYgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcInh4eFwiKTtcbiAgcmV0dXJuIHtcbiAgICBMOiBNYXRoLm1heCgwLCAxMTYgKiB5MiAtIDE2KSxcbiAgICBhOiA1MDAgKiAoeDIgLSB5MiksXG4gICAgYjogMjAwICogKHkyIC0geilcbiAgfTtcbn1cblxuLy8gc3JjL2NvbnZlcnNpb24vcmdiMmxhYi50c1xuZnVuY3Rpb24gcmdiMmxhYihyLCBnLCBiKSB7XG4gIGNvbnN0IHh5eiA9IHJnYjJ4eXoociwgZywgYik7XG4gIHJldHVybiB4eXoybGFiKHh5ei54LCB4eXoueSwgeHl6LnopO1xufVxuXG4vLyBzcmMvY29udmVyc2lvbi9sYWIyeHl6LnRzXG52YXIgcmVmWDIgPSAwLjk1MDQ3O1xudmFyIHJlZlkyID0gMTtcbnZhciByZWZaMiA9IDEuMDg4ODM7XG5mdW5jdGlvbiBwaXZvdDIobikge1xuICByZXR1cm4gbiA+IDAuMjA2ODkzMDM0ID8gbiAqKiAzIDogKG4gLSAxNiAvIDExNikgLyA3Ljc4Nztcbn1cbmZ1bmN0aW9uIGxhYjJ4eXooTCwgYSwgYikge1xuICBjb25zdCB5MiA9IChMICsgMTYpIC8gMTE2O1xuICBjb25zdCB4MiA9IGEgLyA1MDAgKyB5MjtcbiAgY29uc3QgeiA9IHkyIC0gYiAvIDIwMDtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWZYMiAqIHBpdm90Mih4MiksXG4gICAgeTogcmVmWTIgKiBwaXZvdDIoeTIpLFxuICAgIHo6IHJlZloyICogcGl2b3QyKHopXG4gIH07XG59XG5cbi8vIHNyYy9jb252ZXJzaW9uL3h5ejJyZ2IudHNcbmZ1bmN0aW9uIGNvcnJlY3RHYW1tYTIobikge1xuICByZXR1cm4gbiA+IDMxMzA4ZS03ID8gMS4wNTUgKiBuICoqICgxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiBuO1xufVxuZnVuY3Rpb24geHl6MnJnYih4MiwgeTIsIHopIHtcbiAgY29uc3QgciA9IGNvcnJlY3RHYW1tYTIoeDIgKiAzLjI0MDYgKyB5MiAqIC0xLjUzNzIgKyB6ICogLTAuNDk4Nik7XG4gIGNvbnN0IGcgPSBjb3JyZWN0R2FtbWEyKHgyICogLTAuOTY4OSArIHkyICogMS44NzU4ICsgeiAqIDAuMDQxNSk7XG4gIGNvbnN0IGIgPSBjb3JyZWN0R2FtbWEyKHgyICogMC4wNTU3ICsgeTIgKiAtMC4yMDQgKyB6ICogMS4wNTcpO1xuICByZXR1cm4ge1xuICAgIHI6IGluUmFuZ2UwdG8yNTVSb3VuZGVkKHIgKiAyNTUpLFxuICAgIGc6IGluUmFuZ2UwdG8yNTVSb3VuZGVkKGcgKiAyNTUpLFxuICAgIGI6IGluUmFuZ2UwdG8yNTVSb3VuZGVkKGIgKiAyNTUpXG4gIH07XG59XG5cbi8vIHNyYy9jb252ZXJzaW9uL2xhYjJyZ2IudHNcbmZ1bmN0aW9uIGxhYjJyZ2IoTCwgYSwgYikge1xuICBjb25zdCB4eXogPSBsYWIyeHl6KEwsIGEsIGIpO1xuICByZXR1cm4geHl6MnJnYih4eXoueCwgeHl6LnksIHh5ei56KTtcbn1cblxuLy8gc3JjL2Rpc3RhbmNlL2luZGV4LnRzXG52YXIgZGlzdGFuY2VfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZGlzdGFuY2VfZXhwb3J0cywge1xuICBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvcjogKCkgPT4gQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IsXG4gIEFic3RyYWN0RXVjbGlkZWFuOiAoKSA9PiBBYnN0cmFjdEV1Y2xpZGVhbixcbiAgQWJzdHJhY3RNYW5oYXR0YW46ICgpID0+IEFic3RyYWN0TWFuaGF0dGFuLFxuICBDSUU5NEdyYXBoaWNBcnRzOiAoKSA9PiBDSUU5NEdyYXBoaWNBcnRzLFxuICBDSUU5NFRleHRpbGVzOiAoKSA9PiBDSUU5NFRleHRpbGVzLFxuICBDSUVERTIwMDA6ICgpID0+IENJRURFMjAwMCxcbiAgQ01ldHJpYzogKCkgPT4gQ01ldHJpYyxcbiAgRXVjbGlkZWFuOiAoKSA9PiBFdWNsaWRlYW4sXG4gIEV1Y2xpZGVhbkJUNzA5OiAoKSA9PiBFdWNsaWRlYW5CVDcwOSxcbiAgRXVjbGlkZWFuQlQ3MDlOb0FscGhhOiAoKSA9PiBFdWNsaWRlYW5CVDcwOU5vQWxwaGEsXG4gIE1hbmhhdHRhbjogKCkgPT4gTWFuaGF0dGFuLFxuICBNYW5oYXR0YW5CVDcwOTogKCkgPT4gTWFuaGF0dGFuQlQ3MDksXG4gIE1hbmhhdHRhbk5vbW15ZGU6ICgpID0+IE1hbmhhdHRhbk5vbW15ZGUsXG4gIFBOR1F1YW50OiAoKSA9PiBQTkdRdWFudFxufSk7XG5cbi8vIHNyYy9kaXN0YW5jZS9kaXN0YW5jZUNhbGN1bGF0b3IudHNcbnZhciBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tYXhEaXN0YW5jZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3doaXRlUG9pbnRcIik7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMoKTtcbiAgICB0aGlzLnNldFdoaXRlUG9pbnQoMjU1LCAyNTUsIDI1NSwgMjU1KTtcbiAgfVxuICBzZXRXaGl0ZVBvaW50KHIsIGcsIGIsIGEpIHtcbiAgICB0aGlzLl93aGl0ZVBvaW50ID0ge1xuICAgICAgcjogciA+IDAgPyAyNTUgLyByIDogMCxcbiAgICAgIGc6IGcgPiAwID8gMjU1IC8gZyA6IDAsXG4gICAgICBiOiBiID4gMCA/IDI1NSAvIGIgOiAwLFxuICAgICAgYTogYSA+IDAgPyAyNTUgLyBhIDogMFxuICAgIH07XG4gICAgdGhpcy5fbWF4RGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZVJhdyhyLCBnLCBiLCBhLCAwLCAwLCAwLCAwKTtcbiAgfVxuICBjYWxjdWxhdGVOb3JtYWxpemVkKGNvbG9yQSwgY29sb3JCKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlUmF3KGNvbG9yQS5yLCBjb2xvckEuZywgY29sb3JBLmIsIGNvbG9yQS5hLCBjb2xvckIuciwgY29sb3JCLmcsIGNvbG9yQi5iLCBjb2xvckIuYSkgLyB0aGlzLl9tYXhEaXN0YW5jZTtcbiAgfVxufTtcblxuLy8gc3JjL2Rpc3RhbmNlL2NpZTk0LnRzXG52YXIgQWJzdHJhY3RDSUU5NCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3Ige1xuICBjYWxjdWxhdGVSYXcocjEsIGcxLCBiMSwgYTEsIHIyLCBnMiwgYjIsIGEyKSB7XG4gICAgY29uc3QgbGFiMSA9IHJnYjJsYWIoaW5SYW5nZTB0bzI1NShyMSAqIHRoaXMuX3doaXRlUG9pbnQuciksIGluUmFuZ2UwdG8yNTUoZzEgKiB0aGlzLl93aGl0ZVBvaW50LmcpLCBpblJhbmdlMHRvMjU1KGIxICogdGhpcy5fd2hpdGVQb2ludC5iKSk7XG4gICAgY29uc3QgbGFiMiA9IHJnYjJsYWIoaW5SYW5nZTB0bzI1NShyMiAqIHRoaXMuX3doaXRlUG9pbnQuciksIGluUmFuZ2UwdG8yNTUoZzIgKiB0aGlzLl93aGl0ZVBvaW50LmcpLCBpblJhbmdlMHRvMjU1KGIyICogdGhpcy5fd2hpdGVQb2ludC5iKSk7XG4gICAgY29uc3QgZEwgPSBsYWIxLkwgLSBsYWIyLkw7XG4gICAgY29uc3QgZEEgPSBsYWIxLmEgLSBsYWIyLmE7XG4gICAgY29uc3QgZEIgPSBsYWIxLmIgLSBsYWIyLmI7XG4gICAgY29uc3QgYzEgPSBNYXRoLnNxcnQobGFiMS5hICogbGFiMS5hICsgbGFiMS5iICogbGFiMS5iKTtcbiAgICBjb25zdCBjMiA9IE1hdGguc3FydChsYWIyLmEgKiBsYWIyLmEgKyBsYWIyLmIgKiBsYWIyLmIpO1xuICAgIGNvbnN0IGRDID0gYzEgLSBjMjtcbiAgICBsZXQgZGVsdGFIID0gZEEgKiBkQSArIGRCICogZEIgLSBkQyAqIGRDO1xuICAgIGRlbHRhSCA9IGRlbHRhSCA8IDAgPyAwIDogTWF0aC5zcXJ0KGRlbHRhSCk7XG4gICAgY29uc3QgZEFscGhhID0gKGEyIC0gYTEpICogdGhpcy5fd2hpdGVQb2ludC5hICogdGhpcy5fa0E7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoZEwgLyB0aGlzLl9LbCkgKiogMiArIChkQyAvICgxICsgdGhpcy5fSzEgKiBjMSkpICoqIDIgKyAoZGVsdGFIIC8gKDEgKyB0aGlzLl9LMiAqIGMxKSkgKiogMiArIGRBbHBoYSAqKiAyKTtcbiAgfVxufTtcbnZhciBDSUU5NFRleHRpbGVzID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdENJRTk0IHtcbiAgX3NldERlZmF1bHRzKCkge1xuICAgIHRoaXMuX0tsID0gMjtcbiAgICB0aGlzLl9LMSA9IDAuMDQ4O1xuICAgIHRoaXMuX0syID0gMC4wMTQ7XG4gICAgdGhpcy5fa0EgPSAwLjI1ICogNTAgLyAyNTU7XG4gIH1cbn07XG52YXIgQ0lFOTRHcmFwaGljQXJ0cyA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RDSUU5NCB7XG4gIF9zZXREZWZhdWx0cygpIHtcbiAgICB0aGlzLl9LbCA9IDE7XG4gICAgdGhpcy5fSzEgPSAwLjA0NTtcbiAgICB0aGlzLl9LMiA9IDAuMDE1O1xuICAgIHRoaXMuX2tBID0gMC4yNSAqIDEwMCAvIDI1NTtcbiAgfVxufTtcblxuLy8gc3JjL2Rpc3RhbmNlL2NpZWRlMjAwMC50c1xudmFyIF9DSUVERTIwMDAgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcbiAgX3NldERlZmF1bHRzKCkge1xuICB9XG4gIHN0YXRpYyBfY2FsY3VsYXRlaHAoYiwgYXApIHtcbiAgICBjb25zdCBocCA9IE1hdGguYXRhbjIoYiwgYXApO1xuICAgIGlmIChocCA+PSAwKVxuICAgICAgcmV0dXJuIGhwO1xuICAgIHJldHVybiBocCArIF9DSUVERTIwMDAuX2RlZzM2MEluUmFkO1xuICB9XG4gIHN0YXRpYyBfY2FsY3VsYXRlUlQoYWhwLCBhQ3ApIHtcbiAgICBjb25zdCBhQ3BfdG9fNyA9IGFDcCAqKiA3O1xuICAgIGNvbnN0IFJfQyA9IDIgKiBNYXRoLnNxcnQoYUNwX3RvXzcgLyAoYUNwX3RvXzcgKyBfQ0lFREUyMDAwLl9wb3cyNXRvNykpO1xuICAgIGNvbnN0IGRlbHRhX3RoZXRhID0gX0NJRURFMjAwMC5fZGVnMzBJblJhZCAqIE1hdGguZXhwKC0oKChhaHAgLSBfQ0lFREUyMDAwLl9kZWcyNzVJblJhZCkgLyBfQ0lFREUyMDAwLl9kZWcyNUluUmFkKSAqKiAyKSk7XG4gICAgcmV0dXJuIC1NYXRoLnNpbigyICogZGVsdGFfdGhldGEpICogUl9DO1xuICB9XG4gIHN0YXRpYyBfY2FsY3VsYXRlVChhaHApIHtcbiAgICByZXR1cm4gMSAtIDAuMTcgKiBNYXRoLmNvcyhhaHAgLSBfQ0lFREUyMDAwLl9kZWczMEluUmFkKSArIDAuMjQgKiBNYXRoLmNvcyhhaHAgKiAyKSArIDAuMzIgKiBNYXRoLmNvcyhhaHAgKiAzICsgX0NJRURFMjAwMC5fZGVnNkluUmFkKSAtIDAuMiAqIE1hdGguY29zKGFocCAqIDQgLSBfQ0lFREUyMDAwLl9kZWc2M0luUmFkKTtcbiAgfVxuICBzdGF0aWMgX2NhbGN1bGF0ZV9haHAoQzFwQzJwLCBoX2JhciwgaDFwLCBoMnApIHtcbiAgICBjb25zdCBocFN1bSA9IGgxcCArIGgycDtcbiAgICBpZiAoQzFwQzJwID09PSAwKVxuICAgICAgcmV0dXJuIGhwU3VtO1xuICAgIGlmIChoX2JhciA8PSBfQ0lFREUyMDAwLl9kZWcxODBJblJhZClcbiAgICAgIHJldHVybiBocFN1bSAvIDI7XG4gICAgaWYgKGhwU3VtIDwgX0NJRURFMjAwMC5fZGVnMzYwSW5SYWQpIHtcbiAgICAgIHJldHVybiAoaHBTdW0gKyBfQ0lFREUyMDAwLl9kZWczNjBJblJhZCkgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gKGhwU3VtIC0gX0NJRURFMjAwMC5fZGVnMzYwSW5SYWQpIC8gMjtcbiAgfVxuICBzdGF0aWMgX2NhbGN1bGF0ZV9kSHAoQzFwQzJwLCBoX2JhciwgaDJwLCBoMXApIHtcbiAgICBsZXQgZGhwO1xuICAgIGlmIChDMXBDMnAgPT09IDApIHtcbiAgICAgIGRocCA9IDA7XG4gICAgfSBlbHNlIGlmIChoX2JhciA8PSBfQ0lFREUyMDAwLl9kZWcxODBJblJhZCkge1xuICAgICAgZGhwID0gaDJwIC0gaDFwO1xuICAgIH0gZWxzZSBpZiAoaDJwIDw9IGgxcCkge1xuICAgICAgZGhwID0gaDJwIC0gaDFwICsgX0NJRURFMjAwMC5fZGVnMzYwSW5SYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRocCA9IGgycCAtIGgxcCAtIF9DSUVERTIwMDAuX2RlZzM2MEluUmFkO1xuICAgIH1cbiAgICByZXR1cm4gMiAqIE1hdGguc3FydChDMXBDMnApICogTWF0aC5zaW4oZGhwIC8gMik7XG4gIH1cbiAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xuICAgIGNvbnN0IGxhYjEgPSByZ2IybGFiKGluUmFuZ2UwdG8yNTUocjEgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBpblJhbmdlMHRvMjU1KGcxICogdGhpcy5fd2hpdGVQb2ludC5nKSwgaW5SYW5nZTB0bzI1NShiMSAqIHRoaXMuX3doaXRlUG9pbnQuYikpO1xuICAgIGNvbnN0IGxhYjIgPSByZ2IybGFiKGluUmFuZ2UwdG8yNTUocjIgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBpblJhbmdlMHRvMjU1KGcyICogdGhpcy5fd2hpdGVQb2ludC5nKSwgaW5SYW5nZTB0bzI1NShiMiAqIHRoaXMuX3doaXRlUG9pbnQuYikpO1xuICAgIGNvbnN0IGRBID0gKGEyIC0gYTEpICogdGhpcy5fd2hpdGVQb2ludC5hICogX0NJRURFMjAwMC5fa0E7XG4gICAgY29uc3QgZEUyID0gdGhpcy5jYWxjdWxhdGVSYXdJbkxhYihsYWIxLCBsYWIyKTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGRFMiArIGRBICogZEEpO1xuICB9XG4gIGNhbGN1bGF0ZVJhd0luTGFiKExhYjEsIExhYjIpIHtcbiAgICBjb25zdCBMMSA9IExhYjEuTDtcbiAgICBjb25zdCBhMSA9IExhYjEuYTtcbiAgICBjb25zdCBiMSA9IExhYjEuYjtcbiAgICBjb25zdCBMMiA9IExhYjIuTDtcbiAgICBjb25zdCBhMiA9IExhYjIuYTtcbiAgICBjb25zdCBiMiA9IExhYjIuYjtcbiAgICBjb25zdCBDMSA9IE1hdGguc3FydChhMSAqIGExICsgYjEgKiBiMSk7XG4gICAgY29uc3QgQzIgPSBNYXRoLnNxcnQoYTIgKiBhMiArIGIyICogYjIpO1xuICAgIGNvbnN0IHBvd19hX0MxX0MyX3RvXzcgPSAoKEMxICsgQzIpIC8gMikgKiogNztcbiAgICBjb25zdCBHID0gMC41ICogKDEgLSBNYXRoLnNxcnQocG93X2FfQzFfQzJfdG9fNyAvIChwb3dfYV9DMV9DMl90b183ICsgX0NJRURFMjAwMC5fcG93MjV0bzcpKSk7XG4gICAgY29uc3QgYTFwID0gKDEgKyBHKSAqIGExO1xuICAgIGNvbnN0IGEycCA9ICgxICsgRykgKiBhMjtcbiAgICBjb25zdCBDMXAgPSBNYXRoLnNxcnQoYTFwICogYTFwICsgYjEgKiBiMSk7XG4gICAgY29uc3QgQzJwID0gTWF0aC5zcXJ0KGEycCAqIGEycCArIGIyICogYjIpO1xuICAgIGNvbnN0IEMxcEMycCA9IEMxcCAqIEMycDtcbiAgICBjb25zdCBoMXAgPSBfQ0lFREUyMDAwLl9jYWxjdWxhdGVocChiMSwgYTFwKTtcbiAgICBjb25zdCBoMnAgPSBfQ0lFREUyMDAwLl9jYWxjdWxhdGVocChiMiwgYTJwKTtcbiAgICBjb25zdCBoX2JhciA9IE1hdGguYWJzKGgxcCAtIGgycCk7XG4gICAgY29uc3QgZExwID0gTDIgLSBMMTtcbiAgICBjb25zdCBkQ3AgPSBDMnAgLSBDMXA7XG4gICAgY29uc3QgZEhwID0gX0NJRURFMjAwMC5fY2FsY3VsYXRlX2RIcChDMXBDMnAsIGhfYmFyLCBoMnAsIGgxcCk7XG4gICAgY29uc3QgYWhwID0gX0NJRURFMjAwMC5fY2FsY3VsYXRlX2FocChDMXBDMnAsIGhfYmFyLCBoMXAsIGgycCk7XG4gICAgY29uc3QgVCA9IF9DSUVERTIwMDAuX2NhbGN1bGF0ZVQoYWhwKTtcbiAgICBjb25zdCBhQ3AgPSAoQzFwICsgQzJwKSAvIDI7XG4gICAgY29uc3QgYUxwX21pbnVzXzUwX3NxdWFyZSA9ICgoTDEgKyBMMikgLyAyIC0gNTApICoqIDI7XG4gICAgY29uc3QgU19MID0gMSArIDAuMDE1ICogYUxwX21pbnVzXzUwX3NxdWFyZSAvIE1hdGguc3FydCgyMCArIGFMcF9taW51c181MF9zcXVhcmUpO1xuICAgIGNvbnN0IFNfQyA9IDEgKyAwLjA0NSAqIGFDcDtcbiAgICBjb25zdCBTX0ggPSAxICsgMC4wMTUgKiBUICogYUNwO1xuICAgIGNvbnN0IFJfVCA9IF9DSUVERTIwMDAuX2NhbGN1bGF0ZVJUKGFocCwgYUNwKTtcbiAgICBjb25zdCBkTHBTTCA9IGRMcCAvIFNfTDtcbiAgICBjb25zdCBkQ3BTQyA9IGRDcCAvIFNfQztcbiAgICBjb25zdCBkSHBTSCA9IGRIcCAvIFNfSDtcbiAgICByZXR1cm4gZExwU0wgKiogMiArIGRDcFNDICoqIDIgKyBkSHBTSCAqKiAyICsgUl9UICogZENwU0MgKiBkSHBTSDtcbiAgfVxufTtcbnZhciBDSUVERTIwMDAgPSBfQ0lFREUyMDAwO1xuX19wdWJsaWNGaWVsZChDSUVERTIwMDAsIFwiX2tBXCIsIDAuMjUgKiAxMDAgLyAyNTUpO1xuX19wdWJsaWNGaWVsZChDSUVERTIwMDAsIFwiX3BvdzI1dG83XCIsIDI1ICoqIDcpO1xuX19wdWJsaWNGaWVsZChDSUVERTIwMDAsIFwiX2RlZzM2MEluUmFkXCIsIGRlZ3JlZXMycmFkaWFucygzNjApKTtcbl9fcHVibGljRmllbGQoQ0lFREUyMDAwLCBcIl9kZWcxODBJblJhZFwiLCBkZWdyZWVzMnJhZGlhbnMoMTgwKSk7XG5fX3B1YmxpY0ZpZWxkKENJRURFMjAwMCwgXCJfZGVnMzBJblJhZFwiLCBkZWdyZWVzMnJhZGlhbnMoMzApKTtcbl9fcHVibGljRmllbGQoQ0lFREUyMDAwLCBcIl9kZWc2SW5SYWRcIiwgZGVncmVlczJyYWRpYW5zKDYpKTtcbl9fcHVibGljRmllbGQoQ0lFREUyMDAwLCBcIl9kZWc2M0luUmFkXCIsIGRlZ3JlZXMycmFkaWFucyg2MykpO1xuX19wdWJsaWNGaWVsZChDSUVERTIwMDAsIFwiX2RlZzI3NUluUmFkXCIsIGRlZ3JlZXMycmFkaWFucygyNzUpKTtcbl9fcHVibGljRmllbGQoQ0lFREUyMDAwLCBcIl9kZWcyNUluUmFkXCIsIGRlZ3JlZXMycmFkaWFucygyNSkpO1xuXG4vLyBzcmMvZGlzdGFuY2UvY21ldHJpYy50c1xudmFyIENNZXRyaWMgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcbiAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xuICAgIGNvbnN0IHJtZWFuID0gKHIxICsgcjIpIC8gMiAqIHRoaXMuX3doaXRlUG9pbnQucjtcbiAgICBjb25zdCByID0gKHIxIC0gcjIpICogdGhpcy5fd2hpdGVQb2ludC5yO1xuICAgIGNvbnN0IGcgPSAoZzEgLSBnMikgKiB0aGlzLl93aGl0ZVBvaW50Lmc7XG4gICAgY29uc3QgYiA9IChiMSAtIGIyKSAqIHRoaXMuX3doaXRlUG9pbnQuYjtcbiAgICBjb25zdCBkRSA9ICgoNTEyICsgcm1lYW4pICogciAqIHIgPj4gOCkgKyA0ICogZyAqIGcgKyAoKDc2NyAtIHJtZWFuKSAqIGIgKiBiID4+IDgpO1xuICAgIGNvbnN0IGRBID0gKGEyIC0gYTEpICogdGhpcy5fd2hpdGVQb2ludC5hO1xuICAgIHJldHVybiBNYXRoLnNxcnQoZEUgKyBkQSAqIGRBKTtcbiAgfVxuICBfc2V0RGVmYXVsdHMoKSB7XG4gIH1cbn07XG5cbi8vIHNyYy9kaXN0YW5jZS9ldWNsaWRlYW4udHNcbnZhciBBYnN0cmFjdEV1Y2xpZGVhbiA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3Ige1xuICBjYWxjdWxhdGVSYXcocjEsIGcxLCBiMSwgYTEsIHIyLCBnMiwgYjIsIGEyKSB7XG4gICAgY29uc3QgZFIgPSByMiAtIHIxO1xuICAgIGNvbnN0IGRHID0gZzIgLSBnMTtcbiAgICBjb25zdCBkQiA9IGIyIC0gYjE7XG4gICAgY29uc3QgZEEgPSBhMiAtIGExO1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5fa1IgKiBkUiAqIGRSICsgdGhpcy5fa0cgKiBkRyAqIGRHICsgdGhpcy5fa0IgKiBkQiAqIGRCICsgdGhpcy5fa0EgKiBkQSAqIGRBKTtcbiAgfVxufTtcbnZhciBFdWNsaWRlYW4gPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RXVjbGlkZWFuIHtcbiAgX3NldERlZmF1bHRzKCkge1xuICAgIHRoaXMuX2tSID0gMTtcbiAgICB0aGlzLl9rRyA9IDE7XG4gICAgdGhpcy5fa0IgPSAxO1xuICAgIHRoaXMuX2tBID0gMTtcbiAgfVxufTtcbnZhciBFdWNsaWRlYW5CVDcwOSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RFdWNsaWRlYW4ge1xuICBfc2V0RGVmYXVsdHMoKSB7XG4gICAgdGhpcy5fa1IgPSAwLjIxMjYgLyogUkVEICovO1xuICAgIHRoaXMuX2tHID0gMC43MTUyIC8qIEdSRUVOICovO1xuICAgIHRoaXMuX2tCID0gMC4wNzIyIC8qIEJMVUUgKi87XG4gICAgdGhpcy5fa0EgPSAxO1xuICB9XG59O1xudmFyIEV1Y2xpZGVhbkJUNzA5Tm9BbHBoYSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RFdWNsaWRlYW4ge1xuICBfc2V0RGVmYXVsdHMoKSB7XG4gICAgdGhpcy5fa1IgPSAwLjIxMjYgLyogUkVEICovO1xuICAgIHRoaXMuX2tHID0gMC43MTUyIC8qIEdSRUVOICovO1xuICAgIHRoaXMuX2tCID0gMC4wNzIyIC8qIEJMVUUgKi87XG4gICAgdGhpcy5fa0EgPSAwO1xuICB9XG59O1xuXG4vLyBzcmMvZGlzdGFuY2UvbWFuaGF0dGFuLnRzXG52YXIgQWJzdHJhY3RNYW5oYXR0YW4gPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcbiAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xuICAgIGxldCBkUiA9IHIyIC0gcjE7XG4gICAgbGV0IGRHID0gZzIgLSBnMTtcbiAgICBsZXQgZEIgPSBiMiAtIGIxO1xuICAgIGxldCBkQSA9IGEyIC0gYTE7XG4gICAgaWYgKGRSIDwgMClcbiAgICAgIGRSID0gMCAtIGRSO1xuICAgIGlmIChkRyA8IDApXG4gICAgICBkRyA9IDAgLSBkRztcbiAgICBpZiAoZEIgPCAwKVxuICAgICAgZEIgPSAwIC0gZEI7XG4gICAgaWYgKGRBIDwgMClcbiAgICAgIGRBID0gMCAtIGRBO1xuICAgIHJldHVybiB0aGlzLl9rUiAqIGRSICsgdGhpcy5fa0cgKiBkRyArIHRoaXMuX2tCICogZEIgKyB0aGlzLl9rQSAqIGRBO1xuICB9XG59O1xudmFyIE1hbmhhdHRhbiA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNYW5oYXR0YW4ge1xuICBfc2V0RGVmYXVsdHMoKSB7XG4gICAgdGhpcy5fa1IgPSAxO1xuICAgIHRoaXMuX2tHID0gMTtcbiAgICB0aGlzLl9rQiA9IDE7XG4gICAgdGhpcy5fa0EgPSAxO1xuICB9XG59O1xudmFyIE1hbmhhdHRhbk5vbW15ZGUgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWFuaGF0dGFuIHtcbiAgX3NldERlZmF1bHRzKCkge1xuICAgIHRoaXMuX2tSID0gMC40OTg0O1xuICAgIHRoaXMuX2tHID0gMC44NjI1O1xuICAgIHRoaXMuX2tCID0gMC4yOTc5O1xuICAgIHRoaXMuX2tBID0gMTtcbiAgfVxufTtcbnZhciBNYW5oYXR0YW5CVDcwOSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNYW5oYXR0YW4ge1xuICBfc2V0RGVmYXVsdHMoKSB7XG4gICAgdGhpcy5fa1IgPSAwLjIxMjYgLyogUkVEICovO1xuICAgIHRoaXMuX2tHID0gMC43MTUyIC8qIEdSRUVOICovO1xuICAgIHRoaXMuX2tCID0gMC4wNzIyIC8qIEJMVUUgKi87XG4gICAgdGhpcy5fa0EgPSAxO1xuICB9XG59O1xuXG4vLyBzcmMvZGlzdGFuY2UvcG5nUXVhbnQudHNcbnZhciBQTkdRdWFudCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3Ige1xuICBjYWxjdWxhdGVSYXcocjEsIGcxLCBiMSwgYTEsIHIyLCBnMiwgYjIsIGEyKSB7XG4gICAgY29uc3QgYWxwaGFzID0gKGEyIC0gYTEpICogdGhpcy5fd2hpdGVQb2ludC5hO1xuICAgIHJldHVybiB0aGlzLl9jb2xvcmRpZmZlcmVuY2VDaChyMSAqIHRoaXMuX3doaXRlUG9pbnQuciwgcjIgKiB0aGlzLl93aGl0ZVBvaW50LnIsIGFscGhhcykgKyB0aGlzLl9jb2xvcmRpZmZlcmVuY2VDaChnMSAqIHRoaXMuX3doaXRlUG9pbnQuZywgZzIgKiB0aGlzLl93aGl0ZVBvaW50LmcsIGFscGhhcykgKyB0aGlzLl9jb2xvcmRpZmZlcmVuY2VDaChiMSAqIHRoaXMuX3doaXRlUG9pbnQuYiwgYjIgKiB0aGlzLl93aGl0ZVBvaW50LmIsIGFscGhhcyk7XG4gIH1cbiAgX2NvbG9yZGlmZmVyZW5jZUNoKHgyLCB5MiwgYWxwaGFzKSB7XG4gICAgY29uc3QgYmxhY2sgPSB4MiAtIHkyO1xuICAgIGNvbnN0IHdoaXRlID0gYmxhY2sgKyBhbHBoYXM7XG4gICAgcmV0dXJuIGJsYWNrICogYmxhY2sgKyB3aGl0ZSAqIHdoaXRlO1xuICB9XG4gIF9zZXREZWZhdWx0cygpIHtcbiAgfVxufTtcblxuLy8gc3JjL3BhbGV0dGUvaW5kZXgudHNcbnZhciBwYWxldHRlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHBhbGV0dGVfZXhwb3J0cywge1xuICBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXI6ICgpID0+IEFic3RyYWN0UGFsZXR0ZVF1YW50aXplcixcbiAgQ29sb3JIaXN0b2dyYW06ICgpID0+IENvbG9ySGlzdG9ncmFtLFxuICBOZXVRdWFudDogKCkgPT4gTmV1UXVhbnQsXG4gIE5ldVF1YW50RmxvYXQ6ICgpID0+IE5ldVF1YW50RmxvYXQsXG4gIFJHQlF1YW50OiAoKSA9PiBSR0JRdWFudCxcbiAgV3VDb2xvckN1YmU6ICgpID0+IFd1Q29sb3JDdWJlLFxuICBXdVF1YW50OiAoKSA9PiBXdVF1YW50XG59KTtcblxuLy8gc3JjL3BhbGV0dGUvcGFsZXR0ZVF1YW50aXplci50c1xudmFyIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciA9IGNsYXNzIHtcbiAgcXVhbnRpemVTeW5jKCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5xdWFudGl6ZSgpKSB7XG4gICAgICBpZiAodmFsdWUucGFsZXR0ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucGFsZXR0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9wb2ludC50c1xudmFyIFBvaW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidWludDMyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZ2JhXCIpO1xuICAgIHRoaXMudWludDMyID0gLTEgPj4+IDA7XG4gICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gdGhpcy5hID0gMDtcbiAgICB0aGlzLnJnYmEgPSBuZXcgQXJyYXkoNCk7XG4gICAgdGhpcy5yZ2JhWzBdID0gMDtcbiAgICB0aGlzLnJnYmFbMV0gPSAwO1xuICAgIHRoaXMucmdiYVsyXSA9IDA7XG4gICAgdGhpcy5yZ2JhWzNdID0gMDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQnlRdWFkcnVwbGV0KHF1YWRydXBsZXQpIHtcbiAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCgpO1xuICAgIHBvaW50LnIgPSBxdWFkcnVwbGV0WzBdIHwgMDtcbiAgICBwb2ludC5nID0gcXVhZHJ1cGxldFsxXSB8IDA7XG4gICAgcG9pbnQuYiA9IHF1YWRydXBsZXRbMl0gfCAwO1xuICAgIHBvaW50LmEgPSBxdWFkcnVwbGV0WzNdIHwgMDtcbiAgICBwb2ludC5fbG9hZFVJTlQzMigpO1xuICAgIHBvaW50Ll9sb2FkUXVhZHJ1cGxldCgpO1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQnlSR0JBKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICBwb2ludC5yID0gcmVkIHwgMDtcbiAgICBwb2ludC5nID0gZ3JlZW4gfCAwO1xuICAgIHBvaW50LmIgPSBibHVlIHwgMDtcbiAgICBwb2ludC5hID0gYWxwaGEgfCAwO1xuICAgIHBvaW50Ll9sb2FkVUlOVDMyKCk7XG4gICAgcG9pbnQuX2xvYWRRdWFkcnVwbGV0KCk7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVCeVVpbnQzMih1aW50MzIpIHtcbiAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCgpO1xuICAgIHBvaW50LnVpbnQzMiA9IHVpbnQzMiA+Pj4gMDtcbiAgICBwb2ludC5fbG9hZFJHQkEoKTtcbiAgICBwb2ludC5fbG9hZFF1YWRydXBsZXQoKTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cbiAgZnJvbShwb2ludCkge1xuICAgIHRoaXMuciA9IHBvaW50LnI7XG4gICAgdGhpcy5nID0gcG9pbnQuZztcbiAgICB0aGlzLmIgPSBwb2ludC5iO1xuICAgIHRoaXMuYSA9IHBvaW50LmE7XG4gICAgdGhpcy51aW50MzIgPSBwb2ludC51aW50MzI7XG4gICAgdGhpcy5yZ2JhWzBdID0gcG9pbnQucjtcbiAgICB0aGlzLnJnYmFbMV0gPSBwb2ludC5nO1xuICAgIHRoaXMucmdiYVsyXSA9IHBvaW50LmI7XG4gICAgdGhpcy5yZ2JhWzNdID0gcG9pbnQuYTtcbiAgfVxuICBnZXRMdW1pbm9zaXR5KHVzZUFscGhhQ2hhbm5lbCkge1xuICAgIGxldCByID0gdGhpcy5yO1xuICAgIGxldCBnID0gdGhpcy5nO1xuICAgIGxldCBiID0gdGhpcy5iO1xuICAgIGlmICh1c2VBbHBoYUNoYW5uZWwpIHtcbiAgICAgIHIgPSBNYXRoLm1pbigyNTUsIDI1NSAtIHRoaXMuYSArIHRoaXMuYSAqIHIgLyAyNTUpO1xuICAgICAgZyA9IE1hdGgubWluKDI1NSwgMjU1IC0gdGhpcy5hICsgdGhpcy5hICogZyAvIDI1NSk7XG4gICAgICBiID0gTWF0aC5taW4oMjU1LCAyNTUgLSB0aGlzLmEgKyB0aGlzLmEgKiBiIC8gMjU1KTtcbiAgICB9XG4gICAgcmV0dXJuIHIgKiAwLjIxMjYgLyogUkVEICovICsgZyAqIDAuNzE1MiAvKiBHUkVFTiAqLyArIGIgKiAwLjA3MjIgLyogQkxVRSAqLztcbiAgfVxuICBfbG9hZFVJTlQzMigpIHtcbiAgICB0aGlzLnVpbnQzMiA9ICh0aGlzLmEgPDwgMjQgfCB0aGlzLmIgPDwgMTYgfCB0aGlzLmcgPDwgOCB8IHRoaXMucikgPj4+IDA7XG4gIH1cbiAgX2xvYWRSR0JBKCkge1xuICAgIHRoaXMuciA9IHRoaXMudWludDMyICYgMjU1O1xuICAgIHRoaXMuZyA9IHRoaXMudWludDMyID4+PiA4ICYgMjU1O1xuICAgIHRoaXMuYiA9IHRoaXMudWludDMyID4+PiAxNiAmIDI1NTtcbiAgICB0aGlzLmEgPSB0aGlzLnVpbnQzMiA+Pj4gMjQgJiAyNTU7XG4gIH1cbiAgX2xvYWRRdWFkcnVwbGV0KCkge1xuICAgIHRoaXMucmdiYVswXSA9IHRoaXMucjtcbiAgICB0aGlzLnJnYmFbMV0gPSB0aGlzLmc7XG4gICAgdGhpcy5yZ2JhWzJdID0gdGhpcy5iO1xuICAgIHRoaXMucmdiYVszXSA9IHRoaXMuYTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3BvaW50Q29udGFpbmVyLnRzXG52YXIgUG9pbnRDb250YWluZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcG9pbnRBcnJheVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3dpZHRoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaGVpZ2h0XCIpO1xuICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgIHRoaXMuX3BvaW50QXJyYXkgPSBbXTtcbiAgfVxuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB9XG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0UG9pbnRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRBcnJheTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBQb2ludENvbnRhaW5lcigpO1xuICAgIGNsb25lLl93aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgIGNsb25lLl9oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2xvbmUuX3BvaW50QXJyYXlbaV0gPSBQb2ludC5jcmVhdGVCeVVpbnQzMih0aGlzLl9wb2ludEFycmF5W2ldLnVpbnQzMiB8IDApO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgdG9VaW50MzJBcnJheSgpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7XG4gICAgY29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkobCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHVpbnQzMkFycmF5W2ldID0gdGhpcy5fcG9pbnRBcnJheVtpXS51aW50MzI7XG4gICAgfVxuICAgIHJldHVybiB1aW50MzJBcnJheTtcbiAgfVxuICB0b1VpbnQ4QXJyYXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMudG9VaW50MzJBcnJheSgpLmJ1ZmZlcik7XG4gIH1cbiAgc3RhdGljIGZyb21IVE1MSW1hZ2VFbGVtZW50KGltZykge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nLm5hdHVyYWxXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodDtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21IVE1MQ2FudmFzRWxlbWVudChjYW52YXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSFRNTENhbnZhc0VsZW1lbnQoY2FudmFzKSB7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGNvbnN0IGltZ0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tSW1hZ2VEYXRhKGltZ0RhdGEpO1xuICB9XG4gIHN0YXRpYyBmcm9tSW1hZ2VEYXRhKGltYWdlRGF0YSkge1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG4gICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21VaW50OEFycmF5KGltYWdlRGF0YS5kYXRhLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBzdGF0aWMgZnJvbVVpbnQ4QXJyYXkodWludDhBcnJheSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHVpbnQ4QXJyYXkpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjpcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KHVpbnQ4QXJyYXkpO1xuICAgIH1cbiAgICBjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSh1aW50OEFycmF5LmJ1ZmZlcik7XG4gICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21VaW50MzJBcnJheSh1aW50MzJBcnJheSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgc3RhdGljIGZyb21VaW50MzJBcnJheSh1aW50MzJBcnJheSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBQb2ludENvbnRhaW5lcigpO1xuICAgIGNvbnRhaW5lci5fd2lkdGggPSB3aWR0aDtcbiAgICBjb250YWluZXIuX2hlaWdodCA9IGhlaWdodDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHVpbnQzMkFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29udGFpbmVyLl9wb2ludEFycmF5W2ldID0gUG9pbnQuY3JlYXRlQnlVaW50MzIodWludDMyQXJyYXlbaV0gfCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheShidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGggLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgcmV0dXJuIFBvaW50Q29udGFpbmVyLmZyb21VaW50MzJBcnJheSh1aW50MzJBcnJheSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9wYWxldHRlLnRzXG52YXIgaHVlR3JvdXBzID0gMTA7XG5mdW5jdGlvbiBodWVHcm91cChodWUsIHNlZ21lbnRzTnVtYmVyKSB7XG4gIGNvbnN0IG1heEh1ZSA9IDM2MDtcbiAgY29uc3Qgc2VnID0gbWF4SHVlIC8gc2VnbWVudHNOdW1iZXI7XG4gIGNvbnN0IGhhbGYgPSBzZWcgLyAyO1xuICBmb3IgKGxldCBpID0gMSwgbWlkID0gc2VnIC0gaGFsZjsgaSA8IHNlZ21lbnRzTnVtYmVyOyBpKyssIG1pZCArPSBzZWcpIHtcbiAgICBpZiAoaHVlID49IG1pZCAmJiBodWUgPCBtaWQgKyBzZWcpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBQYWxldHRlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3BvaW50Q29udGFpbmVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcG9pbnRBcnJheVwiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9pMzJpZHhcIiwge30pO1xuICAgIHRoaXMuX3BvaW50Q29udGFpbmVyID0gbmV3IFBvaW50Q29udGFpbmVyKCk7XG4gICAgdGhpcy5fcG9pbnRDb250YWluZXIuc2V0SGVpZ2h0KDEpO1xuICAgIHRoaXMuX3BvaW50QXJyYXkgPSB0aGlzLl9wb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XG4gIH1cbiAgYWRkKGNvbG9yKSB7XG4gICAgdGhpcy5fcG9pbnRBcnJheS5wdXNoKGNvbG9yKTtcbiAgICB0aGlzLl9wb2ludENvbnRhaW5lci5zZXRXaWR0aCh0aGlzLl9wb2ludEFycmF5Lmxlbmd0aCk7XG4gIH1cbiAgaGFzKGNvbG9yKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChjb2xvci51aW50MzIgPT09IHRoaXMuX3BvaW50QXJyYXlbaV0udWludDMyKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldE5lYXJlc3RDb2xvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3IpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRBcnJheVt0aGlzLl9nZXROZWFyZXN0SW5kZXgoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9yKSB8IDBdO1xuICB9XG4gIGdldFBvaW50Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludENvbnRhaW5lcjtcbiAgfVxuICBfbmVhcmVzdFBvaW50RnJvbUNhY2hlKGtleSkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5faTMyaWR4W2tleV0gPT09IFwibnVtYmVyXCIgPyB0aGlzLl9pMzJpZHhba2V5XSA6IC0xO1xuICB9XG4gIF9nZXROZWFyZXN0SW5kZXgoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIHBvaW50KSB7XG4gICAgbGV0IGlkeCA9IHRoaXMuX25lYXJlc3RQb2ludEZyb21DYWNoZShcIlwiICsgcG9pbnQudWludDMyKTtcbiAgICBpZiAoaWR4ID49IDApXG4gICAgICByZXR1cm4gaWR4O1xuICAgIGxldCBtaW5pbWFsRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGlkeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgcCA9IHRoaXMuX3BvaW50QXJyYXlbaV07XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLmNhbGN1bGF0ZVJhdyhwb2ludC5yLCBwb2ludC5nLCBwb2ludC5iLCBwb2ludC5hLCBwLnIsIHAuZywgcC5iLCBwLmEpO1xuICAgICAgaWYgKGRpc3RhbmNlIDwgbWluaW1hbERpc3RhbmNlKSB7XG4gICAgICAgIG1pbmltYWxEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICBpZHggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pMzJpZHhbcG9pbnQudWludDMyXSA9IGlkeDtcbiAgICByZXR1cm4gaWR4O1xuICB9XG4gIHNvcnQoKSB7XG4gICAgdGhpcy5faTMyaWR4ID0ge307XG4gICAgdGhpcy5fcG9pbnRBcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBoc2xBID0gcmdiMmhzbChhLnIsIGEuZywgYS5iKTtcbiAgICAgIGNvbnN0IGhzbEIgPSByZ2IyaHNsKGIuciwgYi5nLCBiLmIpO1xuICAgICAgY29uc3QgaHVlQSA9IGEuciA9PT0gYS5nICYmIGEuZyA9PT0gYS5iID8gMCA6IDEgKyBodWVHcm91cChoc2xBLmgsIGh1ZUdyb3Vwcyk7XG4gICAgICBjb25zdCBodWVCID0gYi5yID09PSBiLmcgJiYgYi5nID09PSBiLmIgPyAwIDogMSArIGh1ZUdyb3VwKGhzbEIuaCwgaHVlR3JvdXBzKTtcbiAgICAgIGNvbnN0IGh1ZURpZmYgPSBodWVCIC0gaHVlQTtcbiAgICAgIGlmIChodWVEaWZmKVxuICAgICAgICByZXR1cm4gLWh1ZURpZmY7XG4gICAgICBjb25zdCBsQSA9IGEuZ2V0THVtaW5vc2l0eSh0cnVlKTtcbiAgICAgIGNvbnN0IGxCID0gYi5nZXRMdW1pbm9zaXR5KHRydWUpO1xuICAgICAgaWYgKGxCIC0gbEEgIT09IDApXG4gICAgICAgIHJldHVybiBsQiAtIGxBO1xuICAgICAgY29uc3Qgc2F0RGlmZiA9IChoc2xCLnMgKiAxMDAgfCAwKSAtIChoc2xBLnMgKiAxMDAgfCAwKTtcbiAgICAgIGlmIChzYXREaWZmKVxuICAgICAgICByZXR1cm4gLXNhdERpZmY7XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2luZGV4LnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBIdWVTdGF0aXN0aWNzOiAoKSA9PiBIdWVTdGF0aXN0aWNzLFxuICBQYWxldHRlOiAoKSA9PiBQYWxldHRlLFxuICBQb2ludDogKCkgPT4gUG9pbnQsXG4gIFBvaW50Q29udGFpbmVyOiAoKSA9PiBQb2ludENvbnRhaW5lcixcbiAgUHJvZ3Jlc3NUcmFja2VyOiAoKSA9PiBQcm9ncmVzc1RyYWNrZXIsXG4gIGFyaXRobWV0aWM6ICgpID0+IGFyaXRobWV0aWNfZXhwb3J0c1xufSk7XG5cbi8vIHNyYy91dGlscy9odWVTdGF0aXN0aWNzLnRzXG52YXIgSHVlR3JvdXAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJudW1cIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbHNcIiwgW10pO1xuICB9XG59O1xudmFyIEh1ZVN0YXRpc3RpY3MgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG51bUdyb3VwcywgbWluQ29scykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbnVtR3JvdXBzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbWluQ29sc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3N0YXRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZ3JvdXBzRnVsbFwiKTtcbiAgICB0aGlzLl9udW1Hcm91cHMgPSBudW1Hcm91cHM7XG4gICAgdGhpcy5fbWluQ29scyA9IG1pbkNvbHM7XG4gICAgdGhpcy5fc3RhdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1Hcm91cHM7IGkrKykge1xuICAgICAgdGhpcy5fc3RhdHNbaV0gPSBuZXcgSHVlR3JvdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZ3JvdXBzRnVsbCA9IDA7XG4gIH1cbiAgY2hlY2soaTMyKSB7XG4gICAgaWYgKHRoaXMuX2dyb3Vwc0Z1bGwgPT09IHRoaXMuX251bUdyb3VwcyArIDEpIHtcbiAgICAgIHRoaXMuY2hlY2sgPSAoKSA9PiB7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByID0gaTMyICYgMjU1O1xuICAgIGNvbnN0IGcgPSBpMzIgPj4+IDggJiAyNTU7XG4gICAgY29uc3QgYiA9IGkzMiA+Pj4gMTYgJiAyNTU7XG4gICAgY29uc3QgaGcgPSByID09PSBnICYmIGcgPT09IGIgPyAwIDogMSArIGh1ZUdyb3VwKHJnYjJoc2wociwgZywgYikuaCwgdGhpcy5fbnVtR3JvdXBzKTtcbiAgICBjb25zdCBnciA9IHRoaXMuX3N0YXRzW2hnXTtcbiAgICBjb25zdCBtaW4gPSB0aGlzLl9taW5Db2xzO1xuICAgIGdyLm51bSsrO1xuICAgIGlmIChnci5udW0gPiBtaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGdyLm51bSA9PT0gbWluKSB7XG4gICAgICB0aGlzLl9ncm91cHNGdWxsKys7XG4gICAgfVxuICAgIGlmIChnci5udW0gPD0gbWluKSB7XG4gICAgICB0aGlzLl9zdGF0c1toZ10uY29scy5wdXNoKGkzMik7XG4gICAgfVxuICB9XG4gIGluamVjdEludG9EaWN0aW9uYXJ5KGhpc3RHKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5fbnVtR3JvdXBzOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0c1tpXS5udW0gPD0gdGhpcy5fbWluQ29scykge1xuICAgICAgICB0aGlzLl9zdGF0c1tpXS5jb2xzLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgIGlmICghaGlzdEdbY29sXSkge1xuICAgICAgICAgICAgaGlzdEdbY29sXSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpc3RHW2NvbF0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbmplY3RJbnRvQXJyYXkoaGlzdEcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLl9udW1Hcm91cHM7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX3N0YXRzW2ldLm51bSA8PSB0aGlzLl9taW5Db2xzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzW2ldLmNvbHMuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICAgICAgaWYgKGhpc3RHLmluZGV4T2YoY29sKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGhpc3RHLnB1c2goY29sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3Byb2dyZXNzVHJhY2tlci50c1xudmFyIF9Qcm9ncmVzc1RyYWNrZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlUmFuZ2UsIHByb2dyZXNzUmFuZ2UpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvZ3Jlc3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9zdGVwXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcmFuZ2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sYXN0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcHJvZ3Jlc3NSYW5nZVwiKTtcbiAgICB0aGlzLl9yYW5nZSA9IHZhbHVlUmFuZ2U7XG4gICAgdGhpcy5fcHJvZ3Jlc3NSYW5nZSA9IHByb2dyZXNzUmFuZ2U7XG4gICAgdGhpcy5fc3RlcCA9IE1hdGgubWF4KDEsIHRoaXMuX3JhbmdlIC8gKF9Qcm9ncmVzc1RyYWNrZXIuc3RlcHMgKyAxKSB8IDApO1xuICAgIHRoaXMuX2xhc3QgPSAtdGhpcy5fc3RlcDtcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgfVxuICBzaG91bGROb3RpZnkoY3VycmVudCkge1xuICAgIGlmIChjdXJyZW50IC0gdGhpcy5fbGFzdCA+PSB0aGlzLl9zdGVwKSB7XG4gICAgICB0aGlzLl9sYXN0ID0gY3VycmVudDtcbiAgICAgIHRoaXMucHJvZ3Jlc3MgPSBNYXRoLm1pbih0aGlzLl9wcm9ncmVzc1JhbmdlICogdGhpcy5fbGFzdCAvIHRoaXMuX3JhbmdlLCB0aGlzLl9wcm9ncmVzc1JhbmdlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgUHJvZ3Jlc3NUcmFja2VyID0gX1Byb2dyZXNzVHJhY2tlcjtcbl9fcHVibGljRmllbGQoUHJvZ3Jlc3NUcmFja2VyLCBcInN0ZXBzXCIsIDEwMCk7XG5cbi8vIHNyYy9wYWxldHRlL25ldXF1YW50L25ldXF1YW50LnRzXG52YXIgbmV0d29ya0JpYXNTaGlmdCA9IDM7XG52YXIgTmV1cm9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0VmFsdWUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYVwiKTtcbiAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSB0aGlzLmEgPSBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgdG9Qb2ludCgpIHtcbiAgICByZXR1cm4gUG9pbnQuY3JlYXRlQnlSR0JBKHRoaXMuciA+PiBuZXR3b3JrQmlhc1NoaWZ0LCB0aGlzLmcgPj4gbmV0d29ya0JpYXNTaGlmdCwgdGhpcy5iID4+IG5ldHdvcmtCaWFzU2hpZnQsIHRoaXMuYSA+PiBuZXR3b3JrQmlhc1NoaWZ0KTtcbiAgfVxuICBzdWJ0cmFjdChyLCBnLCBiLCBhKSB7XG4gICAgdGhpcy5yIC09IHIgfCAwO1xuICAgIHRoaXMuZyAtPSBnIHwgMDtcbiAgICB0aGlzLmIgLT0gYiB8IDA7XG4gICAgdGhpcy5hIC09IGEgfCAwO1xuICB9XG59O1xudmFyIF9OZXVRdWFudCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIHtcbiAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyA9IDI1Nikge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9wb2ludEFycmF5XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbmV0d29ya1NpemVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9uZXR3b3JrXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2FtcGxlRmFjdG9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcmFkUG93ZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9mcmVxXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYmlhc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2Rpc3RhbmNlXCIpO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XG4gICAgdGhpcy5fcG9pbnRBcnJheSA9IFtdO1xuICAgIHRoaXMuX3NhbXBsZUZhY3RvciA9IDE7XG4gICAgdGhpcy5fbmV0d29ya1NpemUgPSBjb2xvcnM7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc2V0V2hpdGVQb2ludCgyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0LCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCk7XG4gIH1cbiAgc2FtcGxlKHBvaW50Q29udGFpbmVyKSB7XG4gICAgdGhpcy5fcG9pbnRBcnJheSA9IHRoaXMuX3BvaW50QXJyYXkuY29uY2F0KHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKSk7XG4gIH1cbiAgKnF1YW50aXplKCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgICB5aWVsZCogdGhpcy5fbGVhcm4oKTtcbiAgICB5aWVsZCB7XG4gICAgICBwYWxldHRlOiB0aGlzLl9idWlsZFBhbGV0dGUoKSxcbiAgICAgIHByb2dyZXNzOiAxMDBcbiAgICB9O1xuICB9XG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2ZyZXEgPSBbXTtcbiAgICB0aGlzLl9iaWFzID0gW107XG4gICAgdGhpcy5fcmFkUG93ZXIgPSBbXTtcbiAgICB0aGlzLl9uZXR3b3JrID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9uZXR3b3JrU2l6ZTsgaSsrKSB7XG4gICAgICB0aGlzLl9uZXR3b3JrW2ldID0gbmV3IE5ldXJvbigoaSA8PCBuZXR3b3JrQmlhc1NoaWZ0ICsgOCkgLyB0aGlzLl9uZXR3b3JrU2l6ZSB8IDApO1xuICAgICAgdGhpcy5fZnJlcVtpXSA9IF9OZXVRdWFudC5faW5pdGlhbEJpYXMgLyB0aGlzLl9uZXR3b3JrU2l6ZSB8IDA7XG4gICAgICB0aGlzLl9iaWFzW2ldID0gMDtcbiAgICB9XG4gIH1cbiAgKl9sZWFybigpIHtcbiAgICBsZXQgc2FtcGxlRmFjdG9yID0gdGhpcy5fc2FtcGxlRmFjdG9yO1xuICAgIGNvbnN0IHBvaW50c051bWJlciA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xuICAgIGlmIChwb2ludHNOdW1iZXIgPCBfTmV1UXVhbnQuX21pbnBpY3R1cmVieXRlcylcbiAgICAgIHNhbXBsZUZhY3RvciA9IDE7XG4gICAgY29uc3QgYWxwaGFkZWMgPSAzMCArIChzYW1wbGVGYWN0b3IgLSAxKSAvIDMgfCAwO1xuICAgIGNvbnN0IHBvaW50c1RvU2FtcGxlID0gcG9pbnRzTnVtYmVyIC8gc2FtcGxlRmFjdG9yIHwgMDtcbiAgICBsZXQgZGVsdGEgPSBwb2ludHNUb1NhbXBsZSAvIF9OZXVRdWFudC5fbkN5Y2xlcyB8IDA7XG4gICAgbGV0IGFscGhhID0gX05ldVF1YW50Ll9pbml0QWxwaGE7XG4gICAgbGV0IHJhZGl1cyA9ICh0aGlzLl9uZXR3b3JrU2l6ZSA+PiAzKSAqIF9OZXVRdWFudC5fcmFkaXVzQmlhcztcbiAgICBsZXQgcmFkID0gcmFkaXVzID4+IF9OZXVRdWFudC5fcmFkaXVzQmlhc1NoaWZ0O1xuICAgIGlmIChyYWQgPD0gMSlcbiAgICAgIHJhZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYWQ7IGkrKykge1xuICAgICAgdGhpcy5fcmFkUG93ZXJbaV0gPSBhbHBoYSAqICgocmFkICogcmFkIC0gaSAqIGkpICogX05ldVF1YW50Ll9yYWRCaWFzIC8gKHJhZCAqIHJhZCkpID4+PiAwO1xuICAgIH1cbiAgICBsZXQgc3RlcDtcbiAgICBpZiAocG9pbnRzTnVtYmVyIDwgX05ldVF1YW50Ll9taW5waWN0dXJlYnl0ZXMpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzTnVtYmVyICUgX05ldVF1YW50Ll9wcmltZTEgIT09IDApIHtcbiAgICAgIHN0ZXAgPSBfTmV1UXVhbnQuX3ByaW1lMTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c051bWJlciAlIF9OZXVRdWFudC5fcHJpbWUyICE9PSAwKSB7XG4gICAgICBzdGVwID0gX05ldVF1YW50Ll9wcmltZTI7XG4gICAgfSBlbHNlIGlmIChwb2ludHNOdW1iZXIgJSBfTmV1UXVhbnQuX3ByaW1lMyAhPT0gMCkge1xuICAgICAgc3RlcCA9IF9OZXVRdWFudC5fcHJpbWUzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwID0gX05ldVF1YW50Ll9wcmltZTQ7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKHBvaW50c1RvU2FtcGxlLCA5OSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBvaW50SW5kZXggPSAwOyBpIDwgcG9pbnRzVG9TYW1wbGU7ICkge1xuICAgICAgaWYgKHRyYWNrZXIuc2hvdWxkTm90aWZ5KGkpKSB7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9wb2ludEFycmF5W3BvaW50SW5kZXhdO1xuICAgICAgY29uc3QgYiA9IHBvaW50LmIgPDwgbmV0d29ya0JpYXNTaGlmdDtcbiAgICAgIGNvbnN0IGcgPSBwb2ludC5nIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XG4gICAgICBjb25zdCByID0gcG9pbnQuciA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xuICAgICAgY29uc3QgYSA9IHBvaW50LmEgPDwgbmV0d29ya0JpYXNTaGlmdDtcbiAgICAgIGNvbnN0IG5ldXJvbkluZGV4ID0gdGhpcy5fY29udGVzdChiLCBnLCByLCBhKTtcbiAgICAgIHRoaXMuX2FsdGVyU2luZ2xlKGFscGhhLCBuZXVyb25JbmRleCwgYiwgZywgciwgYSk7XG4gICAgICBpZiAocmFkICE9PSAwKVxuICAgICAgICB0aGlzLl9hbHRlck5laWdoYm91cihyYWQsIG5ldXJvbkluZGV4LCBiLCBnLCByLCBhKTtcbiAgICAgIHBvaW50SW5kZXggKz0gc3RlcDtcbiAgICAgIGlmIChwb2ludEluZGV4ID49IHBvaW50c051bWJlcilcbiAgICAgICAgcG9pbnRJbmRleCAtPSBwb2ludHNOdW1iZXI7XG4gICAgICBpKys7XG4gICAgICBpZiAoZGVsdGEgPT09IDApXG4gICAgICAgIGRlbHRhID0gMTtcbiAgICAgIGlmIChpICUgZGVsdGEgPT09IDApIHtcbiAgICAgICAgYWxwaGEgLT0gYWxwaGEgLyBhbHBoYWRlYyB8IDA7XG4gICAgICAgIHJhZGl1cyAtPSByYWRpdXMgLyBfTmV1UXVhbnQuX3JhZGl1c0RlY3JlYXNlIHwgMDtcbiAgICAgICAgcmFkID0gcmFkaXVzID4+IF9OZXVRdWFudC5fcmFkaXVzQmlhc1NoaWZ0O1xuICAgICAgICBpZiAocmFkIDw9IDEpXG4gICAgICAgICAgcmFkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYWQ7IGorKykge1xuICAgICAgICAgIHRoaXMuX3JhZFBvd2VyW2pdID0gYWxwaGEgKiAoKHJhZCAqIHJhZCAtIGogKiBqKSAqIF9OZXVRdWFudC5fcmFkQmlhcyAvIChyYWQgKiByYWQpKSA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfYnVpbGRQYWxldHRlKCkge1xuICAgIGNvbnN0IHBhbGV0dGUgPSBuZXcgUGFsZXR0ZSgpO1xuICAgIHRoaXMuX25ldHdvcmsuZm9yRWFjaCgobmV1cm9uKSA9PiB7XG4gICAgICBwYWxldHRlLmFkZChuZXVyb24udG9Qb2ludCgpKTtcbiAgICB9KTtcbiAgICBwYWxldHRlLnNvcnQoKTtcbiAgICByZXR1cm4gcGFsZXR0ZTtcbiAgfVxuICBfYWx0ZXJOZWlnaGJvdXIocmFkLCBpLCBiLCBnLCByLCBhbCkge1xuICAgIGxldCBsbyA9IGkgLSByYWQ7XG4gICAgaWYgKGxvIDwgLTEpXG4gICAgICBsbyA9IC0xO1xuICAgIGxldCBoaSA9IGkgKyByYWQ7XG4gICAgaWYgKGhpID4gdGhpcy5fbmV0d29ya1NpemUpXG4gICAgICBoaSA9IHRoaXMuX25ldHdvcmtTaXplO1xuICAgIGxldCBqID0gaSArIDE7XG4gICAgbGV0IGsgPSBpIC0gMTtcbiAgICBsZXQgbSA9IDE7XG4gICAgd2hpbGUgKGogPCBoaSB8fCBrID4gbG8pIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl9yYWRQb3dlclttKytdIC8gX05ldVF1YW50Ll9hbHBoYVJhZEJpYXM7XG4gICAgICBpZiAoaiA8IGhpKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLl9uZXR3b3JrW2orK107XG4gICAgICAgIHAuc3VidHJhY3QoYSAqIChwLnIgLSByKSwgYSAqIChwLmcgLSBnKSwgYSAqIChwLmIgLSBiKSwgYSAqIChwLmEgLSBhbCkpO1xuICAgICAgfVxuICAgICAgaWYgKGsgPiBsbykge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5fbmV0d29ya1trLS1dO1xuICAgICAgICBwLnN1YnRyYWN0KGEgKiAocC5yIC0gciksIGEgKiAocC5nIC0gZyksIGEgKiAocC5iIC0gYiksIGEgKiAocC5hIC0gYWwpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2FsdGVyU2luZ2xlKGFscGhhLCBpLCBiLCBnLCByLCBhKSB7XG4gICAgYWxwaGEgLz0gX05ldVF1YW50Ll9pbml0QWxwaGE7XG4gICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XG4gICAgbi5zdWJ0cmFjdChhbHBoYSAqIChuLnIgLSByKSwgYWxwaGEgKiAobi5nIC0gZyksIGFscGhhICogKG4uYiAtIGIpLCBhbHBoYSAqIChuLmEgLSBhKSk7XG4gIH1cbiAgX2NvbnRlc3QoYiwgZywgciwgYSkge1xuICAgIGNvbnN0IG11bHRpcGxpZXIgPSAyNTUgKiA0IDw8IG5ldHdvcmtCaWFzU2hpZnQ7XG4gICAgbGV0IGJlc3RkID0gfigxIDw8IDMxKTtcbiAgICBsZXQgYmVzdGJpYXNkID0gYmVzdGQ7XG4gICAgbGV0IGJlc3Rwb3MgPSAtMTtcbiAgICBsZXQgYmVzdGJpYXNwb3MgPSBiZXN0cG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xuICAgICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XG4gICAgICBjb25zdCBkaXN0ID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlTm9ybWFsaXplZChuLCB7IHIsIGcsIGIsIGEgfSkgKiBtdWx0aXBsaWVyIHwgMDtcbiAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcbiAgICAgICAgYmVzdGQgPSBkaXN0O1xuICAgICAgICBiZXN0cG9zID0gaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpYXNkaXN0ID0gZGlzdCAtICh0aGlzLl9iaWFzW2ldID4+IF9OZXVRdWFudC5faW5pdGlhbEJpYXNTaGlmdCAtIG5ldHdvcmtCaWFzU2hpZnQpO1xuICAgICAgaWYgKGJpYXNkaXN0IDwgYmVzdGJpYXNkKSB7XG4gICAgICAgIGJlc3RiaWFzZCA9IGJpYXNkaXN0O1xuICAgICAgICBiZXN0Ymlhc3BvcyA9IGk7XG4gICAgICB9XG4gICAgICBjb25zdCBiZXRhZnJlcSA9IHRoaXMuX2ZyZXFbaV0gPj4gX05ldVF1YW50Ll9iZXRhU2hpZnQ7XG4gICAgICB0aGlzLl9mcmVxW2ldIC09IGJldGFmcmVxO1xuICAgICAgdGhpcy5fYmlhc1tpXSArPSBiZXRhZnJlcSA8PCBfTmV1UXVhbnQuX2dhbW1hU2hpZnQ7XG4gICAgfVxuICAgIHRoaXMuX2ZyZXFbYmVzdHBvc10gKz0gX05ldVF1YW50Ll9iZXRhO1xuICAgIHRoaXMuX2JpYXNbYmVzdHBvc10gLT0gX05ldVF1YW50Ll9iZXRhR2FtbWE7XG4gICAgcmV0dXJuIGJlc3RiaWFzcG9zO1xuICB9XG59O1xudmFyIE5ldVF1YW50ID0gX05ldVF1YW50O1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfcHJpbWUxXCIsIDQ5OSk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9wcmltZTJcIiwgNDkxKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX3ByaW1lM1wiLCA0ODcpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfcHJpbWU0XCIsIDUwMyk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9taW5waWN0dXJlYnl0ZXNcIiwgX05ldVF1YW50Ll9wcmltZTQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfbkN5Y2xlc1wiLCAxMDApO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfaW5pdGlhbEJpYXNTaGlmdFwiLCAxNik7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9pbml0aWFsQmlhc1wiLCAxIDw8IF9OZXVRdWFudC5faW5pdGlhbEJpYXNTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9nYW1tYVNoaWZ0XCIsIDEwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX2JldGFTaGlmdFwiLCAxMCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9iZXRhXCIsIF9OZXVRdWFudC5faW5pdGlhbEJpYXMgPj4gX05ldVF1YW50Ll9iZXRhU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfYmV0YUdhbW1hXCIsIF9OZXVRdWFudC5faW5pdGlhbEJpYXMgPDwgX05ldVF1YW50Ll9nYW1tYVNoaWZ0IC0gX05ldVF1YW50Ll9iZXRhU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfcmFkaXVzQmlhc1NoaWZ0XCIsIDYpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfcmFkaXVzQmlhc1wiLCAxIDw8IF9OZXVRdWFudC5fcmFkaXVzQmlhc1NoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX3JhZGl1c0RlY3JlYXNlXCIsIDMwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX2FscGhhQmlhc1NoaWZ0XCIsIDEwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX2luaXRBbHBoYVwiLCAxIDw8IF9OZXVRdWFudC5fYWxwaGFCaWFzU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfcmFkQmlhc1NoaWZ0XCIsIDgpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfcmFkQmlhc1wiLCAxIDw8IF9OZXVRdWFudC5fcmFkQmlhc1NoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX2FscGhhUmFkQmlhc1NoaWZ0XCIsIF9OZXVRdWFudC5fYWxwaGFCaWFzU2hpZnQgKyBfTmV1UXVhbnQuX3JhZEJpYXNTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9hbHBoYVJhZEJpYXNcIiwgMSA8PCBfTmV1UXVhbnQuX2FscGhhUmFkQmlhc1NoaWZ0KTtcblxuLy8gc3JjL3BhbGV0dGUvbmV1cXVhbnQvbmV1cXVhbnRGbG9hdC50c1xudmFyIG5ldHdvcmtCaWFzU2hpZnQyID0gMztcbnZhciBOZXVyb25GbG9hdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFcIik7XG4gICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gdGhpcy5hID0gZGVmYXVsdFZhbHVlO1xuICB9XG4gIHRvUG9pbnQoKSB7XG4gICAgcmV0dXJuIFBvaW50LmNyZWF0ZUJ5UkdCQSh0aGlzLnIgPj4gbmV0d29ya0JpYXNTaGlmdDIsIHRoaXMuZyA+PiBuZXR3b3JrQmlhc1NoaWZ0MiwgdGhpcy5iID4+IG5ldHdvcmtCaWFzU2hpZnQyLCB0aGlzLmEgPj4gbmV0d29ya0JpYXNTaGlmdDIpO1xuICB9XG4gIHN1YnRyYWN0KHIsIGcsIGIsIGEpIHtcbiAgICB0aGlzLnIgLT0gcjtcbiAgICB0aGlzLmcgLT0gZztcbiAgICB0aGlzLmIgLT0gYjtcbiAgICB0aGlzLmEgLT0gYTtcbiAgfVxufTtcbnZhciBfTmV1UXVhbnRGbG9hdCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIHtcbiAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyA9IDI1Nikge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9wb2ludEFycmF5XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbmV0d29ya1NpemVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9uZXR3b3JrXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2FtcGxlRmFjdG9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcmFkUG93ZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9mcmVxXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYmlhc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2Rpc3RhbmNlXCIpO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XG4gICAgdGhpcy5fcG9pbnRBcnJheSA9IFtdO1xuICAgIHRoaXMuX3NhbXBsZUZhY3RvciA9IDE7XG4gICAgdGhpcy5fbmV0d29ya1NpemUgPSBjb2xvcnM7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc2V0V2hpdGVQb2ludCgyNTUgPDwgbmV0d29ya0JpYXNTaGlmdDIsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0MiwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQyLCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdDIpO1xuICB9XG4gIHNhbXBsZShwb2ludENvbnRhaW5lcikge1xuICAgIHRoaXMuX3BvaW50QXJyYXkgPSB0aGlzLl9wb2ludEFycmF5LmNvbmNhdChwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCkpO1xuICB9XG4gICpxdWFudGl6ZSgpIHtcbiAgICB0aGlzLl9pbml0KCk7XG4gICAgeWllbGQqIHRoaXMuX2xlYXJuKCk7XG4gICAgeWllbGQge1xuICAgICAgcGFsZXR0ZTogdGhpcy5fYnVpbGRQYWxldHRlKCksXG4gICAgICBwcm9ncmVzczogMTAwXG4gICAgfTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9mcmVxID0gW107XG4gICAgdGhpcy5fYmlhcyA9IFtdO1xuICAgIHRoaXMuX3JhZFBvd2VyID0gW107XG4gICAgdGhpcy5fbmV0d29yayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xuICAgICAgdGhpcy5fbmV0d29ya1tpXSA9IG5ldyBOZXVyb25GbG9hdCgoaSA8PCBuZXR3b3JrQmlhc1NoaWZ0MiArIDgpIC8gdGhpcy5fbmV0d29ya1NpemUpO1xuICAgICAgdGhpcy5fZnJlcVtpXSA9IF9OZXVRdWFudEZsb2F0Ll9pbml0aWFsQmlhcyAvIHRoaXMuX25ldHdvcmtTaXplO1xuICAgICAgdGhpcy5fYmlhc1tpXSA9IDA7XG4gICAgfVxuICB9XG4gICpfbGVhcm4oKSB7XG4gICAgbGV0IHNhbXBsZUZhY3RvciA9IHRoaXMuX3NhbXBsZUZhY3RvcjtcbiAgICBjb25zdCBwb2ludHNOdW1iZXIgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aDtcbiAgICBpZiAocG9pbnRzTnVtYmVyIDwgX05ldVF1YW50RmxvYXQuX21pbnBpY3R1cmVieXRlcylcbiAgICAgIHNhbXBsZUZhY3RvciA9IDE7XG4gICAgY29uc3QgYWxwaGFkZWMgPSAzMCArIChzYW1wbGVGYWN0b3IgLSAxKSAvIDM7XG4gICAgY29uc3QgcG9pbnRzVG9TYW1wbGUgPSBwb2ludHNOdW1iZXIgLyBzYW1wbGVGYWN0b3I7XG4gICAgbGV0IGRlbHRhID0gcG9pbnRzVG9TYW1wbGUgLyBfTmV1UXVhbnRGbG9hdC5fbkN5Y2xlcyB8IDA7XG4gICAgbGV0IGFscGhhID0gX05ldVF1YW50RmxvYXQuX2luaXRBbHBoYTtcbiAgICBsZXQgcmFkaXVzID0gKHRoaXMuX25ldHdvcmtTaXplID4+IDMpICogX05ldVF1YW50RmxvYXQuX3JhZGl1c0JpYXM7XG4gICAgbGV0IHJhZCA9IHJhZGl1cyA+PiBfTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhc1NoaWZ0O1xuICAgIGlmIChyYWQgPD0gMSlcbiAgICAgIHJhZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYWQ7IGkrKykge1xuICAgICAgdGhpcy5fcmFkUG93ZXJbaV0gPSBhbHBoYSAqICgocmFkICogcmFkIC0gaSAqIGkpICogX05ldVF1YW50RmxvYXQuX3JhZEJpYXMgLyAocmFkICogcmFkKSk7XG4gICAgfVxuICAgIGxldCBzdGVwO1xuICAgIGlmIChwb2ludHNOdW1iZXIgPCBfTmV1UXVhbnRGbG9hdC5fbWlucGljdHVyZWJ5dGVzKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c051bWJlciAlIF9OZXVRdWFudEZsb2F0Ll9wcmltZTEgIT09IDApIHtcbiAgICAgIHN0ZXAgPSBfTmV1UXVhbnRGbG9hdC5fcHJpbWUxO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzTnVtYmVyICUgX05ldVF1YW50RmxvYXQuX3ByaW1lMiAhPT0gMCkge1xuICAgICAgc3RlcCA9IF9OZXVRdWFudEZsb2F0Ll9wcmltZTI7XG4gICAgfSBlbHNlIGlmIChwb2ludHNOdW1iZXIgJSBfTmV1UXVhbnRGbG9hdC5fcHJpbWUzICE9PSAwKSB7XG4gICAgICBzdGVwID0gX05ldVF1YW50RmxvYXQuX3ByaW1lMztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RlcCA9IF9OZXVRdWFudEZsb2F0Ll9wcmltZTQ7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKHBvaW50c1RvU2FtcGxlLCA5OSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBvaW50SW5kZXggPSAwOyBpIDwgcG9pbnRzVG9TYW1wbGU7ICkge1xuICAgICAgaWYgKHRyYWNrZXIuc2hvdWxkTm90aWZ5KGkpKSB7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9wb2ludEFycmF5W3BvaW50SW5kZXhdO1xuICAgICAgY29uc3QgYiA9IHBvaW50LmIgPDwgbmV0d29ya0JpYXNTaGlmdDI7XG4gICAgICBjb25zdCBnID0gcG9pbnQuZyA8PCBuZXR3b3JrQmlhc1NoaWZ0MjtcbiAgICAgIGNvbnN0IHIgPSBwb2ludC5yIDw8IG5ldHdvcmtCaWFzU2hpZnQyO1xuICAgICAgY29uc3QgYSA9IHBvaW50LmEgPDwgbmV0d29ya0JpYXNTaGlmdDI7XG4gICAgICBjb25zdCBuZXVyb25JbmRleCA9IHRoaXMuX2NvbnRlc3QoYiwgZywgciwgYSk7XG4gICAgICB0aGlzLl9hbHRlclNpbmdsZShhbHBoYSwgbmV1cm9uSW5kZXgsIGIsIGcsIHIsIGEpO1xuICAgICAgaWYgKHJhZCAhPT0gMClcbiAgICAgICAgdGhpcy5fYWx0ZXJOZWlnaGJvdXIocmFkLCBuZXVyb25JbmRleCwgYiwgZywgciwgYSk7XG4gICAgICBwb2ludEluZGV4ICs9IHN0ZXA7XG4gICAgICBpZiAocG9pbnRJbmRleCA+PSBwb2ludHNOdW1iZXIpXG4gICAgICAgIHBvaW50SW5kZXggLT0gcG9pbnRzTnVtYmVyO1xuICAgICAgaSsrO1xuICAgICAgaWYgKGRlbHRhID09PSAwKVxuICAgICAgICBkZWx0YSA9IDE7XG4gICAgICBpZiAoaSAlIGRlbHRhID09PSAwKSB7XG4gICAgICAgIGFscGhhIC09IGFscGhhIC8gYWxwaGFkZWM7XG4gICAgICAgIHJhZGl1cyAtPSByYWRpdXMgLyBfTmV1UXVhbnRGbG9hdC5fcmFkaXVzRGVjcmVhc2U7XG4gICAgICAgIHJhZCA9IHJhZGl1cyA+PiBfTmV1UXVhbnRGbG9hdC5fcmFkaXVzQmlhc1NoaWZ0O1xuICAgICAgICBpZiAocmFkIDw9IDEpXG4gICAgICAgICAgcmFkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYWQ7IGorKykge1xuICAgICAgICAgIHRoaXMuX3JhZFBvd2VyW2pdID0gYWxwaGEgKiAoKHJhZCAqIHJhZCAtIGogKiBqKSAqIF9OZXVRdWFudEZsb2F0Ll9yYWRCaWFzIC8gKHJhZCAqIHJhZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9idWlsZFBhbGV0dGUoKSB7XG4gICAgY29uc3QgcGFsZXR0ZSA9IG5ldyBQYWxldHRlKCk7XG4gICAgdGhpcy5fbmV0d29yay5mb3JFYWNoKChuZXVyb24pID0+IHtcbiAgICAgIHBhbGV0dGUuYWRkKG5ldXJvbi50b1BvaW50KCkpO1xuICAgIH0pO1xuICAgIHBhbGV0dGUuc29ydCgpO1xuICAgIHJldHVybiBwYWxldHRlO1xuICB9XG4gIF9hbHRlck5laWdoYm91cihyYWQsIGksIGIsIGcsIHIsIGFsKSB7XG4gICAgbGV0IGxvID0gaSAtIHJhZDtcbiAgICBpZiAobG8gPCAtMSlcbiAgICAgIGxvID0gLTE7XG4gICAgbGV0IGhpID0gaSArIHJhZDtcbiAgICBpZiAoaGkgPiB0aGlzLl9uZXR3b3JrU2l6ZSlcbiAgICAgIGhpID0gdGhpcy5fbmV0d29ya1NpemU7XG4gICAgbGV0IGogPSBpICsgMTtcbiAgICBsZXQgayA9IGkgLSAxO1xuICAgIGxldCBtID0gMTtcbiAgICB3aGlsZSAoaiA8IGhpIHx8IGsgPiBsbykge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX3JhZFBvd2VyW20rK10gLyBfTmV1UXVhbnRGbG9hdC5fYWxwaGFSYWRCaWFzO1xuICAgICAgaWYgKGogPCBoaSkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5fbmV0d29ya1tqKytdO1xuICAgICAgICBwLnN1YnRyYWN0KGEgKiAocC5yIC0gciksIGEgKiAocC5nIC0gZyksIGEgKiAocC5iIC0gYiksIGEgKiAocC5hIC0gYWwpKTtcbiAgICAgIH1cbiAgICAgIGlmIChrID4gbG8pIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuX25ldHdvcmtbay0tXTtcbiAgICAgICAgcC5zdWJ0cmFjdChhICogKHAuciAtIHIpLCBhICogKHAuZyAtIGcpLCBhICogKHAuYiAtIGIpLCBhICogKHAuYSAtIGFsKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9hbHRlclNpbmdsZShhbHBoYSwgaSwgYiwgZywgciwgYSkge1xuICAgIGFscGhhIC89IF9OZXVRdWFudEZsb2F0Ll9pbml0QWxwaGE7XG4gICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XG4gICAgbi5zdWJ0cmFjdChhbHBoYSAqIChuLnIgLSByKSwgYWxwaGEgKiAobi5nIC0gZyksIGFscGhhICogKG4uYiAtIGIpLCBhbHBoYSAqIChuLmEgLSBhKSk7XG4gIH1cbiAgX2NvbnRlc3QoYiwgZywgciwgYWwpIHtcbiAgICBjb25zdCBtdWx0aXBsaWVyID0gMjU1ICogNCA8PCBuZXR3b3JrQmlhc1NoaWZ0MjtcbiAgICBsZXQgYmVzdGQgPSB+KDEgPDwgMzEpO1xuICAgIGxldCBiZXN0Ymlhc2QgPSBiZXN0ZDtcbiAgICBsZXQgYmVzdHBvcyA9IC0xO1xuICAgIGxldCBiZXN0Ymlhc3BvcyA9IGJlc3Rwb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9uZXR3b3JrU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fbmV0d29ya1tpXTtcbiAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLl9kaXN0YW5jZS5jYWxjdWxhdGVOb3JtYWxpemVkKG4sIHsgciwgZywgYiwgYTogYWwgfSkgKiBtdWx0aXBsaWVyO1xuICAgICAgaWYgKGRpc3QgPCBiZXN0ZCkge1xuICAgICAgICBiZXN0ZCA9IGRpc3Q7XG4gICAgICAgIGJlc3Rwb3MgPSBpO1xuICAgICAgfVxuICAgICAgY29uc3QgYmlhc2Rpc3QgPSBkaXN0IC0gKHRoaXMuX2JpYXNbaV0gPj4gX05ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzU2hpZnQgLSBuZXR3b3JrQmlhc1NoaWZ0Mik7XG4gICAgICBpZiAoYmlhc2Rpc3QgPCBiZXN0Ymlhc2QpIHtcbiAgICAgICAgYmVzdGJpYXNkID0gYmlhc2Rpc3Q7XG4gICAgICAgIGJlc3RiaWFzcG9zID0gaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJldGFmcmVxID0gdGhpcy5fZnJlcVtpXSA+PiBfTmV1UXVhbnRGbG9hdC5fYmV0YVNoaWZ0O1xuICAgICAgdGhpcy5fZnJlcVtpXSAtPSBiZXRhZnJlcTtcbiAgICAgIHRoaXMuX2JpYXNbaV0gKz0gYmV0YWZyZXEgPDwgX05ldVF1YW50RmxvYXQuX2dhbW1hU2hpZnQ7XG4gICAgfVxuICAgIHRoaXMuX2ZyZXFbYmVzdHBvc10gKz0gX05ldVF1YW50RmxvYXQuX2JldGE7XG4gICAgdGhpcy5fYmlhc1tiZXN0cG9zXSAtPSBfTmV1UXVhbnRGbG9hdC5fYmV0YUdhbW1hO1xuICAgIHJldHVybiBiZXN0Ymlhc3BvcztcbiAgfVxufTtcbnZhciBOZXVRdWFudEZsb2F0ID0gX05ldVF1YW50RmxvYXQ7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX3ByaW1lMVwiLCA0OTkpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9wcmltZTJcIiwgNDkxKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfcHJpbWUzXCIsIDQ4Nyk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX3ByaW1lNFwiLCA1MDMpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9taW5waWN0dXJlYnl0ZXNcIiwgX05ldVF1YW50RmxvYXQuX3ByaW1lNCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX25DeWNsZXNcIiwgMTAwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfaW5pdGlhbEJpYXNTaGlmdFwiLCAxNik7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX2luaXRpYWxCaWFzXCIsIDEgPDwgX05ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9nYW1tYVNoaWZ0XCIsIDEwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfYmV0YVNoaWZ0XCIsIDEwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfYmV0YVwiLCBfTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXMgPj4gX05ldVF1YW50RmxvYXQuX2JldGFTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX2JldGFHYW1tYVwiLCBfTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXMgPDwgX05ldVF1YW50RmxvYXQuX2dhbW1hU2hpZnQgLSBfTmV1UXVhbnRGbG9hdC5fYmV0YVNoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfcmFkaXVzQmlhc1NoaWZ0XCIsIDYpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9yYWRpdXNCaWFzXCIsIDEgPDwgX05ldVF1YW50RmxvYXQuX3JhZGl1c0JpYXNTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX3JhZGl1c0RlY3JlYXNlXCIsIDMwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfYWxwaGFCaWFzU2hpZnRcIiwgMTApO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9pbml0QWxwaGFcIiwgMSA8PCBfTmV1UXVhbnRGbG9hdC5fYWxwaGFCaWFzU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9yYWRCaWFzU2hpZnRcIiwgOCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX3JhZEJpYXNcIiwgMSA8PCBfTmV1UXVhbnRGbG9hdC5fcmFkQmlhc1NoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfYWxwaGFSYWRCaWFzU2hpZnRcIiwgX05ldVF1YW50RmxvYXQuX2FscGhhQmlhc1NoaWZ0ICsgX05ldVF1YW50RmxvYXQuX3JhZEJpYXNTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX2FscGhhUmFkQmlhc1wiLCAxIDw8IF9OZXVRdWFudEZsb2F0Ll9hbHBoYVJhZEJpYXNTaGlmdCk7XG5cbi8vIHNyYy9wYWxldHRlL3JnYnF1YW50L2NvbG9ySGlzdG9ncmFtLnRzXG52YXIgX0NvbG9ySGlzdG9ncmFtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtZXRob2QsIGNvbG9ycykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbWV0aG9kXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaHVlU3RhdHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9oaXN0b2dyYW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9pbml0Q29sb3JzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbWluSHVlQ29sc1wiKTtcbiAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy5fbWluSHVlQ29scyA9IGNvbG9ycyA8PCAyO1xuICAgIHRoaXMuX2luaXRDb2xvcnMgPSBjb2xvcnMgPDwgMjtcbiAgICB0aGlzLl9odWVTdGF0cyA9IG5ldyBIdWVTdGF0aXN0aWNzKF9Db2xvckhpc3RvZ3JhbS5faHVlR3JvdXBzLCB0aGlzLl9taW5IdWVDb2xzKTtcbiAgICB0aGlzLl9oaXN0b2dyYW0gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBzYW1wbGUocG9pbnRDb250YWluZXIpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX21ldGhvZCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9jb2xvclN0YXRzMUQocG9pbnRDb250YWluZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5fY29sb3JTdGF0czJEKHBvaW50Q29udGFpbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGdldEltcG9ydGFuY2VTb3J0ZWRDb2xvcnNJRFhJMzIoKSB7XG4gICAgY29uc3Qgc29ydGVkID0gc3RhYmxlU29ydChPYmplY3Qua2V5cyh0aGlzLl9oaXN0b2dyYW0pLCAoYSwgYikgPT4gdGhpcy5faGlzdG9ncmFtW2JdIC0gdGhpcy5faGlzdG9ncmFtW2FdKTtcbiAgICBpZiAoc29ydGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgaWR4aTMyO1xuICAgIHN3aXRjaCAodGhpcy5fbWV0aG9kKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNvbnN0IGluaXRpYWxDb2xvcnNMaW1pdCA9IE1hdGgubWluKHNvcnRlZC5sZW5ndGgsIHRoaXMuX2luaXRDb2xvcnMpO1xuICAgICAgICBjb25zdCBsYXN0ID0gc29ydGVkW2luaXRpYWxDb2xvcnNMaW1pdCAtIDFdO1xuICAgICAgICBjb25zdCBmcmVxID0gdGhpcy5faGlzdG9ncmFtW2xhc3RdO1xuICAgICAgICBpZHhpMzIgPSBzb3J0ZWQuc2xpY2UoMCwgaW5pdGlhbENvbG9yc0xpbWl0KTtcbiAgICAgICAgbGV0IHBvcyA9IGluaXRpYWxDb2xvcnNMaW1pdDtcbiAgICAgICAgY29uc3QgbGVuID0gc29ydGVkLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IGxlbiAmJiB0aGlzLl9oaXN0b2dyYW1bc29ydGVkW3Bvc11dID09PSBmcmVxKSB7XG4gICAgICAgICAgaWR4aTMyLnB1c2goc29ydGVkW3BvcysrXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faHVlU3RhdHMuaW5qZWN0SW50b0FycmF5KGlkeGkzMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBpZHhpMzIgPSBzb3J0ZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IG1ldGhvZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkeGkzMi5tYXAoKHYpID0+ICt2KTtcbiAgfVxuICBfY29sb3JTdGF0czFEKHBvaW50Q29udGFpbmVyKSB7XG4gICAgY29uc3QgaGlzdEcgPSB0aGlzLl9oaXN0b2dyYW07XG4gICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcbiAgICBjb25zdCBsZW4gPSBwb2ludEFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjb2wgPSBwb2ludEFycmF5W2ldLnVpbnQzMjtcbiAgICAgIHRoaXMuX2h1ZVN0YXRzLmNoZWNrKGNvbCk7XG4gICAgICBpZiAoY29sIGluIGhpc3RHKSB7XG4gICAgICAgIGhpc3RHW2NvbF0rKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpc3RHW2NvbF0gPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfY29sb3JTdGF0czJEKHBvaW50Q29udGFpbmVyKSB7XG4gICAgY29uc3Qgd2lkdGggPSBwb2ludENvbnRhaW5lci5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHBvaW50Q29udGFpbmVyLmdldEhlaWdodCgpO1xuICAgIGNvbnN0IHBvaW50QXJyYXkgPSBwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XG4gICAgY29uc3QgYm94VyA9IF9Db2xvckhpc3RvZ3JhbS5fYm94U2l6ZVswXTtcbiAgICBjb25zdCBib3hIID0gX0NvbG9ySGlzdG9ncmFtLl9ib3hTaXplWzFdO1xuICAgIGNvbnN0IGFyZWEgPSBib3hXICogYm94SDtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuX21ha2VCb3hlcyh3aWR0aCwgaGVpZ2h0LCBib3hXLCBib3hIKTtcbiAgICBjb25zdCBoaXN0RyA9IHRoaXMuX2hpc3RvZ3JhbTtcbiAgICBib3hlcy5mb3JFYWNoKChib3gpID0+IHtcbiAgICAgIGxldCBlZmZjID0gTWF0aC5yb3VuZChib3gudyAqIGJveC5oIC8gYXJlYSkgKiBfQ29sb3JIaXN0b2dyYW0uX2JveFBpeGVscztcbiAgICAgIGlmIChlZmZjIDwgMilcbiAgICAgICAgZWZmYyA9IDI7XG4gICAgICBjb25zdCBoaXN0TCA9IHt9O1xuICAgICAgdGhpcy5faXRlcmF0ZUJveChib3gsIHdpZHRoLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBjb2wgPSBwb2ludEFycmF5W2ldLnVpbnQzMjtcbiAgICAgICAgdGhpcy5faHVlU3RhdHMuY2hlY2soY29sKTtcbiAgICAgICAgaWYgKGNvbCBpbiBoaXN0Rykge1xuICAgICAgICAgIGhpc3RHW2NvbF0rKztcbiAgICAgICAgfSBlbHNlIGlmIChjb2wgaW4gaGlzdEwpIHtcbiAgICAgICAgICBpZiAoKytoaXN0TFtjb2xdID49IGVmZmMpIHtcbiAgICAgICAgICAgIGhpc3RHW2NvbF0gPSBoaXN0TFtjb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaXN0TFtjb2xdID0gMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5faHVlU3RhdHMuaW5qZWN0SW50b0RpY3Rpb25hcnkoaGlzdEcpO1xuICB9XG4gIF9pdGVyYXRlQm94KGJib3gsIHdpZCwgZm4pIHtcbiAgICBjb25zdCBiID0gYmJveDtcbiAgICBjb25zdCBpMCA9IGIueSAqIHdpZCArIGIueDtcbiAgICBjb25zdCBpMSA9IChiLnkgKyBiLmggLSAxKSAqIHdpZCArIChiLnggKyBiLncgLSAxKTtcbiAgICBjb25zdCBpbmNyID0gd2lkIC0gYi53ICsgMTtcbiAgICBsZXQgY250ID0gMDtcbiAgICBsZXQgaSA9IGkwO1xuICAgIGRvIHtcbiAgICAgIGZuLmNhbGwodGhpcywgaSk7XG4gICAgICBpICs9ICsrY250ICUgYi53ID09PSAwID8gaW5jciA6IDE7XG4gICAgfSB3aGlsZSAoaSA8PSBpMSk7XG4gIH1cbiAgX21ha2VCb3hlcyh3aWR0aCwgaGVpZ2h0LCBzdGVwWCwgc3RlcFkpIHtcbiAgICBjb25zdCB3cmVtID0gd2lkdGggJSBzdGVwWDtcbiAgICBjb25zdCBocmVtID0gaGVpZ2h0ICUgc3RlcFk7XG4gICAgY29uc3QgeGVuZCA9IHdpZHRoIC0gd3JlbTtcbiAgICBjb25zdCB5ZW5kID0gaGVpZ2h0IC0gaHJlbTtcbiAgICBjb25zdCBib3hlc0FycmF5ID0gW107XG4gICAgZm9yIChsZXQgeTIgPSAwOyB5MiA8IGhlaWdodDsgeTIgKz0gc3RlcFkpIHtcbiAgICAgIGZvciAobGV0IHgyID0gMDsgeDIgPCB3aWR0aDsgeDIgKz0gc3RlcFgpIHtcbiAgICAgICAgYm94ZXNBcnJheS5wdXNoKHtcbiAgICAgICAgICB4OiB4MixcbiAgICAgICAgICB5OiB5MixcbiAgICAgICAgICB3OiB4MiA9PT0geGVuZCA/IHdyZW0gOiBzdGVwWCxcbiAgICAgICAgICBoOiB5MiA9PT0geWVuZCA/IGhyZW0gOiBzdGVwWVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJveGVzQXJyYXk7XG4gIH1cbn07XG52YXIgQ29sb3JIaXN0b2dyYW0gPSBfQ29sb3JIaXN0b2dyYW07XG5fX3B1YmxpY0ZpZWxkKENvbG9ySGlzdG9ncmFtLCBcIl9ib3hTaXplXCIsIFs2NCwgNjRdKTtcbl9fcHVibGljRmllbGQoQ29sb3JIaXN0b2dyYW0sIFwiX2JveFBpeGVsc1wiLCAyKTtcbl9fcHVibGljRmllbGQoQ29sb3JIaXN0b2dyYW0sIFwiX2h1ZUdyb3Vwc1wiLCAxMCk7XG5cbi8vIHNyYy9wYWxldHRlL3JnYnF1YW50L3JnYnF1YW50LnRzXG52YXIgUmVtb3ZlZENvbG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpbmRleCwgY29sb3IsIGRpc3RhbmNlKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluZGV4XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb2xvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGlzdGFuY2VcIik7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gIH1cbn07XG52YXIgUkdCUXVhbnQgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMgPSAyNTYsIG1ldGhvZCA9IDIpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY29sb3JzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaW5pdGlhbERpc3RhbmNlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGlzdGFuY2VJbmNyZW1lbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9oaXN0b2dyYW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9kaXN0YW5jZVwiKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xuICAgIHRoaXMuX2NvbG9ycyA9IGNvbG9ycztcbiAgICB0aGlzLl9oaXN0b2dyYW0gPSBuZXcgQ29sb3JIaXN0b2dyYW0obWV0aG9kLCBjb2xvcnMpO1xuICAgIHRoaXMuX2luaXRpYWxEaXN0YW5jZSA9IDAuMDE7XG4gICAgdGhpcy5fZGlzdGFuY2VJbmNyZW1lbnQgPSA1ZS0zO1xuICB9XG4gIHNhbXBsZShpbWFnZSkge1xuICAgIHRoaXMuX2hpc3RvZ3JhbS5zYW1wbGUoaW1hZ2UpO1xuICB9XG4gICpxdWFudGl6ZSgpIHtcbiAgICBjb25zdCBpZHhpMzIgPSB0aGlzLl9oaXN0b2dyYW0uZ2V0SW1wb3J0YW5jZVNvcnRlZENvbG9yc0lEWEkzMigpO1xuICAgIGlmIChpZHhpMzIubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb2xvcnMgaW4gaW1hZ2VcIik7XG4gICAgfVxuICAgIHlpZWxkKiB0aGlzLl9idWlsZFBhbGV0dGUoaWR4aTMyKTtcbiAgfVxuICAqX2J1aWxkUGFsZXR0ZShpZHhpMzIpIHtcbiAgICBjb25zdCBwYWxldHRlID0gbmV3IFBhbGV0dGUoKTtcbiAgICBjb25zdCBjb2xvckFycmF5ID0gcGFsZXR0ZS5nZXRQb2ludENvbnRhaW5lcigpLmdldFBvaW50QXJyYXkoKTtcbiAgICBjb25zdCB1c2FnZUFycmF5ID0gbmV3IEFycmF5KGlkeGkzMi5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWR4aTMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2xvckFycmF5LnB1c2goUG9pbnQuY3JlYXRlQnlVaW50MzIoaWR4aTMyW2ldKSk7XG4gICAgICB1c2FnZUFycmF5W2ldID0gMTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gY29sb3JBcnJheS5sZW5ndGg7XG4gICAgY29uc3QgbWVtRGlzdCA9IFtdO1xuICAgIGxldCBwYWxMZW4gPSBsZW47XG4gICAgbGV0IHRob2xkID0gdGhpcy5faW5pdGlhbERpc3RhbmNlO1xuICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKHBhbExlbiAtIHRoaXMuX2NvbG9ycywgOTkpO1xuICAgIHdoaWxlIChwYWxMZW4gPiB0aGlzLl9jb2xvcnMpIHtcbiAgICAgIG1lbURpc3QubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRyYWNrZXIuc2hvdWxkTm90aWZ5KGxlbiAtIHBhbExlbikpIHtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzYWdlQXJyYXlbaV0gPT09IDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHB4aSA9IGNvbG9yQXJyYXlbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgaWYgKHVzYWdlQXJyYXlbal0gPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBweGogPSBjb2xvckFycmF5W2pdO1xuICAgICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLl9kaXN0YW5jZS5jYWxjdWxhdGVOb3JtYWxpemVkKHB4aSwgcHhqKTtcbiAgICAgICAgICBpZiAoZGlzdCA8IHRob2xkKSB7XG4gICAgICAgICAgICBtZW1EaXN0LnB1c2gobmV3IFJlbW92ZWRDb2xvcihqLCBweGosIGRpc3QpKTtcbiAgICAgICAgICAgIHVzYWdlQXJyYXlbal0gPSAwO1xuICAgICAgICAgICAgcGFsTGVuLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aG9sZCArPSBwYWxMZW4gPiB0aGlzLl9jb2xvcnMgKiAzID8gdGhpcy5faW5pdGlhbERpc3RhbmNlIDogdGhpcy5fZGlzdGFuY2VJbmNyZW1lbnQ7XG4gICAgfVxuICAgIGlmIChwYWxMZW4gPCB0aGlzLl9jb2xvcnMpIHtcbiAgICAgIHN0YWJsZVNvcnQobWVtRGlzdCwgKGEsIGIpID0+IGIuZGlzdGFuY2UgLSBhLmRpc3RhbmNlKTtcbiAgICAgIGxldCBrID0gMDtcbiAgICAgIHdoaWxlIChwYWxMZW4gPCB0aGlzLl9jb2xvcnMgJiYgayA8IG1lbURpc3QubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRDb2xvciA9IG1lbURpc3Rba107XG4gICAgICAgIHVzYWdlQXJyYXlbcmVtb3ZlZENvbG9yLmluZGV4XSA9IDE7XG4gICAgICAgIHBhbExlbisrO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjb2xvcnMgPSBjb2xvckFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBjb2xvckluZGV4ID0gY29sb3JzIC0gMTsgY29sb3JJbmRleCA+PSAwOyBjb2xvckluZGV4LS0pIHtcbiAgICAgIGlmICh1c2FnZUFycmF5W2NvbG9ySW5kZXhdID09PSAwKSB7XG4gICAgICAgIGlmIChjb2xvckluZGV4ICE9PSBjb2xvcnMgLSAxKSB7XG4gICAgICAgICAgY29sb3JBcnJheVtjb2xvckluZGV4XSA9IGNvbG9yQXJyYXlbY29sb3JzIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgLS1jb2xvcnM7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbG9yQXJyYXkubGVuZ3RoID0gY29sb3JzO1xuICAgIHBhbGV0dGUuc29ydCgpO1xuICAgIHlpZWxkIHtcbiAgICAgIHBhbGV0dGUsXG4gICAgICBwcm9ncmVzczogMTAwXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3BhbGV0dGUvd3Uvd3VRdWFudC50c1xuZnVuY3Rpb24gY3JlYXRlQXJyYXkxRChkaW1lbnNpb24xKSB7XG4gIGNvbnN0IGEgPSBbXTtcbiAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1lbnNpb24xOyBrKyspIHtcbiAgICBhW2tdID0gMDtcbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5NEQoZGltZW5zaW9uMSwgZGltZW5zaW9uMiwgZGltZW5zaW9uMywgZGltZW5zaW9uNCkge1xuICBjb25zdCBhID0gbmV3IEFycmF5KGRpbWVuc2lvbjEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xuICAgIGFbaV0gPSBuZXcgQXJyYXkoZGltZW5zaW9uMik7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW1lbnNpb24yOyBqKyspIHtcbiAgICAgIGFbaV1bal0gPSBuZXcgQXJyYXkoZGltZW5zaW9uMyk7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRpbWVuc2lvbjM7IGsrKykge1xuICAgICAgICBhW2ldW2pdW2tdID0gbmV3IEFycmF5KGRpbWVuc2lvbjQpO1xuICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IGRpbWVuc2lvbjQ7IGwrKykge1xuICAgICAgICAgIGFbaV1bal1ba11bbF0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJyYXkzRChkaW1lbnNpb24xLCBkaW1lbnNpb24yLCBkaW1lbnNpb24zKSB7XG4gIGNvbnN0IGEgPSBuZXcgQXJyYXkoZGltZW5zaW9uMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uMTsgaSsrKSB7XG4gICAgYVtpXSA9IG5ldyBBcnJheShkaW1lbnNpb24yKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbjI7IGorKykge1xuICAgICAgYVtpXVtqXSA9IG5ldyBBcnJheShkaW1lbnNpb24zKTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZGltZW5zaW9uMzsgaysrKSB7XG4gICAgICAgIGFbaV1bal1ba10gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGZpbGxBcnJheTNEKGEsIGRpbWVuc2lvbjEsIGRpbWVuc2lvbjIsIGRpbWVuc2lvbjMsIHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uMTsgaSsrKSB7XG4gICAgYVtpXSA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9uMjsgaisrKSB7XG4gICAgICBhW2ldW2pdID0gW107XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRpbWVuc2lvbjM7IGsrKykge1xuICAgICAgICBhW2ldW2pdW2tdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaWxsQXJyYXkxRChhLCBkaW1lbnNpb24xLCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xuICAgIGFbaV0gPSB2YWx1ZTtcbiAgfVxufVxudmFyIFd1Q29sb3JDdWJlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVkTWluaW11bVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVkTWF4aW11bVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ3JlZW5NaW5pbXVtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJncmVlbk1heGltdW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJsdWVNaW5pbXVtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJibHVlTWF4aW11bVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidm9sdW1lXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhbHBoYU1pbmltdW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFscGhhTWF4aW11bVwiKTtcbiAgfVxufTtcbnZhciBfV3VRdWFudCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyIHtcbiAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyA9IDI1Niwgc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbCA9IDUpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcmVkc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2dyZWVuc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2JsdWVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYWxwaGFzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc3Vtc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3dlaWdodHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tb21lbnRzUmVkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbW9tZW50c0dyZWVuXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbW9tZW50c0JsdWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tb21lbnRzQWxwaGFcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tb21lbnRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfdGFibGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9waXhlbHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jdWJlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NvbG9yc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3NpZ25pZmljYW50Qml0c1BlckNoYW5uZWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tYXhTaWRlSW5kZXhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hbHBoYU1heFNpZGVJbmRleFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3NpZGVTaXplXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYWxwaGFTaWRlU2l6ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2Rpc3RhbmNlXCIpO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XG4gICAgdGhpcy5fc2V0UXVhbGl0eShzaWduaWZpY2FudEJpdHNQZXJDaGFubmVsKTtcbiAgICB0aGlzLl9pbml0aWFsaXplKGNvbG9ycyk7XG4gIH1cbiAgc2FtcGxlKGltYWdlKSB7XG4gICAgY29uc3QgcG9pbnRBcnJheSA9IGltYWdlLmdldFBvaW50QXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBvaW50QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLl9hZGRDb2xvcihwb2ludEFycmF5W2ldKTtcbiAgICB9XG4gICAgdGhpcy5fcGl4ZWxzID0gdGhpcy5fcGl4ZWxzLmNvbmNhdChwb2ludEFycmF5KTtcbiAgfVxuICAqcXVhbnRpemUoKSB7XG4gICAgeWllbGQqIHRoaXMuX3ByZXBhcmVQYWxldHRlKCk7XG4gICAgY29uc3QgcGFsZXR0ZSA9IG5ldyBQYWxldHRlKCk7XG4gICAgZm9yIChsZXQgcGFsZXR0ZUluZGV4ID0gMDsgcGFsZXR0ZUluZGV4IDwgdGhpcy5fY29sb3JzOyBwYWxldHRlSW5kZXgrKykge1xuICAgICAgaWYgKHRoaXMuX3N1bXNbcGFsZXR0ZUluZGV4XSA+IDApIHtcbiAgICAgICAgY29uc3Qgc3VtID0gdGhpcy5fc3Vtc1twYWxldHRlSW5kZXhdO1xuICAgICAgICBjb25zdCByID0gdGhpcy5fcmVkc1twYWxldHRlSW5kZXhdIC8gc3VtO1xuICAgICAgICBjb25zdCBnID0gdGhpcy5fZ3JlZW5zW3BhbGV0dGVJbmRleF0gLyBzdW07XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLl9ibHVlc1twYWxldHRlSW5kZXhdIC8gc3VtO1xuICAgICAgICBjb25zdCBhID0gdGhpcy5fYWxwaGFzW3BhbGV0dGVJbmRleF0gLyBzdW07XG4gICAgICAgIGNvbnN0IGNvbG9yID0gUG9pbnQuY3JlYXRlQnlSR0JBKHIgfCAwLCBnIHwgMCwgYiB8IDAsIGEgfCAwKTtcbiAgICAgICAgcGFsZXR0ZS5hZGQoY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBwYWxldHRlLnNvcnQoKTtcbiAgICB5aWVsZCB7XG4gICAgICBwYWxldHRlLFxuICAgICAgcHJvZ3Jlc3M6IDEwMFxuICAgIH07XG4gIH1cbiAgKl9wcmVwYXJlUGFsZXR0ZSgpIHtcbiAgICB5aWVsZCogdGhpcy5fY2FsY3VsYXRlTW9tZW50cygpO1xuICAgIGxldCBuZXh0ID0gMDtcbiAgICBjb25zdCB2b2x1bWVWYXJpYW5jZSA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzKTtcbiAgICBmb3IgKGxldCBjdWJlSW5kZXggPSAxOyBjdWJlSW5kZXggPCB0aGlzLl9jb2xvcnM7ICsrY3ViZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fY3V0KHRoaXMuX2N1YmVzW25leHRdLCB0aGlzLl9jdWJlc1tjdWJlSW5kZXhdKSkge1xuICAgICAgICB2b2x1bWVWYXJpYW5jZVtuZXh0XSA9IHRoaXMuX2N1YmVzW25leHRdLnZvbHVtZSA+IDEgPyB0aGlzLl9jYWxjdWxhdGVWYXJpYW5jZSh0aGlzLl9jdWJlc1tuZXh0XSkgOiAwO1xuICAgICAgICB2b2x1bWVWYXJpYW5jZVtjdWJlSW5kZXhdID0gdGhpcy5fY3ViZXNbY3ViZUluZGV4XS52b2x1bWUgPiAxID8gdGhpcy5fY2FsY3VsYXRlVmFyaWFuY2UodGhpcy5fY3ViZXNbY3ViZUluZGV4XSkgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm9sdW1lVmFyaWFuY2VbbmV4dF0gPSAwO1xuICAgICAgICBjdWJlSW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIG5leHQgPSAwO1xuICAgICAgbGV0IHRlbXAgPSB2b2x1bWVWYXJpYW5jZVswXTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPD0gY3ViZUluZGV4OyArK2luZGV4KSB7XG4gICAgICAgIGlmICh2b2x1bWVWYXJpYW5jZVtpbmRleF0gPiB0ZW1wKSB7XG4gICAgICAgICAgdGVtcCA9IHZvbHVtZVZhcmlhbmNlW2luZGV4XTtcbiAgICAgICAgICBuZXh0ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wIDw9IDApIHtcbiAgICAgICAgdGhpcy5fY29sb3JzID0gY3ViZUluZGV4ICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxvb2t1cFJlZCA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cEdyZWVuID0gW107XG4gICAgY29uc3QgbG9va3VwQmx1ZSA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cEFscGhhID0gW107XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLl9jb2xvcnM7ICsraykge1xuICAgICAgY29uc3Qgd2VpZ2h0ID0gX1d1UXVhbnQuX3ZvbHVtZSh0aGlzLl9jdWJlc1trXSwgdGhpcy5fd2VpZ2h0cyk7XG4gICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICBsb29rdXBSZWRba10gPSBfV3VRdWFudC5fdm9sdW1lKHRoaXMuX2N1YmVzW2tdLCB0aGlzLl9tb21lbnRzUmVkKSAvIHdlaWdodCB8IDA7XG4gICAgICAgIGxvb2t1cEdyZWVuW2tdID0gX1d1UXVhbnQuX3ZvbHVtZSh0aGlzLl9jdWJlc1trXSwgdGhpcy5fbW9tZW50c0dyZWVuKSAvIHdlaWdodCB8IDA7XG4gICAgICAgIGxvb2t1cEJsdWVba10gPSBfV3VRdWFudC5fdm9sdW1lKHRoaXMuX2N1YmVzW2tdLCB0aGlzLl9tb21lbnRzQmx1ZSkgLyB3ZWlnaHQgfCAwO1xuICAgICAgICBsb29rdXBBbHBoYVtrXSA9IF9XdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX21vbWVudHNBbHBoYSkgLyB3ZWlnaHQgfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9va3VwUmVkW2tdID0gMDtcbiAgICAgICAgbG9va3VwR3JlZW5ba10gPSAwO1xuICAgICAgICBsb29rdXBCbHVlW2tdID0gMDtcbiAgICAgICAgbG9va3VwQWxwaGFba10gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZWRzID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcbiAgICB0aGlzLl9ncmVlbnMgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyArIDEpO1xuICAgIHRoaXMuX2JsdWVzID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcbiAgICB0aGlzLl9hbHBoYXMgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyArIDEpO1xuICAgIHRoaXMuX3N1bXMgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyArIDEpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbCA9IHRoaXMuX3BpeGVscy5sZW5ndGg7IGluZGV4IDwgbDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl9waXhlbHNbaW5kZXhdO1xuICAgICAgY29uc3QgbWF0Y2ggPSAtMTtcbiAgICAgIGxldCBiZXN0TWF0Y2ggPSBtYXRjaDtcbiAgICAgIGxldCBiZXN0RGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZm9yIChsZXQgbG9va3VwID0gMDsgbG9va3VwIDwgdGhpcy5fY29sb3JzOyBsb29rdXArKykge1xuICAgICAgICBjb25zdCBmb3VuZFJlZCA9IGxvb2t1cFJlZFtsb29rdXBdO1xuICAgICAgICBjb25zdCBmb3VuZEdyZWVuID0gbG9va3VwR3JlZW5bbG9va3VwXTtcbiAgICAgICAgY29uc3QgZm91bmRCbHVlID0gbG9va3VwQmx1ZVtsb29rdXBdO1xuICAgICAgICBjb25zdCBmb3VuZEFscGhhID0gbG9va3VwQWxwaGFbbG9va3VwXTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZS5jYWxjdWxhdGVSYXcoZm91bmRSZWQsIGZvdW5kR3JlZW4sIGZvdW5kQmx1ZSwgZm91bmRBbHBoYSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYSk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgIGJlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgIGJlc3RNYXRjaCA9IGxvb2t1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVkc1tiZXN0TWF0Y2hdICs9IGNvbG9yLnI7XG4gICAgICB0aGlzLl9ncmVlbnNbYmVzdE1hdGNoXSArPSBjb2xvci5nO1xuICAgICAgdGhpcy5fYmx1ZXNbYmVzdE1hdGNoXSArPSBjb2xvci5iO1xuICAgICAgdGhpcy5fYWxwaGFzW2Jlc3RNYXRjaF0gKz0gY29sb3IuYTtcbiAgICAgIHRoaXMuX3N1bXNbYmVzdE1hdGNoXSsrO1xuICAgIH1cbiAgfVxuICBfYWRkQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBiaXRzVG9SZW1vdmUgPSA4IC0gdGhpcy5fc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbDtcbiAgICBjb25zdCBpbmRleFJlZCA9IChjb2xvci5yID4+IGJpdHNUb1JlbW92ZSkgKyAxO1xuICAgIGNvbnN0IGluZGV4R3JlZW4gPSAoY29sb3IuZyA+PiBiaXRzVG9SZW1vdmUpICsgMTtcbiAgICBjb25zdCBpbmRleEJsdWUgPSAoY29sb3IuYiA+PiBiaXRzVG9SZW1vdmUpICsgMTtcbiAgICBjb25zdCBpbmRleEFscGhhID0gKGNvbG9yLmEgPj4gYml0c1RvUmVtb3ZlKSArIDE7XG4gICAgdGhpcy5fd2VpZ2h0c1tpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSsrO1xuICAgIHRoaXMuX21vbWVudHNSZWRbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gY29sb3IucjtcbiAgICB0aGlzLl9tb21lbnRzR3JlZW5baW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gY29sb3IuZztcbiAgICB0aGlzLl9tb21lbnRzQmx1ZVtpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSBjb2xvci5iO1xuICAgIHRoaXMuX21vbWVudHNBbHBoYVtpbmRleEFscGhhXVtpbmRleFJlZF1baW5kZXhHcmVlbl1baW5kZXhCbHVlXSArPSBjb2xvci5hO1xuICAgIHRoaXMuX21vbWVudHNbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gdGhpcy5fdGFibGVbY29sb3Iucl0gKyB0aGlzLl90YWJsZVtjb2xvci5nXSArIHRoaXMuX3RhYmxlW2NvbG9yLmJdICsgdGhpcy5fdGFibGVbY29sb3IuYV07XG4gIH1cbiAgKl9jYWxjdWxhdGVNb21lbnRzKCkge1xuICAgIGNvbnN0IGFyZWEgPSBbXTtcbiAgICBjb25zdCBhcmVhUmVkID0gW107XG4gICAgY29uc3QgYXJlYUdyZWVuID0gW107XG4gICAgY29uc3QgYXJlYUJsdWUgPSBbXTtcbiAgICBjb25zdCBhcmVhQWxwaGEgPSBbXTtcbiAgICBjb25zdCBhcmVhMiA9IFtdO1xuICAgIGNvbnN0IHhhcmVhID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICBjb25zdCB4YXJlYVJlZCA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XG4gICAgY29uc3QgeGFyZWFHcmVlbiA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XG4gICAgY29uc3QgeGFyZWFCbHVlID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICBjb25zdCB4YXJlYUFscGhhID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICBjb25zdCB4YXJlYTIgPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xuICAgIGxldCB0cmFja2VyUHJvZ3Jlc3MgPSAwO1xuICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKHRoaXMuX2FscGhhTWF4U2lkZUluZGV4ICogdGhpcy5fbWF4U2lkZUluZGV4LCA5OSk7XG4gICAgZm9yIChsZXQgYWxwaGFJbmRleCA9IDE7IGFscGhhSW5kZXggPD0gdGhpcy5fYWxwaGFNYXhTaWRlSW5kZXg7ICsrYWxwaGFJbmRleCkge1xuICAgICAgZmlsbEFycmF5M0QoeGFyZWEsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgZmlsbEFycmF5M0QoeGFyZWFSZWQsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgZmlsbEFycmF5M0QoeGFyZWFHcmVlbiwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XG4gICAgICBmaWxsQXJyYXkzRCh4YXJlYUJsdWUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgZmlsbEFycmF5M0QoeGFyZWFBbHBoYSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XG4gICAgICBmaWxsQXJyYXkzRCh4YXJlYTIsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgZm9yIChsZXQgcmVkSW5kZXggPSAxOyByZWRJbmRleCA8PSB0aGlzLl9tYXhTaWRlSW5kZXg7ICsrcmVkSW5kZXgsICsrdHJhY2tlclByb2dyZXNzKSB7XG4gICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeSh0cmFja2VyUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZpbGxBcnJheTFEKGFyZWEsIHRoaXMuX3NpZGVTaXplLCAwKTtcbiAgICAgICAgZmlsbEFycmF5MUQoYXJlYVJlZCwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgICBmaWxsQXJyYXkxRChhcmVhR3JlZW4sIHRoaXMuX3NpZGVTaXplLCAwKTtcbiAgICAgICAgZmlsbEFycmF5MUQoYXJlYUJsdWUsIHRoaXMuX3NpZGVTaXplLCAwKTtcbiAgICAgICAgZmlsbEFycmF5MUQoYXJlYUFscGhhLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XG4gICAgICAgIGZpbGxBcnJheTFEKGFyZWEyLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XG4gICAgICAgIGZvciAobGV0IGdyZWVuSW5kZXggPSAxOyBncmVlbkluZGV4IDw9IHRoaXMuX21heFNpZGVJbmRleDsgKytncmVlbkluZGV4KSB7XG4gICAgICAgICAgbGV0IGxpbmUgPSAwO1xuICAgICAgICAgIGxldCBsaW5lUmVkID0gMDtcbiAgICAgICAgICBsZXQgbGluZUdyZWVuID0gMDtcbiAgICAgICAgICBsZXQgbGluZUJsdWUgPSAwO1xuICAgICAgICAgIGxldCBsaW5lQWxwaGEgPSAwO1xuICAgICAgICAgIGxldCBsaW5lMiA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgYmx1ZUluZGV4ID0gMTsgYmx1ZUluZGV4IDw9IHRoaXMuX21heFNpZGVJbmRleDsgKytibHVlSW5kZXgpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gdGhpcy5fd2VpZ2h0c1thbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIGxpbmVSZWQgKz0gdGhpcy5fbW9tZW50c1JlZFthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIGxpbmVHcmVlbiArPSB0aGlzLl9tb21lbnRzR3JlZW5bYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICBsaW5lQmx1ZSArPSB0aGlzLl9tb21lbnRzQmx1ZVthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIGxpbmVBbHBoYSArPSB0aGlzLl9tb21lbnRzQWxwaGFbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICBsaW5lMiArPSB0aGlzLl9tb21lbnRzW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xuICAgICAgICAgICAgYXJlYVtibHVlSW5kZXhdICs9IGxpbmU7XG4gICAgICAgICAgICBhcmVhUmVkW2JsdWVJbmRleF0gKz0gbGluZVJlZDtcbiAgICAgICAgICAgIGFyZWFHcmVlbltibHVlSW5kZXhdICs9IGxpbmVHcmVlbjtcbiAgICAgICAgICAgIGFyZWFCbHVlW2JsdWVJbmRleF0gKz0gbGluZUJsdWU7XG4gICAgICAgICAgICBhcmVhQWxwaGFbYmx1ZUluZGV4XSArPSBsaW5lQWxwaGE7XG4gICAgICAgICAgICBhcmVhMltibHVlSW5kZXhdICs9IGxpbmUyO1xuICAgICAgICAgICAgeGFyZWFbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYVtyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhW2JsdWVJbmRleF07XG4gICAgICAgICAgICB4YXJlYVJlZFtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhUmVkW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWFSZWRbYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIHhhcmVhR3JlZW5bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYUdyZWVuW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWFHcmVlbltibHVlSW5kZXhdO1xuICAgICAgICAgICAgeGFyZWFCbHVlW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWFCbHVlW3JlZEluZGV4IC0gMV1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIGFyZWFCbHVlW2JsdWVJbmRleF07XG4gICAgICAgICAgICB4YXJlYUFscGhhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWFBbHBoYVtyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhQWxwaGFbYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIHhhcmVhMltyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhMltyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhMltibHVlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5fd2VpZ2h0c1thbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX3dlaWdodHNbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICB0aGlzLl9tb21lbnRzUmVkW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c1JlZFthbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYVJlZFtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX21vbWVudHNHcmVlblthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX21vbWVudHNHcmVlblthbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYUdyZWVuW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5fbW9tZW50c0JsdWVbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl9tb21lbnRzQmx1ZVthbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYUJsdWVbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICB0aGlzLl9tb21lbnRzQWxwaGFbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl9tb21lbnRzQWxwaGFbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFBbHBoYVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX21vbWVudHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl9tb21lbnRzW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhMltyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIF92b2x1bWVGbG9hdChjdWJlLCBtb21lbnQpIHtcbiAgICByZXR1cm4gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xuICB9XG4gIHN0YXRpYyBfdm9sdW1lKGN1YmUsIG1vbWVudCkge1xuICAgIHJldHVybiBfV3VRdWFudC5fdm9sdW1lRmxvYXQoY3ViZSwgbW9tZW50KSB8IDA7XG4gIH1cbiAgc3RhdGljIF90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgbW9tZW50KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSBfV3VRdWFudC5fYWxwaGE6XG4gICAgICAgIHJlc3VsdCA9IG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSAobW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLSBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfV3VRdWFudC5fcmVkOlxuICAgICAgICByZXN1bHQgPSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9XdVF1YW50Ll9ncmVlbjpcbiAgICAgICAgcmVzdWx0ID0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1heGltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSAtIChtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1pbmltdW1dKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9XdVF1YW50Ll9ibHVlOlxuICAgICAgICByZXN1bHQgPSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW3Bvc2l0aW9uXSAtIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bcG9zaXRpb25dIC0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtwb3NpdGlvbl0gKyBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSAtIChtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW3Bvc2l0aW9uXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bcG9zaXRpb25dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtwb3NpdGlvbl0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wb3NzaWJsZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCB8IDA7XG4gIH1cbiAgc3RhdGljIF9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCBtb21lbnQpIHtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSBfV3VRdWFudC5fYWxwaGE6XG4gICAgICAgIHJldHVybiAtbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtICgtbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XG4gICAgICBjYXNlIF9XdVF1YW50Ll9yZWQ6XG4gICAgICAgIHJldHVybiAtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtICgtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XG4gICAgICBjYXNlIF9XdVF1YW50Ll9ncmVlbjpcbiAgICAgICAgcmV0dXJuIC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gKC1tb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcbiAgICAgIGNhc2UgX1d1UXVhbnQuX2JsdWU6XG4gICAgICAgIHJldHVybiAtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtICgtbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgX2NhbGN1bGF0ZVZhcmlhbmNlKGN1YmUpIHtcbiAgICBjb25zdCB2b2x1bWVSZWQgPSBfV3VRdWFudC5fdm9sdW1lKGN1YmUsIHRoaXMuX21vbWVudHNSZWQpO1xuICAgIGNvbnN0IHZvbHVtZUdyZWVuID0gX1d1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzR3JlZW4pO1xuICAgIGNvbnN0IHZvbHVtZUJsdWUgPSBfV3VRdWFudC5fdm9sdW1lKGN1YmUsIHRoaXMuX21vbWVudHNCbHVlKTtcbiAgICBjb25zdCB2b2x1bWVBbHBoYSA9IF9XdVF1YW50Ll92b2x1bWUoY3ViZSwgdGhpcy5fbW9tZW50c0FscGhhKTtcbiAgICBjb25zdCB2b2x1bWVNb21lbnQgPSBfV3VRdWFudC5fdm9sdW1lRmxvYXQoY3ViZSwgdGhpcy5fbW9tZW50cyk7XG4gICAgY29uc3Qgdm9sdW1lV2VpZ2h0ID0gX1d1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl93ZWlnaHRzKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHZvbHVtZVJlZCAqIHZvbHVtZVJlZCArIHZvbHVtZUdyZWVuICogdm9sdW1lR3JlZW4gKyB2b2x1bWVCbHVlICogdm9sdW1lQmx1ZSArIHZvbHVtZUFscGhhICogdm9sdW1lQWxwaGE7XG4gICAgcmV0dXJuIHZvbHVtZU1vbWVudCAtIGRpc3RhbmNlIC8gdm9sdW1lV2VpZ2h0O1xuICB9XG4gIF9tYXhpbWl6ZShjdWJlLCBkaXJlY3Rpb24sIGZpcnN0LCBsYXN0LCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCkge1xuICAgIGNvbnN0IGJvdHRvbVJlZCA9IF9XdVF1YW50Ll9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCB0aGlzLl9tb21lbnRzUmVkKSB8IDA7XG4gICAgY29uc3QgYm90dG9tR3JlZW4gPSBfV3VRdWFudC5fYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgdGhpcy5fbW9tZW50c0dyZWVuKSB8IDA7XG4gICAgY29uc3QgYm90dG9tQmx1ZSA9IF9XdVF1YW50Ll9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCB0aGlzLl9tb21lbnRzQmx1ZSkgfCAwO1xuICAgIGNvbnN0IGJvdHRvbUFscGhhID0gX1d1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX21vbWVudHNBbHBoYSkgfCAwO1xuICAgIGNvbnN0IGJvdHRvbVdlaWdodCA9IF9XdVF1YW50Ll9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCB0aGlzLl93ZWlnaHRzKSB8IDA7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgbGV0IGN1dFBvc2l0aW9uID0gLTE7XG4gICAgZm9yIChsZXQgcG9zaXRpb24gPSBmaXJzdDsgcG9zaXRpb24gPCBsYXN0OyArK3Bvc2l0aW9uKSB7XG4gICAgICBsZXQgaGFsZlJlZCA9IGJvdHRvbVJlZCArIF9XdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fbW9tZW50c1JlZCk7XG4gICAgICBsZXQgaGFsZkdyZWVuID0gYm90dG9tR3JlZW4gKyBfV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX21vbWVudHNHcmVlbik7XG4gICAgICBsZXQgaGFsZkJsdWUgPSBib3R0b21CbHVlICsgX1d1UXVhbnQuX3RvcChjdWJlLCBkaXJlY3Rpb24sIHBvc2l0aW9uLCB0aGlzLl9tb21lbnRzQmx1ZSk7XG4gICAgICBsZXQgaGFsZkFscGhhID0gYm90dG9tQWxwaGEgKyBfV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX21vbWVudHNBbHBoYSk7XG4gICAgICBsZXQgaGFsZldlaWdodCA9IGJvdHRvbVdlaWdodCArIF9XdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fd2VpZ2h0cyk7XG4gICAgICBpZiAoaGFsZldlaWdodCAhPT0gMCkge1xuICAgICAgICBsZXQgaGFsZkRpc3RhbmNlID0gaGFsZlJlZCAqIGhhbGZSZWQgKyBoYWxmR3JlZW4gKiBoYWxmR3JlZW4gKyBoYWxmQmx1ZSAqIGhhbGZCbHVlICsgaGFsZkFscGhhICogaGFsZkFscGhhO1xuICAgICAgICBsZXQgdGVtcCA9IGhhbGZEaXN0YW5jZSAvIGhhbGZXZWlnaHQ7XG4gICAgICAgIGhhbGZSZWQgPSB3aG9sZVJlZCAtIGhhbGZSZWQ7XG4gICAgICAgIGhhbGZHcmVlbiA9IHdob2xlR3JlZW4gLSBoYWxmR3JlZW47XG4gICAgICAgIGhhbGZCbHVlID0gd2hvbGVCbHVlIC0gaGFsZkJsdWU7XG4gICAgICAgIGhhbGZBbHBoYSA9IHdob2xlQWxwaGEgLSBoYWxmQWxwaGE7XG4gICAgICAgIGhhbGZXZWlnaHQgPSB3aG9sZVdlaWdodCAtIGhhbGZXZWlnaHQ7XG4gICAgICAgIGlmIChoYWxmV2VpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgaGFsZkRpc3RhbmNlID0gaGFsZlJlZCAqIGhhbGZSZWQgKyBoYWxmR3JlZW4gKiBoYWxmR3JlZW4gKyBoYWxmQmx1ZSAqIGhhbGZCbHVlICsgaGFsZkFscGhhICogaGFsZkFscGhhO1xuICAgICAgICAgIHRlbXAgKz0gaGFsZkRpc3RhbmNlIC8gaGFsZldlaWdodDtcbiAgICAgICAgICBpZiAodGVtcCA+IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGVtcDtcbiAgICAgICAgICAgIGN1dFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1heDogcmVzdWx0LCBwb3NpdGlvbjogY3V0UG9zaXRpb24gfTtcbiAgfVxuICBfY3V0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICBsZXQgZGlyZWN0aW9uO1xuICAgIGNvbnN0IHdob2xlUmVkID0gX1d1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fbW9tZW50c1JlZCk7XG4gICAgY29uc3Qgd2hvbGVHcmVlbiA9IF9XdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNHcmVlbik7XG4gICAgY29uc3Qgd2hvbGVCbHVlID0gX1d1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fbW9tZW50c0JsdWUpO1xuICAgIGNvbnN0IHdob2xlQWxwaGEgPSBfV3VRdWFudC5fdm9sdW1lKGZpcnN0LCB0aGlzLl9tb21lbnRzQWxwaGEpO1xuICAgIGNvbnN0IHdob2xlV2VpZ2h0ID0gX1d1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fd2VpZ2h0cyk7XG4gICAgY29uc3QgcmVkID0gdGhpcy5fbWF4aW1pemUoZmlyc3QsIF9XdVF1YW50Ll9yZWQsIGZpcnN0LnJlZE1pbmltdW0gKyAxLCBmaXJzdC5yZWRNYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XG4gICAgY29uc3QgZ3JlZW4gPSB0aGlzLl9tYXhpbWl6ZShmaXJzdCwgX1d1UXVhbnQuX2dyZWVuLCBmaXJzdC5ncmVlbk1pbmltdW0gKyAxLCBmaXJzdC5ncmVlbk1heGltdW0sIHdob2xlUmVkLCB3aG9sZUdyZWVuLCB3aG9sZUJsdWUsIHdob2xlQWxwaGEsIHdob2xlV2VpZ2h0KTtcbiAgICBjb25zdCBibHVlID0gdGhpcy5fbWF4aW1pemUoZmlyc3QsIF9XdVF1YW50Ll9ibHVlLCBmaXJzdC5ibHVlTWluaW11bSArIDEsIGZpcnN0LmJsdWVNYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XG4gICAgY29uc3QgYWxwaGEgPSB0aGlzLl9tYXhpbWl6ZShmaXJzdCwgX1d1UXVhbnQuX2FscGhhLCBmaXJzdC5hbHBoYU1pbmltdW0gKyAxLCBmaXJzdC5hbHBoYU1heGltdW0sIHdob2xlUmVkLCB3aG9sZUdyZWVuLCB3aG9sZUJsdWUsIHdob2xlQWxwaGEsIHdob2xlV2VpZ2h0KTtcbiAgICBpZiAoYWxwaGEubWF4ID49IHJlZC5tYXggJiYgYWxwaGEubWF4ID49IGdyZWVuLm1heCAmJiBhbHBoYS5tYXggPj0gYmx1ZS5tYXgpIHtcbiAgICAgIGRpcmVjdGlvbiA9IF9XdVF1YW50Ll9hbHBoYTtcbiAgICAgIGlmIChhbHBoYS5wb3NpdGlvbiA8IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHJlZC5tYXggPj0gYWxwaGEubWF4ICYmIHJlZC5tYXggPj0gZ3JlZW4ubWF4ICYmIHJlZC5tYXggPj0gYmx1ZS5tYXgpIHtcbiAgICAgIGRpcmVjdGlvbiA9IF9XdVF1YW50Ll9yZWQ7XG4gICAgfSBlbHNlIGlmIChncmVlbi5tYXggPj0gYWxwaGEubWF4ICYmIGdyZWVuLm1heCA+PSByZWQubWF4ICYmIGdyZWVuLm1heCA+PSBibHVlLm1heCkge1xuICAgICAgZGlyZWN0aW9uID0gX1d1UXVhbnQuX2dyZWVuO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJlY3Rpb24gPSBfV3VRdWFudC5fYmx1ZTtcbiAgICB9XG4gICAgc2Vjb25kLnJlZE1heGltdW0gPSBmaXJzdC5yZWRNYXhpbXVtO1xuICAgIHNlY29uZC5ncmVlbk1heGltdW0gPSBmaXJzdC5ncmVlbk1heGltdW07XG4gICAgc2Vjb25kLmJsdWVNYXhpbXVtID0gZmlyc3QuYmx1ZU1heGltdW07XG4gICAgc2Vjb25kLmFscGhhTWF4aW11bSA9IGZpcnN0LmFscGhhTWF4aW11bTtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSBfV3VRdWFudC5fcmVkOlxuICAgICAgICBzZWNvbmQucmVkTWluaW11bSA9IGZpcnN0LnJlZE1heGltdW0gPSByZWQucG9zaXRpb247XG4gICAgICAgIHNlY29uZC5ncmVlbk1pbmltdW0gPSBmaXJzdC5ncmVlbk1pbmltdW07XG4gICAgICAgIHNlY29uZC5ibHVlTWluaW11bSA9IGZpcnN0LmJsdWVNaW5pbXVtO1xuICAgICAgICBzZWNvbmQuYWxwaGFNaW5pbXVtID0gZmlyc3QuYWxwaGFNaW5pbXVtO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX1d1UXVhbnQuX2dyZWVuOlxuICAgICAgICBzZWNvbmQuZ3JlZW5NaW5pbXVtID0gZmlyc3QuZ3JlZW5NYXhpbXVtID0gZ3JlZW4ucG9zaXRpb247XG4gICAgICAgIHNlY29uZC5yZWRNaW5pbXVtID0gZmlyc3QucmVkTWluaW11bTtcbiAgICAgICAgc2Vjb25kLmJsdWVNaW5pbXVtID0gZmlyc3QuYmx1ZU1pbmltdW07XG4gICAgICAgIHNlY29uZC5hbHBoYU1pbmltdW0gPSBmaXJzdC5hbHBoYU1pbmltdW07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfV3VRdWFudC5fYmx1ZTpcbiAgICAgICAgc2Vjb25kLmJsdWVNaW5pbXVtID0gZmlyc3QuYmx1ZU1heGltdW0gPSBibHVlLnBvc2l0aW9uO1xuICAgICAgICBzZWNvbmQucmVkTWluaW11bSA9IGZpcnN0LnJlZE1pbmltdW07XG4gICAgICAgIHNlY29uZC5ncmVlbk1pbmltdW0gPSBmaXJzdC5ncmVlbk1pbmltdW07XG4gICAgICAgIHNlY29uZC5hbHBoYU1pbmltdW0gPSBmaXJzdC5hbHBoYU1pbmltdW07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfV3VRdWFudC5fYWxwaGE6XG4gICAgICAgIHNlY29uZC5hbHBoYU1pbmltdW0gPSBmaXJzdC5hbHBoYU1heGltdW0gPSBhbHBoYS5wb3NpdGlvbjtcbiAgICAgICAgc2Vjb25kLmJsdWVNaW5pbXVtID0gZmlyc3QuYmx1ZU1pbmltdW07XG4gICAgICAgIHNlY29uZC5yZWRNaW5pbXVtID0gZmlyc3QucmVkTWluaW11bTtcbiAgICAgICAgc2Vjb25kLmdyZWVuTWluaW11bSA9IGZpcnN0LmdyZWVuTWluaW11bTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZpcnN0LnZvbHVtZSA9IChmaXJzdC5yZWRNYXhpbXVtIC0gZmlyc3QucmVkTWluaW11bSkgKiAoZmlyc3QuZ3JlZW5NYXhpbXVtIC0gZmlyc3QuZ3JlZW5NaW5pbXVtKSAqIChmaXJzdC5ibHVlTWF4aW11bSAtIGZpcnN0LmJsdWVNaW5pbXVtKSAqIChmaXJzdC5hbHBoYU1heGltdW0gLSBmaXJzdC5hbHBoYU1pbmltdW0pO1xuICAgIHNlY29uZC52b2x1bWUgPSAoc2Vjb25kLnJlZE1heGltdW0gLSBzZWNvbmQucmVkTWluaW11bSkgKiAoc2Vjb25kLmdyZWVuTWF4aW11bSAtIHNlY29uZC5ncmVlbk1pbmltdW0pICogKHNlY29uZC5ibHVlTWF4aW11bSAtIHNlY29uZC5ibHVlTWluaW11bSkgKiAoc2Vjb25kLmFscGhhTWF4aW11bSAtIHNlY29uZC5hbHBoYU1pbmltdW0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9pbml0aWFsaXplKGNvbG9ycykge1xuICAgIHRoaXMuX2NvbG9ycyA9IGNvbG9ycztcbiAgICB0aGlzLl9jdWJlcyA9IFtdO1xuICAgIGZvciAobGV0IGN1YmVJbmRleCA9IDA7IGN1YmVJbmRleCA8IGNvbG9yczsgY3ViZUluZGV4KyspIHtcbiAgICAgIHRoaXMuX2N1YmVzW2N1YmVJbmRleF0gPSBuZXcgV3VDb2xvckN1YmUoKTtcbiAgICB9XG4gICAgdGhpcy5fY3ViZXNbMF0ucmVkTWluaW11bSA9IDA7XG4gICAgdGhpcy5fY3ViZXNbMF0uZ3JlZW5NaW5pbXVtID0gMDtcbiAgICB0aGlzLl9jdWJlc1swXS5ibHVlTWluaW11bSA9IDA7XG4gICAgdGhpcy5fY3ViZXNbMF0uYWxwaGFNaW5pbXVtID0gMDtcbiAgICB0aGlzLl9jdWJlc1swXS5yZWRNYXhpbXVtID0gdGhpcy5fbWF4U2lkZUluZGV4O1xuICAgIHRoaXMuX2N1YmVzWzBdLmdyZWVuTWF4aW11bSA9IHRoaXMuX21heFNpZGVJbmRleDtcbiAgICB0aGlzLl9jdWJlc1swXS5ibHVlTWF4aW11bSA9IHRoaXMuX21heFNpZGVJbmRleDtcbiAgICB0aGlzLl9jdWJlc1swXS5hbHBoYU1heGltdW0gPSB0aGlzLl9hbHBoYU1heFNpZGVJbmRleDtcbiAgICB0aGlzLl93ZWlnaHRzID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICB0aGlzLl9tb21lbnRzUmVkID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICB0aGlzLl9tb21lbnRzR3JlZW4gPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xuICAgIHRoaXMuX21vbWVudHNCbHVlID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICB0aGlzLl9tb21lbnRzQWxwaGEgPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xuICAgIHRoaXMuX21vbWVudHMgPSBjcmVhdGVBcnJheTREKHRoaXMuX2FscGhhU2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgZm9yIChsZXQgdGFibGVJbmRleCA9IDA7IHRhYmxlSW5kZXggPCAyNTY7ICsrdGFibGVJbmRleCkge1xuICAgICAgdGhpcy5fdGFibGVbdGFibGVJbmRleF0gPSB0YWJsZUluZGV4ICogdGFibGVJbmRleDtcbiAgICB9XG4gICAgdGhpcy5fcGl4ZWxzID0gW107XG4gIH1cbiAgX3NldFF1YWxpdHkoc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbCA9IDUpIHtcbiAgICB0aGlzLl9zaWduaWZpY2FudEJpdHNQZXJDaGFubmVsID0gc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbDtcbiAgICB0aGlzLl9tYXhTaWRlSW5kZXggPSAxIDw8IHRoaXMuX3NpZ25pZmljYW50Qml0c1BlckNoYW5uZWw7XG4gICAgdGhpcy5fYWxwaGFNYXhTaWRlSW5kZXggPSB0aGlzLl9tYXhTaWRlSW5kZXg7XG4gICAgdGhpcy5fc2lkZVNpemUgPSB0aGlzLl9tYXhTaWRlSW5kZXggKyAxO1xuICAgIHRoaXMuX2FscGhhU2lkZVNpemUgPSB0aGlzLl9hbHBoYU1heFNpZGVJbmRleCArIDE7XG4gIH1cbn07XG52YXIgV3VRdWFudCA9IF9XdVF1YW50O1xuX19wdWJsaWNGaWVsZChXdVF1YW50LCBcIl9hbHBoYVwiLCAzKTtcbl9fcHVibGljRmllbGQoV3VRdWFudCwgXCJfcmVkXCIsIDIpO1xuX19wdWJsaWNGaWVsZChXdVF1YW50LCBcIl9ncmVlblwiLCAxKTtcbl9fcHVibGljRmllbGQoV3VRdWFudCwgXCJfYmx1ZVwiLCAwKTtcblxuLy8gc3JjL2ltYWdlL2luZGV4LnRzXG52YXIgaW1hZ2VfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW1hZ2VfZXhwb3J0cywge1xuICBBYnN0cmFjdEltYWdlUXVhbnRpemVyOiAoKSA9PiBBYnN0cmFjdEltYWdlUXVhbnRpemVyLFxuICBFcnJvckRpZmZ1c2lvbkFycmF5OiAoKSA9PiBFcnJvckRpZmZ1c2lvbkFycmF5LFxuICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsOiAoKSA9PiBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsLFxuICBFcnJvckRpZmZ1c2lvblJpZW1lcnNtYTogKCkgPT4gRXJyb3JEaWZmdXNpb25SaWVtZXJzbWEsXG4gIE5lYXJlc3RDb2xvcjogKCkgPT4gTmVhcmVzdENvbG9yXG59KTtcblxuLy8gc3JjL2ltYWdlL2ltYWdlUXVhbnRpemVyLnRzXG52YXIgQWJzdHJhY3RJbWFnZVF1YW50aXplciA9IGNsYXNzIHtcbiAgcXVhbnRpemVTeW5jKHBvaW50Q29udGFpbmVyLCBwYWxldHRlKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLnF1YW50aXplKHBvaW50Q29udGFpbmVyLCBwYWxldHRlKSkge1xuICAgICAgaWYgKHZhbHVlLnBvaW50Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5wb2ludENvbnRhaW5lcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9pbWFnZS9uZWFyZXN0Q29sb3IudHNcbnZhciBOZWFyZXN0Q29sb3IgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIge1xuICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcikge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9kaXN0YW5jZVwiKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xuICB9XG4gICpxdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkge1xuICAgIGNvbnN0IHBvaW50QXJyYXkgPSBwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XG4gICAgY29uc3Qgd2lkdGggPSBwb2ludENvbnRhaW5lci5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHBvaW50Q29udGFpbmVyLmdldEhlaWdodCgpO1xuICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUHJvZ3Jlc3NUcmFja2VyKGhlaWdodCwgOTkpO1xuICAgIGZvciAobGV0IHkyID0gMDsgeTIgPCBoZWlnaHQ7IHkyKyspIHtcbiAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeSh5MikpIHtcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB4MiA9IDAsIGlkeCA9IHkyICogd2lkdGg7IHgyIDwgd2lkdGg7IHgyKyssIGlkeCsrKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRBcnJheVtpZHhdO1xuICAgICAgICBwb2ludC5mcm9tKHBhbGV0dGUuZ2V0TmVhcmVzdENvbG9yKHRoaXMuX2Rpc3RhbmNlLCBwb2ludCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB5aWVsZCB7XG4gICAgICBwb2ludENvbnRhaW5lcixcbiAgICAgIHByb2dyZXNzOiAxMDBcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvaW1hZ2UvYXJyYXkudHNcbnZhciBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsID0gLyogQF9fUFVSRV9fICovICgoRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDIpID0+IHtcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbXCJGbG95ZFN0ZWluYmVyZ1wiXSA9IDBdID0gXCJGbG95ZFN0ZWluYmVyZ1wiO1xuICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltcIkZhbHNlRmxveWRTdGVpbmJlcmdcIl0gPSAxXSA9IFwiRmFsc2VGbG95ZFN0ZWluYmVyZ1wiO1xuICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltcIlN0dWNraVwiXSA9IDJdID0gXCJTdHVja2lcIjtcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbXCJBdGtpbnNvblwiXSA9IDNdID0gXCJBdGtpbnNvblwiO1xuICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltcIkphcnZpc1wiXSA9IDRdID0gXCJKYXJ2aXNcIjtcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbXCJCdXJrZXNcIl0gPSA1XSA9IFwiQnVya2VzXCI7XG4gIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW1wiU2llcnJhXCJdID0gNl0gPSBcIlNpZXJyYVwiO1xuICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltcIlR3b1NpZXJyYVwiXSA9IDddID0gXCJUd29TaWVycmFcIjtcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbXCJTaWVycmFMaXRlXCJdID0gOF0gPSBcIlNpZXJyYUxpdGVcIjtcbiAgcmV0dXJuIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyO1xufSkoRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbCB8fCB7fSk7XG52YXIgRXJyb3JEaWZmdXNpb25BcnJheSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RJbWFnZVF1YW50aXplciB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBrZXJuZWwsIHNlcnBlbnRpbmUgPSB0cnVlLCBtaW5pbXVtQ29sb3JEaXN0YW5jZVRvRGl0aGVyID0gMCwgY2FsY3VsYXRlRXJyb3JMaWtlR0lNUCA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX21pbkNvbG9yRGlzdGFuY2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9zZXJwZW50aW5lXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfa2VybmVsXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY2FsY3VsYXRlRXJyb3JMaWtlR0lNUFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2Rpc3RhbmNlXCIpO1xuICAgIHRoaXMuX3NldEtlcm5lbChrZXJuZWwpO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gY29sb3JEaXN0YW5jZUNhbGN1bGF0b3I7XG4gICAgdGhpcy5fbWluQ29sb3JEaXN0YW5jZSA9IG1pbmltdW1Db2xvckRpc3RhbmNlVG9EaXRoZXI7XG4gICAgdGhpcy5fc2VycGVudGluZSA9IHNlcnBlbnRpbmU7XG4gICAgdGhpcy5fY2FsY3VsYXRlRXJyb3JMaWtlR0lNUCA9IGNhbGN1bGF0ZUVycm9yTGlrZUdJTVA7XG4gIH1cbiAgKnF1YW50aXplKHBvaW50Q29udGFpbmVyLCBwYWxldHRlKSB7XG4gICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcbiAgICBjb25zdCBvcmlnaW5hbFBvaW50ID0gbmV3IFBvaW50KCk7XG4gICAgY29uc3Qgd2lkdGggPSBwb2ludENvbnRhaW5lci5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHBvaW50Q29udGFpbmVyLmdldEhlaWdodCgpO1xuICAgIGNvbnN0IGVycm9yTGluZXMgPSBbXTtcbiAgICBsZXQgZGlyID0gMTtcbiAgICBsZXQgbWF4RXJyb3JMaW5lcyA9IDE7XG4gICAgZm9yIChjb25zdCBrZXJuZWwgb2YgdGhpcy5fa2VybmVsKSB7XG4gICAgICBjb25zdCBrZXJuZWxFcnJvckxpbmVzID0ga2VybmVsWzJdICsgMTtcbiAgICAgIGlmIChtYXhFcnJvckxpbmVzIDwga2VybmVsRXJyb3JMaW5lcylcbiAgICAgICAgbWF4RXJyb3JMaW5lcyA9IGtlcm5lbEVycm9yTGluZXM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4RXJyb3JMaW5lczsgaSsrKSB7XG4gICAgICB0aGlzLl9maWxsRXJyb3JMaW5lKGVycm9yTGluZXNbaV0gPSBbXSwgd2lkdGgpO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihoZWlnaHQsIDk5KTtcbiAgICBmb3IgKGxldCB5MiA9IDA7IHkyIDwgaGVpZ2h0OyB5MisrKSB7XG4gICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkoeTIpKSB7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NlcnBlbnRpbmUpXG4gICAgICAgIGRpciAqPSAtMTtcbiAgICAgIGNvbnN0IGxuaSA9IHkyICogd2lkdGg7XG4gICAgICBjb25zdCB4U3RhcnQgPSBkaXIgPT09IDEgPyAwIDogd2lkdGggLSAxO1xuICAgICAgY29uc3QgeEVuZCA9IGRpciA9PT0gMSA/IHdpZHRoIDogLTE7XG4gICAgICB0aGlzLl9maWxsRXJyb3JMaW5lKGVycm9yTGluZXNbMF0sIHdpZHRoKTtcbiAgICAgIGVycm9yTGluZXMucHVzaChlcnJvckxpbmVzLnNoaWZ0KCkpO1xuICAgICAgY29uc3QgZXJyb3JMaW5lID0gZXJyb3JMaW5lc1swXTtcbiAgICAgIGZvciAobGV0IHgyID0geFN0YXJ0LCBpZHggPSBsbmkgKyB4U3RhcnQ7IHgyICE9PSB4RW5kOyB4MiArPSBkaXIsIGlkeCArPSBkaXIpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludEFycmF5W2lkeF07XG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JMaW5lW3gyXTtcbiAgICAgICAgb3JpZ2luYWxQb2ludC5mcm9tKHBvaW50KTtcbiAgICAgICAgY29uc3QgY29ycmVjdGVkUG9pbnQgPSBQb2ludC5jcmVhdGVCeVJHQkEoaW5SYW5nZTB0bzI1NVJvdW5kZWQocG9pbnQuciArIGVycm9yWzBdKSwgaW5SYW5nZTB0bzI1NVJvdW5kZWQocG9pbnQuZyArIGVycm9yWzFdKSwgaW5SYW5nZTB0bzI1NVJvdW5kZWQocG9pbnQuYiArIGVycm9yWzJdKSwgaW5SYW5nZTB0bzI1NVJvdW5kZWQocG9pbnQuYSArIGVycm9yWzNdKSk7XG4gICAgICAgIGNvbnN0IHBhbGV0dGVQb2ludCA9IHBhbGV0dGUuZ2V0TmVhcmVzdENvbG9yKHRoaXMuX2Rpc3RhbmNlLCBjb3JyZWN0ZWRQb2ludCk7XG4gICAgICAgIHBvaW50LmZyb20ocGFsZXR0ZVBvaW50KTtcbiAgICAgICAgaWYgKHRoaXMuX21pbkNvbG9yRGlzdGFuY2UpIHtcbiAgICAgICAgICBjb25zdCBkaXN0ID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlTm9ybWFsaXplZChvcmlnaW5hbFBvaW50LCBwYWxldHRlUG9pbnQpO1xuICAgICAgICAgIGlmIChkaXN0IDwgdGhpcy5fbWluQ29sb3JEaXN0YW5jZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcjtcbiAgICAgICAgbGV0IGVnO1xuICAgICAgICBsZXQgZWI7XG4gICAgICAgIGxldCBlYTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGN1bGF0ZUVycm9yTGlrZUdJTVApIHtcbiAgICAgICAgICBlciA9IGNvcnJlY3RlZFBvaW50LnIgLSBwYWxldHRlUG9pbnQucjtcbiAgICAgICAgICBlZyA9IGNvcnJlY3RlZFBvaW50LmcgLSBwYWxldHRlUG9pbnQuZztcbiAgICAgICAgICBlYiA9IGNvcnJlY3RlZFBvaW50LmIgLSBwYWxldHRlUG9pbnQuYjtcbiAgICAgICAgICBlYSA9IGNvcnJlY3RlZFBvaW50LmEgLSBwYWxldHRlUG9pbnQuYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlciA9IG9yaWdpbmFsUG9pbnQuciAtIHBhbGV0dGVQb2ludC5yO1xuICAgICAgICAgIGVnID0gb3JpZ2luYWxQb2ludC5nIC0gcGFsZXR0ZVBvaW50Lmc7XG4gICAgICAgICAgZWIgPSBvcmlnaW5hbFBvaW50LmIgLSBwYWxldHRlUG9pbnQuYjtcbiAgICAgICAgICBlYSA9IG9yaWdpbmFsUG9pbnQuYSAtIHBhbGV0dGVQb2ludC5hO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRTdGFydCA9IGRpciA9PT0gMSA/IDAgOiB0aGlzLl9rZXJuZWwubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgZEVuZCA9IGRpciA9PT0gMSA/IHRoaXMuX2tlcm5lbC5sZW5ndGggOiAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGRTdGFydDsgaSAhPT0gZEVuZDsgaSArPSBkaXIpIHtcbiAgICAgICAgICBjb25zdCB4MSA9IHRoaXMuX2tlcm5lbFtpXVsxXSAqIGRpcjtcbiAgICAgICAgICBjb25zdCB5MSA9IHRoaXMuX2tlcm5lbFtpXVsyXTtcbiAgICAgICAgICBpZiAoeDEgKyB4MiA+PSAwICYmIHgxICsgeDIgPCB3aWR0aCAmJiB5MSArIHkyID49IDAgJiYgeTEgKyB5MiA8IGhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuX2tlcm5lbFtpXVswXTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlcnJvckxpbmVzW3kxXVt4MSArIHgyXTtcbiAgICAgICAgICAgIGVbMF0gKz0gZXIgKiBkO1xuICAgICAgICAgICAgZVsxXSArPSBlZyAqIGQ7XG4gICAgICAgICAgICBlWzJdICs9IGViICogZDtcbiAgICAgICAgICAgIGVbM10gKz0gZWEgKiBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB5aWVsZCB7XG4gICAgICBwb2ludENvbnRhaW5lcixcbiAgICAgIHByb2dyZXNzOiAxMDBcbiAgICB9O1xuICB9XG4gIF9maWxsRXJyb3JMaW5lKGVycm9yTGluZSwgd2lkdGgpIHtcbiAgICBpZiAoZXJyb3JMaW5lLmxlbmd0aCA+IHdpZHRoKSB7XG4gICAgICBlcnJvckxpbmUubGVuZ3RoID0gd2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IGwgPSBlcnJvckxpbmUubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGVycm9yTGluZVtpXTtcbiAgICAgIGVycm9yWzBdID0gZXJyb3JbMV0gPSBlcnJvclsyXSA9IGVycm9yWzNdID0gMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGw7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICBlcnJvckxpbmVbaV0gPSBbMCwgMCwgMCwgMF07XG4gICAgfVxuICB9XG4gIF9zZXRLZXJuZWwoa2VybmVsKSB7XG4gICAgc3dpdGNoIChrZXJuZWwpIHtcbiAgICAgIGNhc2UgMCAvKiBGbG95ZFN0ZWluYmVyZyAqLzpcbiAgICAgICAgdGhpcy5fa2VybmVsID0gW1xuICAgICAgICAgIFs3IC8gMTYsIDEsIDBdLFxuICAgICAgICAgIFszIC8gMTYsIC0xLCAxXSxcbiAgICAgICAgICBbNSAvIDE2LCAwLCAxXSxcbiAgICAgICAgICBbMSAvIDE2LCAxLCAxXVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBGYWxzZUZsb3lkU3RlaW5iZXJnICovOlxuICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXG4gICAgICAgICAgWzMgLyA4LCAxLCAwXSxcbiAgICAgICAgICBbMyAvIDgsIDAsIDFdLFxuICAgICAgICAgIFsyIC8gOCwgMSwgMV1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIgLyogU3R1Y2tpICovOlxuICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXG4gICAgICAgICAgWzggLyA0MiwgMSwgMF0sXG4gICAgICAgICAgWzQgLyA0MiwgMiwgMF0sXG4gICAgICAgICAgWzIgLyA0MiwgLTIsIDFdLFxuICAgICAgICAgIFs0IC8gNDIsIC0xLCAxXSxcbiAgICAgICAgICBbOCAvIDQyLCAwLCAxXSxcbiAgICAgICAgICBbNCAvIDQyLCAxLCAxXSxcbiAgICAgICAgICBbMiAvIDQyLCAyLCAxXSxcbiAgICAgICAgICBbMSAvIDQyLCAtMiwgMl0sXG4gICAgICAgICAgWzIgLyA0MiwgLTEsIDJdLFxuICAgICAgICAgIFs0IC8gNDIsIDAsIDJdLFxuICAgICAgICAgIFsyIC8gNDIsIDEsIDJdLFxuICAgICAgICAgIFsxIC8gNDIsIDIsIDJdXG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzIC8qIEF0a2luc29uICovOlxuICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXG4gICAgICAgICAgWzEgLyA4LCAxLCAwXSxcbiAgICAgICAgICBbMSAvIDgsIDIsIDBdLFxuICAgICAgICAgIFsxIC8gOCwgLTEsIDFdLFxuICAgICAgICAgIFsxIC8gOCwgMCwgMV0sXG4gICAgICAgICAgWzEgLyA4LCAxLCAxXSxcbiAgICAgICAgICBbMSAvIDgsIDAsIDJdXG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0IC8qIEphcnZpcyAqLzpcbiAgICAgICAgdGhpcy5fa2VybmVsID0gW1xuICAgICAgICAgIFs3IC8gNDgsIDEsIDBdLFxuICAgICAgICAgIFs1IC8gNDgsIDIsIDBdLFxuICAgICAgICAgIFszIC8gNDgsIC0yLCAxXSxcbiAgICAgICAgICBbNSAvIDQ4LCAtMSwgMV0sXG4gICAgICAgICAgWzcgLyA0OCwgMCwgMV0sXG4gICAgICAgICAgWzUgLyA0OCwgMSwgMV0sXG4gICAgICAgICAgWzMgLyA0OCwgMiwgMV0sXG4gICAgICAgICAgWzEgLyA0OCwgLTIsIDJdLFxuICAgICAgICAgIFszIC8gNDgsIC0xLCAyXSxcbiAgICAgICAgICBbNSAvIDQ4LCAwLCAyXSxcbiAgICAgICAgICBbMyAvIDQ4LCAxLCAyXSxcbiAgICAgICAgICBbMSAvIDQ4LCAyLCAyXVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNSAvKiBCdXJrZXMgKi86XG4gICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcbiAgICAgICAgICBbOCAvIDMyLCAxLCAwXSxcbiAgICAgICAgICBbNCAvIDMyLCAyLCAwXSxcbiAgICAgICAgICBbMiAvIDMyLCAtMiwgMV0sXG4gICAgICAgICAgWzQgLyAzMiwgLTEsIDFdLFxuICAgICAgICAgIFs4IC8gMzIsIDAsIDFdLFxuICAgICAgICAgIFs0IC8gMzIsIDEsIDFdLFxuICAgICAgICAgIFsyIC8gMzIsIDIsIDFdXG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2IC8qIFNpZXJyYSAqLzpcbiAgICAgICAgdGhpcy5fa2VybmVsID0gW1xuICAgICAgICAgIFs1IC8gMzIsIDEsIDBdLFxuICAgICAgICAgIFszIC8gMzIsIDIsIDBdLFxuICAgICAgICAgIFsyIC8gMzIsIC0yLCAxXSxcbiAgICAgICAgICBbNCAvIDMyLCAtMSwgMV0sXG4gICAgICAgICAgWzUgLyAzMiwgMCwgMV0sXG4gICAgICAgICAgWzQgLyAzMiwgMSwgMV0sXG4gICAgICAgICAgWzIgLyAzMiwgMiwgMV0sXG4gICAgICAgICAgWzIgLyAzMiwgLTEsIDJdLFxuICAgICAgICAgIFszIC8gMzIsIDAsIDJdLFxuICAgICAgICAgIFsyIC8gMzIsIDEsIDJdXG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA3IC8qIFR3b1NpZXJyYSAqLzpcbiAgICAgICAgdGhpcy5fa2VybmVsID0gW1xuICAgICAgICAgIFs0IC8gMTYsIDEsIDBdLFxuICAgICAgICAgIFszIC8gMTYsIDIsIDBdLFxuICAgICAgICAgIFsxIC8gMTYsIC0yLCAxXSxcbiAgICAgICAgICBbMiAvIDE2LCAtMSwgMV0sXG4gICAgICAgICAgWzMgLyAxNiwgMCwgMV0sXG4gICAgICAgICAgWzIgLyAxNiwgMSwgMV0sXG4gICAgICAgICAgWzEgLyAxNiwgMiwgMV1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDggLyogU2llcnJhTGl0ZSAqLzpcbiAgICAgICAgdGhpcy5fa2VybmVsID0gW1xuICAgICAgICAgIFsyIC8gNCwgMSwgMF0sXG4gICAgICAgICAgWzEgLyA0LCAtMSwgMV0sXG4gICAgICAgICAgWzEgLyA0LCAwLCAxXVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3JEaWZmdXNpb25BcnJheTogdW5rbm93biBrZXJuZWwgPSAke2tlcm5lbH1gKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9pbWFnZS9zcGFjZUZpbGxpbmdDdXJ2ZXMvaGlsYmVydEN1cnZlLnRzXG5mdW5jdGlvbiogaGlsYmVydEN1cnZlKHdpZHRoLCBoZWlnaHQsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IG1heEJvdW5kID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGxldmVsID0gTWF0aC5mbG9vcihNYXRoLmxvZyhtYXhCb3VuZCkgLyBNYXRoLmxvZygyKSArIDEpO1xuICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcih3aWR0aCAqIGhlaWdodCwgOTkpO1xuICBjb25zdCBkYXRhID0ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsZXZlbCxcbiAgICBjYWxsYmFjayxcbiAgICB0cmFja2VyLFxuICAgIGluZGV4OiAwLFxuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMSAvKiBVUCAqLyk7XG4gIHZpc2l0KGRhdGEsIDAgLyogTk9ORSAqLyk7XG59XG5mdW5jdGlvbiogd2Fsa0hpbGJlcnQoZGF0YSwgZGlyZWN0aW9uKSB7XG4gIGlmIChkYXRhLmxldmVsIDwgMSlcbiAgICByZXR1cm47XG4gIGlmIChkYXRhLnRyYWNrZXIuc2hvdWxkTm90aWZ5KGRhdGEuaW5kZXgpKSB7XG4gICAgeWllbGQgeyBwcm9ncmVzczogZGF0YS50cmFja2VyLnByb2dyZXNzIH07XG4gIH1cbiAgZGF0YS5sZXZlbC0tO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgMiAvKiBMRUZUICovOlxuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDEgLyogVVAgKi8pO1xuICAgICAgdmlzaXQoZGF0YSwgMyAvKiBSSUdIVCAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMiAvKiBMRUZUICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDQgLyogRE9XTiAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMiAvKiBMRUZUICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDIgLyogTEVGVCAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgNCAvKiBET1dOICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMyAvKiBSSUdIVCAqLzpcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCA0IC8qIERPV04gKi8pO1xuICAgICAgdmlzaXQoZGF0YSwgMiAvKiBMRUZUICovKTtcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCAzIC8qIFJJR0hUICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDEgLyogVVAgKi8pO1xuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDMgLyogUklHSFQgKi8pO1xuICAgICAgdmlzaXQoZGF0YSwgMyAvKiBSSUdIVCAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMSAvKiBVUCAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEgLyogVVAgKi86XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMiAvKiBMRUZUICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDQgLyogRE9XTiAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMSAvKiBVUCAqLyk7XG4gICAgICB2aXNpdChkYXRhLCAzIC8qIFJJR0hUICovKTtcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCAxIC8qIFVQICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDEgLyogVVAgKi8pO1xuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDMgLyogUklHSFQgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0IC8qIERPV04gKi86XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMyAvKiBSSUdIVCAqLyk7XG4gICAgICB2aXNpdChkYXRhLCAxIC8qIFVQICovKTtcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCA0IC8qIERPV04gKi8pO1xuICAgICAgdmlzaXQoZGF0YSwgMiAvKiBMRUZUICovKTtcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCA0IC8qIERPV04gKi8pO1xuICAgICAgdmlzaXQoZGF0YSwgNCAvKiBET1dOICovKTtcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCAyIC8qIExFRlQgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG4gIGRhdGEubGV2ZWwrKztcbn1cbmZ1bmN0aW9uIHZpc2l0KGRhdGEsIGRpcmVjdGlvbikge1xuICBpZiAoZGF0YS54ID49IDAgJiYgZGF0YS54IDwgZGF0YS53aWR0aCAmJiBkYXRhLnkgPj0gMCAmJiBkYXRhLnkgPCBkYXRhLmhlaWdodCkge1xuICAgIGRhdGEuY2FsbGJhY2soZGF0YS54LCBkYXRhLnkpO1xuICAgIGRhdGEuaW5kZXgrKztcbiAgfVxuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgMiAvKiBMRUZUICovOlxuICAgICAgZGF0YS54LS07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDMgLyogUklHSFQgKi86XG4gICAgICBkYXRhLngrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMSAvKiBVUCAqLzpcbiAgICAgIGRhdGEueS0tO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0IC8qIERPV04gKi86XG4gICAgICBkYXRhLnkrKztcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8vIHNyYy9pbWFnZS9yaWVtZXJzbWEudHNcbnZhciBFcnJvckRpZmZ1c2lvblJpZW1lcnNtYSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RJbWFnZVF1YW50aXplciB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBlcnJvclF1ZXVlU2l6ZSA9IDE2LCBlcnJvclByb3BhZ2F0aW9uID0gMSkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9kaXN0YW5jZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3dlaWdodHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9lcnJvclF1ZXVlU2l6ZVwiKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xuICAgIHRoaXMuX2Vycm9yUXVldWVTaXplID0gZXJyb3JRdWV1ZVNpemU7XG4gICAgdGhpcy5fd2VpZ2h0cyA9IEVycm9yRGlmZnVzaW9uUmllbWVyc21hLl9jcmVhdGVXZWlnaHRzKGVycm9yUHJvcGFnYXRpb24sIGVycm9yUXVldWVTaXplKTtcbiAgfVxuICAqcXVhbnRpemUocG9pbnRDb250YWluZXIsIHBhbGV0dGUpIHtcbiAgICBjb25zdCBwb2ludEFycmF5ID0gcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xuICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCBlcnJvclF1ZXVlID0gW107XG4gICAgbGV0IGhlYWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JRdWV1ZVNpemU7IGkrKykge1xuICAgICAgZXJyb3JRdWV1ZVtpXSA9IHsgcjogMCwgZzogMCwgYjogMCwgYTogMCB9O1xuICAgIH1cbiAgICB5aWVsZCogaGlsYmVydEN1cnZlKHdpZHRoLCBoZWlnaHQsICh4MiwgeTIpID0+IHtcbiAgICAgIGNvbnN0IHAgPSBwb2ludEFycmF5W3gyICsgeTIgKiB3aWR0aF07XG4gICAgICBsZXQgeyByLCBnLCBiLCBhIH0gPSBwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9lcnJvclF1ZXVlU2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IHRoaXMuX3dlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IGUgPSBlcnJvclF1ZXVlWyhpICsgaGVhZCkgJSB0aGlzLl9lcnJvclF1ZXVlU2l6ZV07XG4gICAgICAgIHIgKz0gZS5yICogd2VpZ2h0O1xuICAgICAgICBnICs9IGUuZyAqIHdlaWdodDtcbiAgICAgICAgYiArPSBlLmIgKiB3ZWlnaHQ7XG4gICAgICAgIGEgKz0gZS5hICogd2VpZ2h0O1xuICAgICAgfVxuICAgICAgY29uc3QgY29ycmVjdGVkUG9pbnQgPSBQb2ludC5jcmVhdGVCeVJHQkEoaW5SYW5nZTB0bzI1NVJvdW5kZWQociksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKGcpLCBpblJhbmdlMHRvMjU1Um91bmRlZChiKSwgaW5SYW5nZTB0bzI1NVJvdW5kZWQoYSkpO1xuICAgICAgY29uc3QgcXVhbnRpemVkUG9pbnQgPSBwYWxldHRlLmdldE5lYXJlc3RDb2xvcih0aGlzLl9kaXN0YW5jZSwgY29ycmVjdGVkUG9pbnQpO1xuICAgICAgaGVhZCA9IChoZWFkICsgMSkgJSB0aGlzLl9lcnJvclF1ZXVlU2l6ZTtcbiAgICAgIGNvbnN0IHRhaWwgPSAoaGVhZCArIHRoaXMuX2Vycm9yUXVldWVTaXplIC0gMSkgJSB0aGlzLl9lcnJvclF1ZXVlU2l6ZTtcbiAgICAgIGVycm9yUXVldWVbdGFpbF0uciA9IHAuciAtIHF1YW50aXplZFBvaW50LnI7XG4gICAgICBlcnJvclF1ZXVlW3RhaWxdLmcgPSBwLmcgLSBxdWFudGl6ZWRQb2ludC5nO1xuICAgICAgZXJyb3JRdWV1ZVt0YWlsXS5iID0gcC5iIC0gcXVhbnRpemVkUG9pbnQuYjtcbiAgICAgIGVycm9yUXVldWVbdGFpbF0uYSA9IHAuYSAtIHF1YW50aXplZFBvaW50LmE7XG4gICAgICBwLmZyb20ocXVhbnRpemVkUG9pbnQpO1xuICAgIH0pO1xuICAgIHlpZWxkIHtcbiAgICAgIHBvaW50Q29udGFpbmVyLFxuICAgICAgcHJvZ3Jlc3M6IDEwMFxuICAgIH07XG4gIH1cbiAgc3RhdGljIF9jcmVhdGVXZWlnaHRzKGVycm9yUHJvcGFnYXRpb24sIGVycm9yUXVldWVTaXplKSB7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IFtdO1xuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLmV4cChNYXRoLmxvZyhlcnJvclF1ZXVlU2l6ZSkgLyAoZXJyb3JRdWV1ZVNpemUgLSAxKSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG5leHQgPSAxOyBpIDwgZXJyb3JRdWV1ZVNpemU7IGkrKykge1xuICAgICAgd2VpZ2h0c1tpXSA9IChuZXh0ICsgMC41IHwgMCkgLyBlcnJvclF1ZXVlU2l6ZSAqIGVycm9yUHJvcGFnYXRpb247XG4gICAgICBuZXh0ICo9IG11bHRpcGxpZXI7XG4gICAgfVxuICAgIHJldHVybiB3ZWlnaHRzO1xuICB9XG59O1xuXG4vLyBzcmMvcXVhbGl0eS9pbmRleC50c1xudmFyIHF1YWxpdHlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocXVhbGl0eV9leHBvcnRzLCB7XG4gIHNzaW06ICgpID0+IHNzaW1cbn0pO1xuXG4vLyBzcmMvcXVhbGl0eS9zc2ltLnRzXG52YXIgSzEgPSAwLjAxO1xudmFyIEsyID0gMC4wMztcbmZ1bmN0aW9uIHNzaW0oaW1hZ2UxLCBpbWFnZTIpIHtcbiAgaWYgKGltYWdlMS5nZXRIZWlnaHQoKSAhPT0gaW1hZ2UyLmdldEhlaWdodCgpIHx8IGltYWdlMS5nZXRXaWR0aCgpICE9PSBpbWFnZTIuZ2V0V2lkdGgoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlcyBoYXZlIGRpZmZlcmVudCBzaXplcyFcIik7XG4gIH1cbiAgY29uc3QgYml0c1BlckNvbXBvbmVudCA9IDg7XG4gIGNvbnN0IEwgPSAoMSA8PCBiaXRzUGVyQ29tcG9uZW50KSAtIDE7XG4gIGNvbnN0IGMxID0gKEsxICogTCkgKiogMjtcbiAgY29uc3QgYzIgPSAoSzIgKiBMKSAqKiAyO1xuICBsZXQgbnVtV2luZG93cyA9IDA7XG4gIGxldCBtc3NpbSA9IDA7XG4gIGl0ZXJhdGUoaW1hZ2UxLCBpbWFnZTIsIChsdW1hVmFsdWVzMSwgbHVtYVZhbHVlczIsIGF2ZXJhZ2VMdW1hVmFsdWUxLCBhdmVyYWdlTHVtYVZhbHVlMikgPT4ge1xuICAgIGxldCBzaWd4eSA9IDA7XG4gICAgbGV0IHNpZ3NxeCA9IDA7XG4gICAgbGV0IHNpZ3NxeSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsdW1hVmFsdWVzMS5sZW5ndGg7IGkrKykge1xuICAgICAgc2lnc3F4ICs9IChsdW1hVmFsdWVzMVtpXSAtIGF2ZXJhZ2VMdW1hVmFsdWUxKSAqKiAyO1xuICAgICAgc2lnc3F5ICs9IChsdW1hVmFsdWVzMltpXSAtIGF2ZXJhZ2VMdW1hVmFsdWUyKSAqKiAyO1xuICAgICAgc2lneHkgKz0gKGx1bWFWYWx1ZXMxW2ldIC0gYXZlcmFnZUx1bWFWYWx1ZTEpICogKGx1bWFWYWx1ZXMyW2ldIC0gYXZlcmFnZUx1bWFWYWx1ZTIpO1xuICAgIH1cbiAgICBjb25zdCBudW1QaXhlbHNJbldpbiA9IGx1bWFWYWx1ZXMxLmxlbmd0aCAtIDE7XG4gICAgc2lnc3F4IC89IG51bVBpeGVsc0luV2luO1xuICAgIHNpZ3NxeSAvPSBudW1QaXhlbHNJbldpbjtcbiAgICBzaWd4eSAvPSBudW1QaXhlbHNJbldpbjtcbiAgICBjb25zdCBudW1lcmF0b3IgPSAoMiAqIGF2ZXJhZ2VMdW1hVmFsdWUxICogYXZlcmFnZUx1bWFWYWx1ZTIgKyBjMSkgKiAoMiAqIHNpZ3h5ICsgYzIpO1xuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gKGF2ZXJhZ2VMdW1hVmFsdWUxICoqIDIgKyBhdmVyYWdlTHVtYVZhbHVlMiAqKiAyICsgYzEpICogKHNpZ3NxeCArIHNpZ3NxeSArIGMyKTtcbiAgICBjb25zdCBzc2ltMiA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgIG1zc2ltICs9IHNzaW0yO1xuICAgIG51bVdpbmRvd3MrKztcbiAgfSk7XG4gIHJldHVybiBtc3NpbSAvIG51bVdpbmRvd3M7XG59XG5mdW5jdGlvbiBpdGVyYXRlKGltYWdlMSwgaW1hZ2UyLCBjYWxsYmFjaykge1xuICBjb25zdCB3aW5kb3dTaXplID0gODtcbiAgY29uc3Qgd2lkdGggPSBpbWFnZTEuZ2V0V2lkdGgoKTtcbiAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UxLmdldEhlaWdodCgpO1xuICBmb3IgKGxldCB5MiA9IDA7IHkyIDwgaGVpZ2h0OyB5MiArPSB3aW5kb3dTaXplKSB7XG4gICAgZm9yIChsZXQgeDIgPSAwOyB4MiA8IHdpZHRoOyB4MiArPSB3aW5kb3dTaXplKSB7XG4gICAgICBjb25zdCB3aW5kb3dXaWR0aCA9IE1hdGgubWluKHdpbmRvd1NpemUsIHdpZHRoIC0geDIpO1xuICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gTWF0aC5taW4od2luZG93U2l6ZSwgaGVpZ2h0IC0geTIpO1xuICAgICAgY29uc3QgbHVtYVZhbHVlczEgPSBjYWxjdWxhdGVMdW1hVmFsdWVzRm9yV2luZG93KGltYWdlMSwgeDIsIHkyLCB3aW5kb3dXaWR0aCwgd2luZG93SGVpZ2h0KTtcbiAgICAgIGNvbnN0IGx1bWFWYWx1ZXMyID0gY2FsY3VsYXRlTHVtYVZhbHVlc0ZvcldpbmRvdyhpbWFnZTIsIHgyLCB5Miwgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodCk7XG4gICAgICBjb25zdCBhdmVyYWdlTHVtYTEgPSBjYWxjdWxhdGVBdmVyYWdlTHVtYShsdW1hVmFsdWVzMSk7XG4gICAgICBjb25zdCBhdmVyYWdlTHVtYTIgPSBjYWxjdWxhdGVBdmVyYWdlTHVtYShsdW1hVmFsdWVzMik7XG4gICAgICBjYWxsYmFjayhsdW1hVmFsdWVzMSwgbHVtYVZhbHVlczIsIGF2ZXJhZ2VMdW1hMSwgYXZlcmFnZUx1bWEyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUx1bWFWYWx1ZXNGb3JXaW5kb3coaW1hZ2UsIHgyLCB5Miwgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCBwb2ludEFycmF5ID0gaW1hZ2UuZ2V0UG9pbnRBcnJheSgpO1xuICBjb25zdCBsdW1hVmFsdWVzID0gW107XG4gIGxldCBjb3VudGVyID0gMDtcbiAgZm9yIChsZXQgaiA9IHkyOyBqIDwgeTIgKyBoZWlnaHQ7IGorKykge1xuICAgIGNvbnN0IG9mZnNldCA9IGogKiBpbWFnZS5nZXRXaWR0aCgpO1xuICAgIGZvciAobGV0IGkgPSB4MjsgaSA8IHgyICsgd2lkdGg7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludEFycmF5W29mZnNldCArIGldO1xuICAgICAgbHVtYVZhbHVlc1tjb3VudGVyXSA9IHBvaW50LnIgKiAwLjIxMjYgLyogUkVEICovICsgcG9pbnQuZyAqIDAuNzE1MiAvKiBHUkVFTiAqLyArIHBvaW50LmIgKiAwLjA3MjIgLyogQkxVRSAqLztcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGx1bWFWYWx1ZXM7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVBdmVyYWdlTHVtYShsdW1hVmFsdWVzKSB7XG4gIGxldCBzdW1MdW1hID0gMDtcbiAgZm9yIChjb25zdCBsdW1hIG9mIGx1bWFWYWx1ZXMpIHtcbiAgICBzdW1MdW1hICs9IGx1bWE7XG4gIH1cbiAgcmV0dXJuIHN1bUx1bWEgLyBsdW1hVmFsdWVzLmxlbmd0aDtcbn1cblxuLy8gc3JjL2Jhc2ljQVBJLnRzXG52YXIgc2V0SW1tZWRpYXRlSW1wbCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiAocHJvY2VzcyA9PSBudWxsID8gdm9pZCAwIDogcHJvY2Vzcy5uZXh0VGljaykgPT09IFwiZnVuY3Rpb25cIiA/IChjYWxsYmFjaykgPT4gcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaykgOiAoY2FsbGJhY2spID0+IHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuZnVuY3Rpb24gYnVpbGRQYWxldHRlU3luYyhpbWFnZXMsIHtcbiAgY29sb3JEaXN0YW5jZUZvcm11bGEsXG4gIHBhbGV0dGVRdWFudGl6YXRpb24sXG4gIGNvbG9yc1xufSA9IHt9KSB7XG4gIGNvbnN0IGRpc3RhbmNlQ2FsY3VsYXRvciA9IGNvbG9yRGlzdGFuY2VGb3JtdWxhVG9Db2xvckRpc3RhbmNlKGNvbG9yRGlzdGFuY2VGb3JtdWxhKTtcbiAgY29uc3QgcGFsZXR0ZVF1YW50aXplciA9IHBhbGV0dGVRdWFudGl6YXRpb25Ub1BhbGV0dGVRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBwYWxldHRlUXVhbnRpemF0aW9uLCBjb2xvcnMpO1xuICBpbWFnZXMuZm9yRWFjaCgoaW1hZ2UpID0+IHBhbGV0dGVRdWFudGl6ZXIuc2FtcGxlKGltYWdlKSk7XG4gIHJldHVybiBwYWxldHRlUXVhbnRpemVyLnF1YW50aXplU3luYygpO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRQYWxldHRlKGltYWdlcywge1xuICBjb2xvckRpc3RhbmNlRm9ybXVsYSxcbiAgcGFsZXR0ZVF1YW50aXphdGlvbixcbiAgY29sb3JzLFxuICBvblByb2dyZXNzXG59ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBkaXN0YW5jZUNhbGN1bGF0b3IgPSBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSk7XG4gICAgY29uc3QgcGFsZXR0ZVF1YW50aXplciA9IHBhbGV0dGVRdWFudGl6YXRpb25Ub1BhbGV0dGVRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBwYWxldHRlUXVhbnRpemF0aW9uLCBjb2xvcnMpO1xuICAgIGltYWdlcy5mb3JFYWNoKChpbWFnZSkgPT4gcGFsZXR0ZVF1YW50aXplci5zYW1wbGUoaW1hZ2UpKTtcbiAgICBsZXQgcGFsZXR0ZTtcbiAgICBjb25zdCBpdGVyYXRvciA9IHBhbGV0dGVRdWFudGl6ZXIucXVhbnRpemUoKTtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKHBhbGV0dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUucGFsZXR0ZSlcbiAgICAgICAgICAgIHBhbGV0dGUgPSByZXN1bHQudmFsdWUucGFsZXR0ZTtcbiAgICAgICAgICBpZiAob25Qcm9ncmVzcylcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MocmVzdWx0LnZhbHVlLnByb2dyZXNzKTtcbiAgICAgICAgICBzZXRJbW1lZGlhdGVJbXBsKG5leHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2V0SW1tZWRpYXRlSW1wbChuZXh0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhcHBseVBhbGV0dGVTeW5jKGltYWdlLCBwYWxldHRlLCB7IGNvbG9yRGlzdGFuY2VGb3JtdWxhLCBpbWFnZVF1YW50aXphdGlvbiB9ID0ge30pIHtcbiAgY29uc3QgZGlzdGFuY2VDYWxjdWxhdG9yID0gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEpO1xuICBjb25zdCBpbWFnZVF1YW50aXplciA9IGltYWdlUXVhbnRpemF0aW9uVG9JbWFnZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlUXVhbnRpemF0aW9uKTtcbiAgcmV0dXJuIGltYWdlUXVhbnRpemVyLnF1YW50aXplU3luYyhpbWFnZSwgcGFsZXR0ZSk7XG59XG5hc3luYyBmdW5jdGlvbiBhcHBseVBhbGV0dGUoaW1hZ2UsIHBhbGV0dGUsIHtcbiAgY29sb3JEaXN0YW5jZUZvcm11bGEsXG4gIGltYWdlUXVhbnRpemF0aW9uLFxuICBvblByb2dyZXNzXG59ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBkaXN0YW5jZUNhbGN1bGF0b3IgPSBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSk7XG4gICAgY29uc3QgaW1hZ2VRdWFudGl6ZXIgPSBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbik7XG4gICAgbGV0IG91dFBvaW50Q29udGFpbmVyO1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gaW1hZ2VRdWFudGl6ZXIucXVhbnRpemUoaW1hZ2UsIHBhbGV0dGUpO1xuICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUob3V0UG9pbnRDb250YWluZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUucG9pbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgIG91dFBvaW50Q29udGFpbmVyID0gcmVzdWx0LnZhbHVlLnBvaW50Q29udGFpbmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob25Qcm9ncmVzcylcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MocmVzdWx0LnZhbHVlLnByb2dyZXNzKTtcbiAgICAgICAgICBzZXRJbW1lZGlhdGVJbXBsKG5leHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2V0SW1tZWRpYXRlSW1wbChuZXh0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSA9IFwiZXVjbGlkZWFuLWJ0NzA5XCIpIHtcbiAgc3dpdGNoIChjb2xvckRpc3RhbmNlRm9ybXVsYSkge1xuICAgIGNhc2UgXCJjaWU5NC1ncmFwaGljLWFydHNcIjpcbiAgICAgIHJldHVybiBuZXcgQ0lFOTRHcmFwaGljQXJ0cygpO1xuICAgIGNhc2UgXCJjaWU5NC10ZXh0aWxlc1wiOlxuICAgICAgcmV0dXJuIG5ldyBDSUU5NFRleHRpbGVzKCk7XG4gICAgY2FzZSBcImNpZWRlMjAwMFwiOlxuICAgICAgcmV0dXJuIG5ldyBDSUVERTIwMDAoKTtcbiAgICBjYXNlIFwiY29sb3ItbWV0cmljXCI6XG4gICAgICByZXR1cm4gbmV3IENNZXRyaWMoKTtcbiAgICBjYXNlIFwiZXVjbGlkZWFuXCI6XG4gICAgICByZXR1cm4gbmV3IEV1Y2xpZGVhbigpO1xuICAgIGNhc2UgXCJldWNsaWRlYW4tYnQ3MDlcIjpcbiAgICAgIHJldHVybiBuZXcgRXVjbGlkZWFuQlQ3MDkoKTtcbiAgICBjYXNlIFwiZXVjbGlkZWFuLWJ0NzA5LW5vYWxwaGFcIjpcbiAgICAgIHJldHVybiBuZXcgRXVjbGlkZWFuQlQ3MDlOb0FscGhhKCk7XG4gICAgY2FzZSBcIm1hbmhhdHRhblwiOlxuICAgICAgcmV0dXJuIG5ldyBNYW5oYXR0YW4oKTtcbiAgICBjYXNlIFwibWFuaGF0dGFuLWJ0NzA5XCI6XG4gICAgICByZXR1cm4gbmV3IE1hbmhhdHRhbkJUNzA5KCk7XG4gICAgY2FzZSBcIm1hbmhhdHRhbi1ub21teWRlXCI6XG4gICAgICByZXR1cm4gbmV3IE1hbmhhdHRhbk5vbW15ZGUoKTtcbiAgICBjYXNlIFwicG5ncXVhbnRcIjpcbiAgICAgIHJldHVybiBuZXcgUE5HUXVhbnQoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbG9yRGlzdGFuY2VGb3JtdWxhICR7Y29sb3JEaXN0YW5jZUZvcm11bGF9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGltYWdlUXVhbnRpemF0aW9uVG9JbWFnZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIGltYWdlUXVhbnRpemF0aW9uID0gXCJmbG95ZC1zdGVpbmJlcmdcIikge1xuICBzd2l0Y2ggKGltYWdlUXVhbnRpemF0aW9uKSB7XG4gICAgY2FzZSBcIm5lYXJlc3RcIjpcbiAgICAgIHJldHVybiBuZXcgTmVhcmVzdENvbG9yKGRpc3RhbmNlQ2FsY3VsYXRvcik7XG4gICAgY2FzZSBcInJpZW1lcnNtYVwiOlxuICAgICAgcmV0dXJuIG5ldyBFcnJvckRpZmZ1c2lvblJpZW1lcnNtYShkaXN0YW5jZUNhbGN1bGF0b3IpO1xuICAgIGNhc2UgXCJmbG95ZC1zdGVpbmJlcmdcIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIDAgLyogRmxveWRTdGVpbmJlcmcgKi8pO1xuICAgIGNhc2UgXCJmYWxzZS1mbG95ZC1zdGVpbmJlcmdcIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIDEgLyogRmFsc2VGbG95ZFN0ZWluYmVyZyAqLyk7XG4gICAgY2FzZSBcInN0dWNraVwiOlxuICAgICAgcmV0dXJuIG5ldyBFcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgMiAvKiBTdHVja2kgKi8pO1xuICAgIGNhc2UgXCJhdGtpbnNvblwiOlxuICAgICAgcmV0dXJuIG5ldyBFcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgMyAvKiBBdGtpbnNvbiAqLyk7XG4gICAgY2FzZSBcImphcnZpc1wiOlxuICAgICAgcmV0dXJuIG5ldyBFcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgNCAvKiBKYXJ2aXMgKi8pO1xuICAgIGNhc2UgXCJidXJrZXNcIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIDUgLyogQnVya2VzICovKTtcbiAgICBjYXNlIFwic2llcnJhXCI6XG4gICAgICByZXR1cm4gbmV3IEVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCA2IC8qIFNpZXJyYSAqLyk7XG4gICAgY2FzZSBcInR3by1zaWVycmFcIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIDcgLyogVHdvU2llcnJhICovKTtcbiAgICBjYXNlIFwic2llcnJhLWxpdGVcIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIDggLyogU2llcnJhTGl0ZSAqLyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBpbWFnZVF1YW50aXphdGlvbiAke2ltYWdlUXVhbnRpemF0aW9ufWApO1xuICB9XG59XG5mdW5jdGlvbiBwYWxldHRlUXVhbnRpemF0aW9uVG9QYWxldHRlUXVhbnRpemVyKGRpc3RhbmNlQ2FsY3VsYXRvciwgcGFsZXR0ZVF1YW50aXphdGlvbiA9IFwid3VxdWFudFwiLCBjb2xvcnMgPSAyNTYpIHtcbiAgc3dpdGNoIChwYWxldHRlUXVhbnRpemF0aW9uKSB7XG4gICAgY2FzZSBcIm5ldXF1YW50XCI6XG4gICAgICByZXR1cm4gbmV3IE5ldVF1YW50KGRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzKTtcbiAgICBjYXNlIFwicmdicXVhbnRcIjpcbiAgICAgIHJldHVybiBuZXcgUkdCUXVhbnQoZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xuICAgIGNhc2UgXCJ3dXF1YW50XCI6XG4gICAgICByZXR1cm4gbmV3IFd1UXVhbnQoZGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMpO1xuICAgIGNhc2UgXCJuZXVxdWFudC1mbG9hdFwiOlxuICAgICAgcmV0dXJuIG5ldyBOZXVRdWFudEZsb2F0KGRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhbGV0dGVRdWFudGl6YXRpb24gJHtwYWxldHRlUXVhbnRpemF0aW9ufWApO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBwbHlQYWxldHRlLFxuICBhcHBseVBhbGV0dGVTeW5jLFxuICBidWlsZFBhbGV0dGUsXG4gIGJ1aWxkUGFsZXR0ZVN5bmMsXG4gIGNvbnN0YW50cyxcbiAgY29udmVyc2lvbixcbiAgZGlzdGFuY2UsXG4gIGltYWdlLFxuICBwYWxldHRlLFxuICBxdWFsaXR5LFxuICB1dGlsc1xufSk7XG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogY2llOTQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBjaWVkZTIwMDAudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBjbWV0cmljLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogY29tbW9uLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogY29uc3RhbnRzLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogZGl0aGVyRXJyb3JEaWZmdXNpb25BcnJheS50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGV1Y2xpZGVhbi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGhlbHBlci50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGh1ZVN0YXRpc3RpY3MudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBpcS50cyAtIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBsYWIycmdiLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogbGFiMnh5ei50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIG1hbmhhdHRhbk5ldVF1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogbmVhcmVzdENvbG9yLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogcGFsZXR0ZS50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHBuZ1F1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogcG9pbnQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBwb2ludENvbnRhaW5lci50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHJnYjJoc2wudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiByZ2IybGFiLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogcmdiMnh5ei50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHNzaW0udHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiB3dVF1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogeHl6MmxhYi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHh5ejJyZ2IudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbiAqIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4gKiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiAqIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAqIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiByaWVtZXJzbWEudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlIFR5cGVTY3JpcHQgcG9ydDpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGNvbG9ySGlzdG9ncmFtLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZSBUeXBlU2NyaXB0IHBvcnQ6XG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBuZXVxdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmUgVHlwZVNjcmlwdCBwb3J0OlxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogcmdicXVhbnQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLXEuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/image-q/dist/cjs/image-q.cjs\n");

/***/ })

};
;