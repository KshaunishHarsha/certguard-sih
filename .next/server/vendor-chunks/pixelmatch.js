"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pixelmatch";
exports.ids = ["vendor-chunks/pixelmatch"];
exports.modules = {

/***/ "(action-browser)/./node_modules/pixelmatch/index.js":
/*!******************************************!*\
  !*** ./node_modules/pixelmatch/index.js ***!
  \******************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = pixelmatch;\n\nfunction pixelmatch(img1, img2, output, width, height, options) {\n\n    if (!options) options = {};\n\n    var threshold = options.threshold === undefined ? 0.1 : options.threshold;\n\n    // maximum acceptable square distance between two colors;\n    // 35215 is the maximum possible value for the YIQ difference metric\n    var maxDelta = 35215 * threshold * threshold,\n        diff = 0;\n\n    // compare each pixel of one image against the other one\n    for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n\n            var pos = (y * width + x) * 4;\n\n            // squared YUV distance between colors at this pixel position\n            var delta = colorDelta(img1, img2, pos, pos);\n\n            // the color difference is above the threshold\n            if (delta > maxDelta) {\n                // check it's a real rendering difference or just anti-aliasing\n                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) ||\n                                   antialiased(img2, x, y, width, height, img1))) {\n                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference\n                    if (output) drawPixel(output, pos, 255, 255, 0);\n\n                } else {\n                    // found substantial difference not caused by anti-aliasing; draw it as red\n                    if (output) drawPixel(output, pos, 255, 0, 0);\n                    diff++;\n                }\n\n            } else if (output) {\n                // pixels are similar; draw background as grayscale image blended with white\n                var val = blend(grayPixel(img1, pos), 0.1);\n                drawPixel(output, pos, val, val, val);\n            }\n        }\n    }\n\n    // return the number of different pixels\n    return diff;\n}\n\n// check if a pixel is likely a part of anti-aliasing;\n// based on \"Anti-aliased Pixel and Intensity Slope Detector\" paper by V. Vysniauskas, 2009\n\nfunction antialiased(img, x1, y1, width, height, img2) {\n    var x0 = Math.max(x1 - 1, 0),\n        y0 = Math.max(y1 - 1, 0),\n        x2 = Math.min(x1 + 1, width - 1),\n        y2 = Math.min(y1 + 1, height - 1),\n        pos = (y1 * width + x1) * 4,\n        zeroes = 0,\n        positives = 0,\n        negatives = 0,\n        min = 0,\n        max = 0,\n        minX, minY, maxX, maxY;\n\n    // go through 8 adjacent pixels\n    for (var x = x0; x <= x2; x++) {\n        for (var y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            // brightness delta between the center pixel and adjacent one\n            var delta = colorDelta(img, img, pos, (y * width + x) * 4, true);\n\n            // count the number of equal, darker and brighter adjacent pixels\n            if (delta === 0) zeroes++;\n            else if (delta < 0) negatives++;\n            else if (delta > 0) positives++;\n\n            // if found more than 2 equal siblings, it's definitely not anti-aliasing\n            if (zeroes > 2) return false;\n\n            if (!img2) continue;\n\n            // remember the darkest pixel\n            if (delta < min) {\n                min = delta;\n                minX = x;\n                minY = y;\n            }\n            // remember the brightest pixel\n            if (delta > max) {\n                max = delta;\n                maxX = x;\n                maxY = y;\n            }\n        }\n    }\n\n    if (!img2) return true;\n\n    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing\n    if (negatives === 0 || positives === 0) return false;\n\n    // if either the darkest or the brightest pixel has more than 2 equal siblings in both images\n    // (definitely not anti-aliased), this pixel is anti-aliased\n    return (!antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height)) ||\n           (!antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height));\n}\n\n// calculate color difference according to the paper \"Measuring perceived color difference\n// using YIQ NTSC transmission color space in mobile applications\" by Y. Kotsarenko and F. Ramos\n\nfunction colorDelta(img1, img2, k, m, yOnly) {\n    var a1 = img1[k + 3] / 255,\n        a2 = img2[m + 3] / 255,\n\n        r1 = blend(img1[k + 0], a1),\n        g1 = blend(img1[k + 1], a1),\n        b1 = blend(img1[k + 2], a1),\n\n        r2 = blend(img2[m + 0], a2),\n        g2 = blend(img2[m + 1], a2),\n        b2 = blend(img2[m + 2], a2),\n\n        y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);\n\n    if (yOnly) return y; // brightness difference only\n\n    var i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2),\n        q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);\n\n    return 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;\n}\n\nfunction rgb2y(r, g, b) { return r * 0.29889531 + g * 0.58662247 + b * 0.11448223; }\nfunction rgb2i(r, g, b) { return r * 0.59597799 - g * 0.27417610 - b * 0.32180189; }\nfunction rgb2q(r, g, b) { return r * 0.21147017 - g * 0.52261711 + b * 0.31114694; }\n\n// blend semi-transparent color with white\nfunction blend(c, a) {\n    return 255 + (c - 255) * a;\n}\n\nfunction drawPixel(output, pos, r, g, b) {\n    output[pos + 0] = r;\n    output[pos + 1] = g;\n    output[pos + 2] = b;\n    output[pos + 3] = 255;\n}\n\nfunction grayPixel(img, i) {\n    var a = img[i + 3] / 255,\n        r = blend(img[i + 0], a),\n        g = blend(img[i + 1], a),\n        b = blend(img[i + 2], a);\n    return rgb2y(r, g, b);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9waXhlbG1hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsd0JBQXdCLFdBQVc7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQSxrQkFBa0I7QUFDbEIsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUIseUJBQXlCLFNBQVM7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL3BpeGVsbWF0Y2gvaW5kZXguanM/ODRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGl4ZWxtYXRjaDtcblxuZnVuY3Rpb24gcGl4ZWxtYXRjaChpbWcxLCBpbWcyLCBvdXRwdXQsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gICAgdmFyIHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkID09PSB1bmRlZmluZWQgPyAwLjEgOiBvcHRpb25zLnRocmVzaG9sZDtcblxuICAgIC8vIG1heGltdW0gYWNjZXB0YWJsZSBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiB0d28gY29sb3JzO1xuICAgIC8vIDM1MjE1IGlzIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIGZvciB0aGUgWUlRIGRpZmZlcmVuY2UgbWV0cmljXG4gICAgdmFyIG1heERlbHRhID0gMzUyMTUgKiB0aHJlc2hvbGQgKiB0aHJlc2hvbGQsXG4gICAgICAgIGRpZmYgPSAwO1xuXG4gICAgLy8gY29tcGFyZSBlYWNoIHBpeGVsIG9mIG9uZSBpbWFnZSBhZ2FpbnN0IHRoZSBvdGhlciBvbmVcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuXG4gICAgICAgICAgICB2YXIgcG9zID0gKHkgKiB3aWR0aCArIHgpICogNDtcblxuICAgICAgICAgICAgLy8gc3F1YXJlZCBZVVYgZGlzdGFuY2UgYmV0d2VlbiBjb2xvcnMgYXQgdGhpcyBwaXhlbCBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGRlbHRhID0gY29sb3JEZWx0YShpbWcxLCBpbWcyLCBwb3MsIHBvcyk7XG5cbiAgICAgICAgICAgIC8vIHRoZSBjb2xvciBkaWZmZXJlbmNlIGlzIGFib3ZlIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IG1heERlbHRhKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaXQncyBhIHJlYWwgcmVuZGVyaW5nIGRpZmZlcmVuY2Ugb3IganVzdCBhbnRpLWFsaWFzaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmluY2x1ZGVBQSAmJiAoYW50aWFsaWFzZWQoaW1nMSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgaW1nMikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWFsaWFzZWQoaW1nMiwgeCwgeSwgd2lkdGgsIGhlaWdodCwgaW1nMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uZSBvZiB0aGUgcGl4ZWxzIGlzIGFudGktYWxpYXNpbmc7IGRyYXcgYXMgeWVsbG93IGFuZCBkbyBub3QgY291bnQgYXMgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0KSBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIDI1NSwgMjU1LCAwKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIHN1YnN0YW50aWFsIGRpZmZlcmVuY2Ugbm90IGNhdXNlZCBieSBhbnRpLWFsaWFzaW5nOyBkcmF3IGl0IGFzIHJlZFxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0KSBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIDI1NSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gcGl4ZWxzIGFyZSBzaW1pbGFyOyBkcmF3IGJhY2tncm91bmQgYXMgZ3JheXNjYWxlIGltYWdlIGJsZW5kZWQgd2l0aCB3aGl0ZVxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBibGVuZChncmF5UGl4ZWwoaW1nMSwgcG9zKSwgMC4xKTtcbiAgICAgICAgICAgICAgICBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIHZhbCwgdmFsLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW50IHBpeGVsc1xuICAgIHJldHVybiBkaWZmO1xufVxuXG4vLyBjaGVjayBpZiBhIHBpeGVsIGlzIGxpa2VseSBhIHBhcnQgb2YgYW50aS1hbGlhc2luZztcbi8vIGJhc2VkIG9uIFwiQW50aS1hbGlhc2VkIFBpeGVsIGFuZCBJbnRlbnNpdHkgU2xvcGUgRGV0ZWN0b3JcIiBwYXBlciBieSBWLiBWeXNuaWF1c2thcywgMjAwOVxuXG5mdW5jdGlvbiBhbnRpYWxpYXNlZChpbWcsIHgxLCB5MSwgd2lkdGgsIGhlaWdodCwgaW1nMikge1xuICAgIHZhciB4MCA9IE1hdGgubWF4KHgxIC0gMSwgMCksXG4gICAgICAgIHkwID0gTWF0aC5tYXgoeTEgLSAxLCAwKSxcbiAgICAgICAgeDIgPSBNYXRoLm1pbih4MSArIDEsIHdpZHRoIC0gMSksXG4gICAgICAgIHkyID0gTWF0aC5taW4oeTEgKyAxLCBoZWlnaHQgLSAxKSxcbiAgICAgICAgcG9zID0gKHkxICogd2lkdGggKyB4MSkgKiA0LFxuICAgICAgICB6ZXJvZXMgPSAwLFxuICAgICAgICBwb3NpdGl2ZXMgPSAwLFxuICAgICAgICBuZWdhdGl2ZXMgPSAwLFxuICAgICAgICBtaW4gPSAwLFxuICAgICAgICBtYXggPSAwLFxuICAgICAgICBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuXG4gICAgLy8gZ28gdGhyb3VnaCA4IGFkamFjZW50IHBpeGVsc1xuICAgIGZvciAodmFyIHggPSB4MDsgeCA8PSB4MjsgeCsrKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSB5MDsgeSA8PSB5MjsgeSsrKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0geDEgJiYgeSA9PT0geTEpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBicmlnaHRuZXNzIGRlbHRhIGJldHdlZW4gdGhlIGNlbnRlciBwaXhlbCBhbmQgYWRqYWNlbnQgb25lXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBjb2xvckRlbHRhKGltZywgaW1nLCBwb3MsICh5ICogd2lkdGggKyB4KSAqIDQsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIGVxdWFsLCBkYXJrZXIgYW5kIGJyaWdodGVyIGFkamFjZW50IHBpeGVsc1xuICAgICAgICAgICAgaWYgKGRlbHRhID09PSAwKSB6ZXJvZXMrKztcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkgbmVnYXRpdmVzKys7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YSA+IDApIHBvc2l0aXZlcysrO1xuXG4gICAgICAgICAgICAvLyBpZiBmb3VuZCBtb3JlIHRoYW4gMiBlcXVhbCBzaWJsaW5ncywgaXQncyBkZWZpbml0ZWx5IG5vdCBhbnRpLWFsaWFzaW5nXG4gICAgICAgICAgICBpZiAoemVyb2VzID4gMikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIWltZzIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgZGFya2VzdCBwaXhlbFxuICAgICAgICAgICAgaWYgKGRlbHRhIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgbWluWCA9IHg7XG4gICAgICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgYnJpZ2h0ZXN0IHBpeGVsXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBtYXhYID0geDtcbiAgICAgICAgICAgICAgICBtYXhZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW1nMikgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gYm90aCBkYXJrZXIgYW5kIGJyaWdodGVyIHBpeGVscyBhbW9uZyBzaWJsaW5ncywgaXQncyBub3QgYW50aS1hbGlhc2luZ1xuICAgIGlmIChuZWdhdGl2ZXMgPT09IDAgfHwgcG9zaXRpdmVzID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBpZiBlaXRoZXIgdGhlIGRhcmtlc3Qgb3IgdGhlIGJyaWdodGVzdCBwaXhlbCBoYXMgbW9yZSB0aGFuIDIgZXF1YWwgc2libGluZ3MgaW4gYm90aCBpbWFnZXNcbiAgICAvLyAoZGVmaW5pdGVseSBub3QgYW50aS1hbGlhc2VkKSwgdGhpcyBwaXhlbCBpcyBhbnRpLWFsaWFzZWRcbiAgICByZXR1cm4gKCFhbnRpYWxpYXNlZChpbWcsIG1pblgsIG1pblksIHdpZHRoLCBoZWlnaHQpICYmICFhbnRpYWxpYXNlZChpbWcyLCBtaW5YLCBtaW5ZLCB3aWR0aCwgaGVpZ2h0KSkgfHxcbiAgICAgICAgICAgKCFhbnRpYWxpYXNlZChpbWcsIG1heFgsIG1heFksIHdpZHRoLCBoZWlnaHQpICYmICFhbnRpYWxpYXNlZChpbWcyLCBtYXhYLCBtYXhZLCB3aWR0aCwgaGVpZ2h0KSk7XG59XG5cbi8vIGNhbGN1bGF0ZSBjb2xvciBkaWZmZXJlbmNlIGFjY29yZGluZyB0byB0aGUgcGFwZXIgXCJNZWFzdXJpbmcgcGVyY2VpdmVkIGNvbG9yIGRpZmZlcmVuY2Vcbi8vIHVzaW5nIFlJUSBOVFNDIHRyYW5zbWlzc2lvbiBjb2xvciBzcGFjZSBpbiBtb2JpbGUgYXBwbGljYXRpb25zXCIgYnkgWS4gS290c2FyZW5rbyBhbmQgRi4gUmFtb3NcblxuZnVuY3Rpb24gY29sb3JEZWx0YShpbWcxLCBpbWcyLCBrLCBtLCB5T25seSkge1xuICAgIHZhciBhMSA9IGltZzFbayArIDNdIC8gMjU1LFxuICAgICAgICBhMiA9IGltZzJbbSArIDNdIC8gMjU1LFxuXG4gICAgICAgIHIxID0gYmxlbmQoaW1nMVtrICsgMF0sIGExKSxcbiAgICAgICAgZzEgPSBibGVuZChpbWcxW2sgKyAxXSwgYTEpLFxuICAgICAgICBiMSA9IGJsZW5kKGltZzFbayArIDJdLCBhMSksXG5cbiAgICAgICAgcjIgPSBibGVuZChpbWcyW20gKyAwXSwgYTIpLFxuICAgICAgICBnMiA9IGJsZW5kKGltZzJbbSArIDFdLCBhMiksXG4gICAgICAgIGIyID0gYmxlbmQoaW1nMlttICsgMl0sIGEyKSxcblxuICAgICAgICB5ID0gcmdiMnkocjEsIGcxLCBiMSkgLSByZ2IyeShyMiwgZzIsIGIyKTtcblxuICAgIGlmICh5T25seSkgcmV0dXJuIHk7IC8vIGJyaWdodG5lc3MgZGlmZmVyZW5jZSBvbmx5XG5cbiAgICB2YXIgaSA9IHJnYjJpKHIxLCBnMSwgYjEpIC0gcmdiMmkocjIsIGcyLCBiMiksXG4gICAgICAgIHEgPSByZ2IycShyMSwgZzEsIGIxKSAtIHJnYjJxKHIyLCBnMiwgYjIpO1xuXG4gICAgcmV0dXJuIDAuNTA1MyAqIHkgKiB5ICsgMC4yOTkgKiBpICogaSArIDAuMTk1NyAqIHEgKiBxO1xufVxuXG5mdW5jdGlvbiByZ2IyeShyLCBnLCBiKSB7IHJldHVybiByICogMC4yOTg4OTUzMSArIGcgKiAwLjU4NjYyMjQ3ICsgYiAqIDAuMTE0NDgyMjM7IH1cbmZ1bmN0aW9uIHJnYjJpKHIsIGcsIGIpIHsgcmV0dXJuIHIgKiAwLjU5NTk3Nzk5IC0gZyAqIDAuMjc0MTc2MTAgLSBiICogMC4zMjE4MDE4OTsgfVxuZnVuY3Rpb24gcmdiMnEociwgZywgYikgeyByZXR1cm4gciAqIDAuMjExNDcwMTcgLSBnICogMC41MjI2MTcxMSArIGIgKiAwLjMxMTE0Njk0OyB9XG5cbi8vIGJsZW5kIHNlbWktdHJhbnNwYXJlbnQgY29sb3Igd2l0aCB3aGl0ZVxuZnVuY3Rpb24gYmxlbmQoYywgYSkge1xuICAgIHJldHVybiAyNTUgKyAoYyAtIDI1NSkgKiBhO1xufVxuXG5mdW5jdGlvbiBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIHIsIGcsIGIpIHtcbiAgICBvdXRwdXRbcG9zICsgMF0gPSByO1xuICAgIG91dHB1dFtwb3MgKyAxXSA9IGc7XG4gICAgb3V0cHV0W3BvcyArIDJdID0gYjtcbiAgICBvdXRwdXRbcG9zICsgM10gPSAyNTU7XG59XG5cbmZ1bmN0aW9uIGdyYXlQaXhlbChpbWcsIGkpIHtcbiAgICB2YXIgYSA9IGltZ1tpICsgM10gLyAyNTUsXG4gICAgICAgIHIgPSBibGVuZChpbWdbaSArIDBdLCBhKSxcbiAgICAgICAgZyA9IGJsZW5kKGltZ1tpICsgMV0sIGEpLFxuICAgICAgICBiID0gYmxlbmQoaW1nW2kgKyAyXSwgYSk7XG4gICAgcmV0dXJuIHJnYjJ5KHIsIGcsIGIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/pixelmatch/index.js\n");

/***/ })

};
;